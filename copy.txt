多創: 214

///////////////////////////////////////////////////////////////
//
// lc030. Substring with Concatenation of All Words (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 

另一種解法較簡單，將每個val當作尾巴往前找最小值*上寬度，求最大面積即可。

///////////////////////////////////////////////////////////////
//
// lc101. Symmetric Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc951，遞迴解。
(2) 可用兩個queue去解，對稱式丟入queue(que1丟left，que2就丟right，反之)。

///////////////////////////////////////////////////////////////
//
// lc102. Binary Tree Level Order Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dfs：
    每次call dfs將當前的val放入output。
    若output size <= 當前level，則new一vector並push_back，
    反之就對於相應位置的vector用push_back。
    當left or right!= NULL，就call並傳入當前level+1。

(2) bfs：
    預設qsize = 1，並把root丟到queue
    當queue不是空的，將head的孩子丟到queue裡並pop。
    每次pop就qsize--並且把pop的元素加入vec
    當qsize = 0，將vec push_back到output並讓qsize = 當前queue.size()。

///////////////////////////////////////////////////////////////
//
// lc103. Binary Tree Zigzag Level Order Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用bfs印出左到右，當為由到左時，reverse (有不用STL function的方法)。

///////////////////////////////////////////////////////////////
//
// lc104. Maximum Depth of Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，return對於左子樹和右子樹取大者再+1。

///////////////////////////////////////////////////////////////
//
// lc105. Construct Binary Tree from Preorder and Inorder Traversal (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遞迴解。
(2) iteration with stack，
    push preorder into stack and pop with inorder。
    push左半邊並建左半邊樹，
    pop直到左半邊都結束就可將下一個root接到右孩子，在繼續往右孩子的左半邊做。

///////////////////////////////////////////////////////////////
//
// lc106. Construct Binary Tree from Inorder and Postorder Traversal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc105。
(1) postorder的最後一個是root，就如同preorder的第一個是root，利用這規律make tree。
(2) 類似lc105 iteration，但從尾巴開始。
    similar as preorder and inorder traversal but start from last of the array
    since postorder is the inverse of preorder when viewing from the end of the array

///////////////////////////////////////////////////////////////
//
// lc107. Binary Tree Level Order Traversal II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc102一模一樣，可用bfd或dfs。

///////////////////////////////////////////////////////////////
//
// lc108. Convert Sorted Array to Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到陣列中間，當root，遞迴跑root->left, root->right。
    binary search。

///////////////////////////////////////////////////////////////
//
// lc109. Convert Sorted List to Binary Search Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用快慢指針找出中間點，遞迴找left & right
    利用頭尾當邊界來算出中間點，當頭=尾，return NULL。

///////////////////////////////////////////////////////////////
//
// lc110. Balanced Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用postorder遍歷到底端後往top計算深度，當前節點為最大深度為max(左節點,右節點)+1
(2) 用preorder計算當前節點的最大深度: max(左節點,右節點)，由上往下遍歷

///////////////////////////////////////////////////////////////
//
// lc111. Minimum Depth of Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，因為要從葉子往上算，所以當前節點中只有一子樹為null的話，往另一個子數做遞迴。
    遇到null，return 0。

///////////////////////////////////////////////////////////////
//
// lc112. Path Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc111，因為要從葉子往上算，所以當前節點中只有一子樹為null的話，往另一個子數做遞迴。
    遇到葉子去看sum有沒有和葉子的val一樣。

///////////////////////////////////////////////////////////////
//
// lc113. Path Sum II (看) 沒想到從上往下，思路卡在由下往上做。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用preorder (dfs) 解。

///////////////////////////////////////////////////////////////
//
// lc114. Flatten Binary Tree to Linked List (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs recursion，使用dummy。
(2) 將右子樹放到左子樹的最右邊，將左子樹放到右子樹，左子樹=NULL。

///////////////////////////////////////////////////////////////
//
// lc116. Populating Next Right Pointers in Each Node
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 與lc117一樣作法。

///////////////////////////////////////////////////////////////
//
// lc117. Populating Next Right Pointers in Each Node II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method  1

(1) 實作queue，
    紀錄當前level的點：now，head和rear紀錄當前層的下一層。
    當把now的left和right加入queue後，now = now->next，
    若now為NULL代表該層已做完，更新now至下層的頭：head，然後head = rear = NULL。

(2) 實作queue，(自己想的)
    紀錄當前和上一層的queue size，每加入一個元素至queue，當前q_size+1
    每次pop時，上層q_size減一，當等於0的時候代表該層已全處理完，
    更新上層q_size至當前queue的size，(代表移往下層做處理)，
    並將該次pop出的元素->next指向NULL。

(3) 利用STL容器queue，並跑bfs，紀錄當前level的size:q_size，
    每次pop就減一，當等於0的時候代表該層已全處理完，
    更新q_size至下一層queue的size，
    並將該次pop出的元素->next指向NULL。

///////////////////////////////////////////////////////////////
//
// lc118. Pascal's Triangle
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc120，從上往下做，注意頭尾邊界處理。

///////////////////////////////////////////////////////////////
//
// lc119. Pascal's Triangle II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc120，差別在這題是取單列，用一個vector紀錄最後一列，當前列用最後一列算出。
    可作空間用化，只用一個vector而非兩個。

///////////////////////////////////////////////////////////////
//
// lc120. Triangle (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用iteration dp解，遞迴會TLE。
    !!!注意O(n) space解法，從底層往上做。
    dp[j] = min(dp[j], dp[j+1]) + triangle[i-1][j]

///////////////////////////////////////////////////////////////
//
// lc121. Best Time to Buy and Sell Stock
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個最小值，為到目前為止的最小買入價格，
    維持一個最大值，為到目前為止的售出價格-買入價格。
    return 最大值。

///////////////////////////////////////////////////////////////
//
// lc122. Best Time to Buy and Sell Stock II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 類似lc309，利用state machine來記錄每個階段的最大利潤s_sell和s_buy。
    賣的狀態：s_sell = max(s_sell, s_buy+prices[i]);
    買的狀態：s_buy = max(s_buy, s_sell-prices[i]);
    return s_sell。
(2) another view ofstate machine

///////////////////////////////////////////////////////////////
//
// lc123. Best Time to Buy and Sell Stock III (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/135704/Detail-explanation-of-DP-solution

(1) dp solution, space: O(kn)
    dp[k][i] = max(dp[k][i-1], price[i]-price[j]+dp[k-1][j-1]), j = 0~i-1
    因為同一輪k，price[j]+dp[k-1][j-1]可以重複使用，省略一個回圈j = 0~i-1。
(2) dp solution, space: O(k)
    將method1 for loop 對調，因為dp[k][i]和dp[k][i-1]為同調，可省略為dp[k]。
    minv[k] = min(minv[k], prices[i]-dp[k-1])
    dp[k] = max(dp[k], prices[i]-minv)
    改寫成variable

    buy1 = max(buy1, -prices[i]);
    sell1 = max(sell1, buy1+prices[i]);
    buy2 = max(buy2, sell1-prices[i]);
    sell2 = max(sell2, buy2+prices[i]);

///////////////////////////////////////////////////////////////
//
// lc124. Binary Tree Maximum Path Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc865。
    利用postorder，
    若該點為路徑最高點，則root->val+leftv+rightv。
    若該點只是經過，則max(root->val+max(leftv,rightv), root->val)。
    ***follow up：返回最大陸路徑和的路徑。

///////////////////////////////////////////////////////////////
//
// lc125. Valid Palindrome
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於不是數字或字母的都跳過，
    比較s[left] == s[right] or (s[left]^32) == s[right]。

///////////////////////////////////////////////////////////////
//
// lc126. Word Ladder II (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bi directional，維持一個unordered_set<string, vector<string>>
    表示當前word的下一步，用來到時候getpath可以串連路線。注意若不是從begin
    開始，加入時要倒著加，可用一變數判斷當前是從end開始還是begin開始。
    和lc127不同的是因為可能當前這輪都會走到同一點，lc127是找到那一點就erase，
    這題不行，不然其他點就走不到，solution會變少，所以做法是做完這一輪再erase所有這輪
    走過的點。

    time complexity:
    Let's call k the max number of neighbors of a node, and d is the distance from start to end. 
    In traditional BFS, we explore k nodes at each BFS level, each one generating in the worst case k 
    neighbors till we find end. So the maximum number of nodes we explore till we reach end is k*k*k...*k, d times. So it's O(k^d).

    In double-ended BFS we finish when the forward and backward searches collide. 
    Where do they collide? Approximately at d/2 distance. Let's call this point mid. 
    So it's O(k^(d/2)) (start to mid) + O(k^(d/2)) (end to mid), yielding O(k^(d/2)). 
    Yes, it's the same class of complexity of standard BFS, 
    but for large graphs double-ended BFS may give you the right result waaaaaaay faster.

///////////////////////////////////////////////////////////////
//
// lc127. Word Ladder (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，bidirectional，對少的詞的一邊做expand。
(2) bfs，對每個詞的每一位，有26個走法，O(n)。
(3) bfs，對每個詞找wordList中和自己差一位的，O(n^2)。

///////////////////////////////////////////////////////////////
//
// lc128. Longest Consecutive Sequence (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) unordered_set
    先將所有element放到set中，然後遍歷vector，如果在set中，erase並且
    往左右找直到找不到，這中間找到的都要erase，然後儲存長度與res比。
(2) unordered_map
    遍歷vector，如果在map中則跳過，不在的話，找出左右一個元素的value，
    sum = left + right + 1。
    且
    map[nums[i]-left] = sum，
    map[nums[i]+right] = sum。
    這目的是一個連續邊界的最大值，這樣下次碰到邊界的旁邊(沒遇到過的，
    在邊界裡的會跳過)，可以直接取該連續數列的長度。

///////////////////////////////////////////////////////////////
//
// lc129. Sum Root to Leaf Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc130. Surrounded Regions
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，從邊上走dfs轉成特殊字母，最後跑一次遍歷，特殊字母轉乘‘O’，其餘
    轉成'X'。

///////////////////////////////////////////////////////////////
//
// lc131. Palindrome Partitioning (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先將i到j是否回文紀錄好，類似lc647。
    再跑dfs，對於每個切的點判斷可不可以切，不可以就跳過，可以就再call dfs。
    time complexity: n*(2^n)。
    f(n) = f(n-1) + f(n-2) + ... + f(1)
    f(n+1) = f(n) + f(n-1) + f(n-2) + ... + f(1)= 2*f(n)
    f(n) = 2^n
    但一個function裡面跑一個O(n) loop，所以:n*2^n。

///////////////////////////////////////////////////////////////
//
// lc133. Clone Graph (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map作為node和clone node的對應，可bfs或dfs。

///////////////////////////////////////////////////////////////
//
// lc134. Gas Station (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若從頭到目前為止和為負的，下一個點當起點，因為之前都是負的表示之前的點都不適合
    當起點，起點必須為一直加都為正的。

///////////////////////////////////////////////////////////////
//
// lc136. Single Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 同樣的數字xor會=0，因此single number會直接維答案。

///////////////////////////////////////////////////////////////
//
// lc137. Single Number II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為xor代表bit相加，我們可以開立目前為止出現一次的bit情況：ones
                                        二次的bit情況：twos
                                        三次的bit情況：threes
    若當前數字和ones做xor一定會有進位問題，表示兩個都1，那我們要先儲存這個1
    到二進位的話，可以先tows = twos | ones & nums;這樣就可以記錄當前數字有1的bit和
    ones也有1的bit，有兩個，進位到twos中。
    再來做一進位的相加 ones = ones ^ nums;
    若ones和two兩者同位都有1表示出現三次，清空。
    return ones即為答案。
(2) 在每一位bit都和所有數字做&，若次數％3不等於0，表示該為有出現一次的值。
    累加這些值在這32位過程即為答案。
follow up：出現兩次的就return twos。
https://www.cnblogs.com/daijinqiao/p/3352893.html

///////////////////////////////////////////////////////////////
//
// lc138. Copy List with Random Pointer (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先複製一份與本來的一樣的點在本來的點的後面，讓複製的點的random指到本來的點的random的next，
    最後將這arr分成兩個即為結果。

///////////////////////////////////////////////////////////////
//
// lc139. Word Break (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dp iteration：
    假設dp[i]表示到i為止都可以被拆分，
    dp[i] = 1 if dp[j]=1且 s[j+1:i]在word list裡。
    細節：找dp時從j = i往0找，因為從0找substr相當於從頭找，會比較慢。
(2) dp recursion：
    類似lc140，所用方法為lc140的精髓，參考lc140。

///////////////////////////////////////////////////////////////
//
// lc140. Word Break II (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於這種return 組合的題目，通常用recurion和記憶模組(unordered_map<string, vector<string>>)。
    因此對於input string，找一個wordDict[i]使得s可被拆分為wordDict[i] + s.substr(wordDict[i].size());
    遞迴下去跑s.substr(wordDict[i].size()) 得到vector<string> recur;
    將其一一和wordDict[i]合併即為map[s]的vector<strin>。
    time complexity: O(2^n)
(2) dp recursion without memorization: 2^n time

    * time分析類似lc131。

///////////////////////////////////////////////////////////////
//
// lc141. Linked List Cycle
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc142，一樣用快慢指針。

///////////////////////////////////////////////////////////////
//
// lc142. Linked List Cycle II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

利用快慢指針所到的交會點，再從此交會點和原點一起順著走，相遇點即為cycle入口。
假設head至入口為a，入口至相遇點為b，相遇點再到入口為c，
2*(a+b) = a+b+n*(b+c) -> a+b = n*(b+c) -> a = (n-1)(b+c) + c;
也就是說從head走到入口的距離等同於從交會點順著走n-1圈後再走長度c。 

///////////////////////////////////////////////////////////////
//
// lc143. Reorder List (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

先用快慢指針算出中間點，把後半段reverse後，和前半段merge。
要注意奇數merge和偶數merge在最後一個node的不同。
*** 更新: merge的時候不用管奇偶數，在找到對半點就將slow->next = NULL就好。
    參考方法一。

///////////////////////////////////////////////////////////////
//
// lc144. Binary Tree Preorder Traversal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 3

(1) 遞迴跑preorder
(2) print當前cur，加入cur->right至stack，cur = cur->left。
    接著若cur是NULL，且stack不為空，則從stack pop出一個。
(3) 和inorder的morris traversal差不多。
    唯一的差別是在push的時候是當cur的left的最右孩子指向null時print cur。

///////////////////////////////////////////////////////////////
//
// lc145. Binary Tree Postorder Traversal (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 3

(1) 遞迴跑postorder
(2) 每次在迴圈開始對stack的top做處理。
    利用一便數控制有沒有自己的孩子有沒有處理過，
    若有自己才能print並pop，且讓便數等於自己。
    若沒有處理過且自己有孩子，將孩子放入stack。
(3) 與preorder或inorder的morris traversal不同
    需要有一個super root，其leftchild = root，
    連接方式和preorder，inorder相同，當cur的左孩子的最右節點為cur時，
    必須倒敘print出，因此後續原理就是每次都倒敘print出從該點往右下斜線所有點。
    (倒著印，當該點的爸爸=右下斜線最後一點的right)。

///////////////////////////////////////////////////////////////
//
// lc146. LRU Cache (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用c++ list去做，建立unordered_map<key, list<pair<int, int>>>::iterator> map;
    注意map存方的value是這對pair在list的位置，而不是單純的key對應到的val，目的是這樣取得位置
    就可以做刪除和insert的動作。

///////////////////////////////////////////////////////////////
//
// lc147. Insertion Sort List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個insersition list，每次看到新的從左開始找適合的點插入
    insertion->next->val > cur->val，則插入。

///////////////////////////////////////////////////////////////
//
// lc148. Sort List (看)* 第一種方法。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) merge sort，中間點用快慢指針，類似lc021。 
    要注意找出中間點時，左邊的尾巴要指向NULL。

(2) bottom up，o(nlogn) time and o(1) space。
    想像merge sort 由下往上做，每次合併2(左右各一) 4(左右各2) 8...個
    每次做完一個合併過程，要將tail指向left & right的頭，並且串接left & right
    最後return 一個新的tail
    
    ex:4->2->1->3
    
    step = 1，左右各1合併
    2->4->1->3
    
    step = 2，左右各2合併
    1->2->3->4

(3) quick sort，將list分為三種：大於，等於，小於。
    將這3個list尾巴都指向NULL，遞迴後得到sort過的list再拿去merge。

///////////////////////////////////////////////////////////////
//
// lc150. Evaluate Reverse Polish Notation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) stack operation。

///////////////////////////////////////////////////////////////
//
// lc151. Reverse Words in a String (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) inplace reversion，space: O(1)
    利用ri表示實際長度，遇到' '，reverse上一個word，最後再對s swap一次。
(2) built-in function，space: O(n)

///////////////////////////////////////////////////////////////
//
// lc152. Maximum Product Subarray (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp，維持當前最大和當前為小，做三比較(當前最大*當前數字，當前最小*當前數字，當前數字)
    遇到0，當前最大和當前最小要設為0。
(2) 類似lc053的divide and conquer，差別在橫跨中間時，左邊要算出最大和最小，右邊要算出最大和最小
    取最大*最大和最小*最小做比較當作橫跨中間的最大值。

///////////////////////////////////////////////////////////////
//
// lc153. Find Minimum in Rotated Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc33，lc81，最小值一定會在非上升序列的那個區段，若左右兩序列都上升
    序列，return 左右兩個頭中最小的。

///////////////////////////////////////////////////////////////
//
// lc155. Min Stack (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用一個stack，若當前x <= min_val，push(min_val)後，min_val = x。
    目的是儲存上一個min_val。因此當pop掉的是min_val，skack的下一個必為
    push這個值之前的min_val。

///////////////////////////////////////////////////////////////
//
// lc156. Binary Tree Upside Down (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，root->left->left = root->right
               root->left->right = root，用**pointer去紀錄new root。

///////////////////////////////////////////////////////////////
//
// lc159. Longest Substring with At Most Two Distinct Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer，維持subarry讓diff <= 2。

///////////////////////////////////////////////////////////////
//
// lc160. Intersection of Two Linked Lists (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 走完自己走別人，最後的點即為相遇點(沒有的話會null)
(2) 長的list先走和短的list差距的長度，然後一起走，必有相遇點(沒有的話會null)

///////////////////////////////////////////////////////////////
//
// lc161. One Edit Distance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 把插入，刪除，和對調都比較
(2) 只考慮刪除和對調，若 len(s) < len(t)，就swap。

///////////////////////////////////////////////////////////////
//
// lc162. Find Peak Element (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用binary search，一直找到最高點，即
    if (nums[mid] < nums[mid+1]) left = mid+1;
    else right = mid;

///////////////////////////////////////////////////////////////
//
// lc163. Missing Ranges
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將upper+1 push到arr，last = lower-1開始，
    這樣就能跑一個for loop，不用做額外判斷。

///////////////////////////////////////////////////////////////
//
// lc165. Compare Version Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer 去找version number。

///////////////////////////////////////////////////////////////
//
// lc167. Two Sum II - Input array is sorted
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc001，這題更簡單，因為已經排序過，用left，right兩指針來逼近target值就好。

///////////////////////////////////////////////////////////////
//
// lc168. Excel Sheet Column Title
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc171，比較特別且要注意的是每次要n--再取餘數，才能取到正確的字母。

///////////////////////////////////////////////////////////////
//
// lc169. Majority Element (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為會過半數，所以和自己不同的兩兩抵銷(用count紀錄當前major出現次數)必會剩下一個，此為最多數。
(2) 可通過排序再取中間數，但為O(nlogn)，沒有(1)的O(n)好

///////////////////////////////////////////////////////////////
//
// lc171. Excel Sheet Column Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似26進位， res = res*26 + s[i]-'A'+1。

///////////////////////////////////////////////////////////////
//
// lc172. Factorial Trailing Zeroes (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算n!中0的個數，代表計算10的個數，也就是2和5的個數，因為2遠比5多，
    所以計算5的個數。
    n/5 + n/(5*5) + n/(5*5*5)...。

///////////////////////////////////////////////////////////////
//
// lc173. Binary Search Tree Iterator
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 類似lc094 stack作法，constructor放入當前左子樹，每次取出一個，
    若有右孩子，將右孩子的左子樹放入stack。
(2) morris traversal

///////////////////////////////////////////////////////////////
//
// lc179. Largest Number
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 先轉字串，利用排序法，比較a和b時，a+b>b+a則a放在b前面。
(2) 也可用內建sort排序，定義compare function。

///////////////////////////////////////////////////////////////
//
// lc187. Repeated DNA Sequences (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 單純維持current string去看set裡面有沒有出現。
    time: O(n)
    space: O(n)
(2) bit manipulation
    因為有四個字母，將其轉成00,01,10,11，並去找當前bit string有才取substring加入set，
    和上述差異就是，這裡的key是interger，只有找到才要substring，不用每一次都
    找substring。

///////////////////////////////////////////////////////////////
//
// lc188. Best Time to Buy and Sell Stock IV (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc123 method 2。

///////////////////////////////////////////////////////////////
//
// lc189. Rotate Array (看)* 看方法2。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先翻轉vector，再對前k個翻轉，後n-k就翻轉。
(2) (難想)：
    對當前項紀錄cur = nums[idx+k]，且將最後一次紀錄的pre填到nums[idx+k]，
    即nums[idx+k] = pre, pre = cur，idx = (idx+k)%n，
    為避免造成只會繞著某幾位轉(ex：nums.size() = 6, k = 2，1->3->5->1->3->5)，
    當idx回到start，idx = ++start，pre = nums[pre]。
(3) 將首項pushback n-k次且同時erase。

///////////////////////////////////////////////////////////////
//
// lc190. Reverse Bits (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc136，都是bit operation的操作。
    對於res的當前一位，先shift 1( res << 1)，將n的最後一位放到res的第1位。

///////////////////////////////////////////////////////////////
//
// lc191. Number of 1 Bits
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 類似lc190，對最後一位去看是不是1： res += (n & 1);
    取最後一位就用1去做&就好。
(2) n &= n-1，可以去除最後一個1。

///////////////////////////////////////////////////////////////
//
// lc198. House Robber (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個dp[i] = max(dp[i-1], dp[i-2]+nums[i])。
    表示當前最大偷錢為 (a) 當前不偷，選用上一個偷錢數量。
                    (b) 當前偷，加上上上個偷錢數量。
    (a)和(b)取最大值。                 

***優化為：維持evenMax和oddMax
          若當前為偶數idx，則抓錢最大化為 max(evenMax+nums[idx], oddMax)。
          奇數反之。

///////////////////////////////////////////////////////////////
//
// lc199. Binary Tree Right Side View (看) 反向dfs。
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) bfs
(2) dfs，將preorder左右順序互換，反向dfs。

///////////////////////////////////////////////////////////////
//
// lc200. Number of Islands (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dfs
(2) bfs: bfs要在加入que的時候就改，避免一個node被兩個同時連到的情況：
         a和c都連b，在處理a的時候將b加入queue，a改被處理過，這時queue裡有b和c，
         取出b又會再將c加入一次，但其實c已經被走過。
(3) follow up: (未解決)
        算最短曼哈頓距離
        算島嶼面積
        填上一個點後，哪個點可以使得到最大島嶼面積

///////////////////////////////////////////////////////////////
//
// lc202. Happy Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

happy number和不會是4。
(1) 一般跑回圈，n == 4 或 n == 1跳出return。
(2) 利用快慢指針來找出重複數字，(類似找環)。
    類似lc142。

///////////////////////////////////////////////////////////////
//
// lc203. Remove Linked List Elements
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dummy和pre，cur雙指針來做link list重新連接。
    如果cur->val == val，pre->next = cur->next。

///////////////////////////////////////////////////////////////
//
// lc204. Count Primes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

利用質數篩檢法，將小於sqrt(n)的所有質數倍數挑出來，剩下的就是質數。
time complexity: O(NloglogN)
https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html

///////////////////////////////////////////////////////////////
//
// lc205. Isomorphic Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立雙向bi-directional vector紀錄字母是一對一映射。
    類似lc890。

///////////////////////////////////////////////////////////////
//
// lc206. Reverse Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) recursion (double link list)。
(2) iteration。

///////////////////////////////////////////////////////////////
//
// lc207. Course Schedule (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

有向圖找環
(1) dfs找灰色點(白色call dfs，黑色跳過)。
(2) bds拓樸排序，丟入度為0的點進queue。

///////////////////////////////////////////////////////////////
//
// lc208. Implement Trie (Prefix Tree) (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立trie tree data structude和一個變數判斷當前是不是string。
** follow up ** delete word (可參考討論區)。

///////////////////////////////////////////////////////////////
//
// lc209. Minimum Size Subarray Sum (看)* 看nlogn解法
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) one pass解法：
    維持left和right，先往右找到>=s的點再讓left往右到<s，
    每次都維持min_len，直到right > 邊界。
(2) O(nlogn) binary search，先維持一個到任意idx總和的陣列：sum，
    再利用binary search 逼出總和>=s的點。
    **===要注意當return的right為最後一個點，直接檢查有沒有>=s。===**

///////////////////////////////////////////////////////////////
//
// lc210. Course Schedule II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc207一樣。

///////////////////////////////////////////////////////////////
//
// lc211. Design Add and Search Words Data Structure
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) trie tree，類似lc208。
    n: # of words, m: average word length
    total space of tree: O(n*m)
    one word insert: 
        time: O(m)
        space: O(m)
    one search:
        time:  O(max(m, (existed node in each layer)^m))
        space: O(m) stack of recursion

///////////////////////////////////////////////////////////////
//
// lc212. Word Search II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用trietree，以及dfs，當前不能在trietree有東西時，就return。
    time complexity:
    // time O(cnt * len + m * n * min(4 ^ maxlen, m * n))
    // space O(cnt * len)
    // cnt is the number of words
    // len is the average length of words
    // m * n is the size of board
    // maxlen is the max length of words
(2) 將每一個word跑一遍m*n dfs，每一個dfs為m*n，利用len 表示當前檢測到
    哪一個位置，若idx == word.size()-1，return true。

///////////////////////////////////////////////////////////////
//
// lc213. House Robber II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 偷第一間就不能偷最後一間，反之。
    因此分兩步驟走：
    - (1)不偷第一間的情況   (0 ~ n-2)。
    - (2)不偷最後一間的情況 (1 ~ n-1)。

    兩種情況取最大值。

///////////////////////////////////////////////////////////////
//
// lc214. Shortest Palindrome (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc459。

///////////////////////////////////////////////////////////////
//
// lc215. Kth Largest Element in an Array (看)* heap sort
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 4

(1) quick select partion，若找到的mid>k則往左找，反之。
    注意選擇的pivot要用random，O(n)
(2) max heap, O(n) + klogn
(3) sort, nlogn
(4) priority queue, klogn

///////////////////////////////////////////////////////////////
//
// lc216. Combination Sum III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用遞迴，檢查k==0 && target==0 就將當前vec加入到res中。
    time complexity: O(9^k) or C(9, k)
    space complexity: O(k)

///////////////////////////////////////////////////////////////
//
// lc217. Contains Duplicate
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) unordered_set。
(2) sort。

///////////////////////////////////////////////////////////////
//
// lc219. Contains Duplicate II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用hashmap，因為要找重複項index差距最多不超過k，所以每次更新nums[i]的位置，
    這樣差距只會越來越小。

///////////////////////////////////////////////////////////////
//
// lc221. Maximal Square (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 紀錄當前點的最大邊長，利用dp[i] = min(dp[i], dp[i-1], pre)。
    pre為當前點的左斜上的點，意即matrix[i-1][j-1]。

///////////////////////////////////////////////////////////////
//
// lc222. Count Complete Tree Nodes (看) 有點難想。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為是complete tree，左子樹或右子樹必為full complete tree，
    所以算到full complete tree，直接算pow(2,h)-1，
    若當前不是full complete tree，遞回去算full complete tree
    => 1 + dfs(root->left) + dfs(root->right)
    time complexity: O(logN*logN)
    since always at least one of the two recursive calls is such a full tree, 
    at least one of the two calls immediately stops. Again we have runtime O(log(n)^2).

///////////////////////////////////////////////////////////////
//
// lc224. Basic Calculator
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc394, lc726
    dfs recursion。

///////////////////////////////////////////////////////////////
//
// lc225. Implement Stack using Queues
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當push x時，把當前queue重新push進入queue。

///////////////////////////////////////////////////////////////
//
// lc226. Invert Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs互換left和right tree。

///////////////////////////////////////////////////////////////
//
// lc227. Basic Calculator II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(1) space： 遇到數字，把所有*和/算完，與當前ans做相加或相減。
(2) O(n) space： 使用stack，遇到+-*/時，
                 先用op把sum和stack的top做運算，在將當前運算符號記錄到op中。

///////////////////////////////////////////////////////////////
//
// lc228. Summary Ranges (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1)跑回圈找到連續number的尾部，連同start一起push到res。

///////////////////////////////////////////////////////////////
//
// lc229. Majority Element II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc169類似，一組數列中超過n/3的數字最多兩個，如果三個代表總合>n/3，與題目的n
    個不成立，因此維持兩個計數器，當有第三個和這兩個不一樣，兩個計數器都減一。
    最後再便利一次確定計數器中的值是正確過n/3的值。

///////////////////////////////////////////////////////////////
//
// lc230. Kth Smallest Element in a BST (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 3

和lc094類似。
(1) dfs recursion。
(2) stack iteration。
(3) morris traversal。

** follow up
list with map<nodeval, list<int>::iterator>
find O(1) insert into list O(logn) delete from list O(1)

///////////////////////////////////////////////////////////////
//
// lc231. Power of Two (看) 第二個方法
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 因為2的次方，整個數字只有一個1，所以可以cnt += (n&1)，cnt = 1才是2的次方。
(2) O(1) time，因為2的次方只有1個1，所以可以用 n&(n-1)是否等於0來判斷是否為2的次方。
    類似lc191。

///////////////////////////////////////////////////////////////
//
// lc232. Implement Queue using Stacks (看)* 看方法2。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 在push x的時候翻轉當前stack，翻轉出來的值先用一個tmp stack裝著，push後，
    再將tmp中的值放回主stack。
(2) 因為方法一要在每次push x時process兩個stack，效率差，
    這邊用一個stack sk_tmp專門push x進去，當要pop或peep，將當前stack翻轉放到sk_now，
    並取出其top，當sk_now.size() == 0，將sk_tmp再翻轉進去sk_now。
    注意！！一定要sk_now用完才能將sk_tmp翻轉進入stack，因為要保持其順序。

///////////////////////////////////////////////////////////////
//
// lc234. Palindrome Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) time, O(1) space
    利用快慢指針找到中間點後
    (a) fast = NULL 則右半段 = mid，
    (b) fast->next = NULL 則右半段 = mid->next，
    反轉前半段，再一一比較。

(2) O(n) time，O(n) space
    很扯的遞迴解法。

///////////////////////////////////////////////////////////////
//
// lc235. Lowest Common Ancestor of a Binary Search Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc236，但有bst這個特性，所以較簡單，可以用比大小列出case來找出祖先。
    可用遞迴，也可用iteration。

///////////////////////////////////////////////////////////////
//
// lc236. Lowest Common Ancestor of a Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用祖先特性，最先找到的點，下面就不用找。因為他或他以上才可能是祖先。
    若左子樹找到p，右子樹找到q則祖先為root。
    若左子樹先找到p，右子樹沒找到(NULL)，則祖先為p。
    若左子樹先找到q，右子樹沒找到(NULL)，則祖先為q。
    反之。
(2) 利用dfs紀錄到p的path和到q的path，然後比較兩個path的共同點。

///////////////////////////////////////////////////////////////
//
// lc237. Delete Node in a Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將當前值由下一個node的val取代，
    且當cur->next->next = NULL，cur->next = NULL，結束。

///////////////////////////////////////////////////////////////
//
// lc238. Product of Array Except Self (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當前乘積等於左邊的乘積*右邊的乘積，因此同時維持一個右邊的乘積，和左邊的乘積。
    time： O(n), space： O(1)。

///////////////////////////////////////////////////////////////
//
// lc239. Sliding Window Maximum (看)* 看第二種解法。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) priority_queue維持區間內最大值(max_heap)。
(2) O(n)，利用deque STL，
    維持一個降序陣列，此外當頭 <= i-k，pop_front,
    每當push_back時，若尾端 < nums[i]，pop_back。
    
///////////////////////////////////////////////////////////////
//
// lc240. Search a 2D Matrix II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear search (右上起點)，better。
(2) 兩次binary search

///////////////////////////////////////////////////////////////
//
// lc241. Different Ways to Add Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用divide & conquer with dp memorization。
    time complexity: 
    https://www.geeksforgeeks.org/program-nth-catalan-number/
    https://stackoverflow.com/questions/27371612/catalan-numbers-recursive-function-time-complexity
    http://people.math.sc.edu/howard/Classes/554b/catalan.pdf
    計算時間類似lc95。

///////////////////////////////////////////////////////////////
//
// lc242. Valid Anagram
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc49，lc567，利用一data structure紀錄次數，若--str[s[i]-'a'] < 0
    return false。

///////////////////////////////////////////////////////////////
//
// lc243. Shortest Word Distance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) double pointer, one pass，利用last1, last2表示兩個最後遇到word1, word2
    的index，若當前 == word1，res = min(res, i - last2)，不用絕對值
    是因為i 一定於last2。

///////////////////////////////////////////////////////////////
//
// lc244. Shortest Word Distance II
//
///////////////////////////////////////////////////////////////

Approach 1: Preprocessing: O(n^2) Compute:O(1)
Approach 2: Preprocessing: O(n) Compute:O(n)

If the compute method is getting called a lot of times, approach 1 is better. 
Let's say compute is called n times. 
approach1 would be O(n^2) + O(n)
approach2 would be O(n) + O(n)*O(n)
so if compute > n times, approach 1 is better。

approach 1: We can use a hash map to store the shortest distances for any pair of words.
            then compute would be O(1).

最佳解： method 1

(1) 先將words用hashmap存起來同一個word出現的index位置，再用double pointer
    去算出smallest distance。

///////////////////////////////////////////////////////////////
//
// lc245. Shortest Word Distance III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用double pointer，多一個條件：
    words[i] == word1 && words[i] == word2。

///////////////////////////////////////////////////////////////
//
// lc246. Strobogrammatic Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，num[i] == num[j]，num[i]一定要是0, 1, 8，若num[i] != num[j]，
    只能是 69 or 96。

///////////////////////////////////////////////////////////////
//
// lc247. Strobogrammatic Number II
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 基本dfs
(2) 先到最底(i == j or i > j)，然後拿到下一層的res處理後再繼續return。
    類似lc095。

///////////////////////////////////////////////////////////////
//
// lc248. Strobogrammatic Number III (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 因為有low，high，可以generate number from n = low.size() ~ high.size()，
    當now.size() == n，去判斷可不可以在區間內。
    優化速度：當now.size() < n-1，就不用遞迴，因為絕對不會變成now.size() == n
    而去做判斷。
(2) 對於當前size，給定left和right去填。

///////////////////////////////////////////////////////////////
//
// lc249. Group Shifted Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) map operation，字串shift後一樣，表示彼此的差距是一樣的。

///////////////////////////////////////////////////////////////
//
// lc250. Count Univalue Subtrees
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 維持最底下的leaf值，若當前和leaf不一樣，當前的comp = INT_MIN，else，
    comp = max(left_comp, right_comp)。
(2) postorder，當前和孩子比較，若不同，return false，但若比較之前postorder中
    其中一個孩子returnfalse，直接return false。

///////////////////////////////////////////////////////////////
//
// lc252. Meeting Rooms
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若start < last_end -> return false。

///////////////////////////////////////////////////////////////
//
// lc253. Meeting Rooms II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 排序start time and end time，
    若start time < end time -> ++res。
    反之 -> ++endPos。
(2) 類似lc731，若start time ++, end time --，
    計算event重複最大的數量。

///////////////////////////////////////////////////////////////
//
// lc255. Verify Preorder Sequence in Binary Search Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，利用另一個index表示stack index。
(2) O(n) space，利用降序stack，每次踢掉的當標準值，當比標準值小的，return false。

***follow up: postorder to verify if bst

///////////////////////////////////////////////////////////////
//
// lc256. Paint House
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當前cost[i]的這個顏色 = min(cost[i-1]的其他兩個顏色) + cost[i]的這個顏色。

///////////////////////////////////////////////////////////////
//
// lc257. Binary Tree Paths
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc258. Add Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找出規律，發現所有數字相加得到的1 digit為該數字的9的餘數。

///////////////////////////////////////////////////////////////
//
// lc259. 3Sum Smaller
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc611，two pointer。

///////////////////////////////////////////////////////////////
//
// lc260. Single Number III (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要找出出現一次的兩個數字，首先將所有數字xor，剩餘的就是出現一次的數字bit。
    我們目的是拿出第一位為1的bit(由右至左算)，使用方式為diff &= (~diff+1)，
    原因是這bit可以分出兩個出現一次的數字，
    因為只出現一次，代表其中一個數字and會為0，另一個數字and為1。
    其餘數字因為都成對出現，所以xor到對應位置都會為0。

///////////////////////////////////////////////////////////////
//
// lc261. Graph Valid Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find
(2) bfs + queue

///////////////////////////////////////////////////////////////
//
// lc263. Ugly Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對num除2除3除5到不能再除，若為1則為ugly nubmer。

///////////////////////////////////////////////////////////////
//
// lc264. Ugly Number II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前的dp數字，要找到下一個比他大的，因為有2,3,5，所以對於這三個數字
    找到第一個idx使得該醜數*2大於now，這樣這個idx for 2 可以下一輪當醜樹候選人。
    3，5同理。

///////////////////////////////////////////////////////////////
//
// lc266. Palindrome Permutation
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 計算是奇數的次數，必須<=1。
(2) 利用一set表是奇數次數的charater，set size必須<=1。

///////////////////////////////////////////////////////////////
//
// lc268. Missing Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 將vector的value全部相加，和本來應該要有的總和取diff極為答案。
(2) 類似lc136，和方法ㄧ也類似，差別在於用xor找出單獨的數字。
(3) 類似lc287，binary search。
    先將數列排序，若取到mid > nums[mid]，則right = mid，反之，left = mid+1。

///////////////////////////////////////////////////////////////
//
// lc270. Closest Binary Search Tree Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) preorder，利用bst特性選要走的路，類似lc669，lc938。

///////////////////////////////////////////////////////////////
//
// lc273. Integer to English Words (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，以1000為單位，注意細節。

///////////////////////////////////////////////////////////////
//
// lc276. Paint Fence (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當前dp[i]，表示到第i位的方法數 = same[i] + diff[i]，
    same[i]是和上一位一樣，diff[i]是和上一位不一樣的方法數。
    可以想像成
    (1) ith和i-1th不一樣的方法數。
    (2) ith和i-1th一樣的方法數。
    (1) 就是dp[i-1]*(k-1)
    (2) 就是和上一位一樣，保證不能連三位一樣，所以diff[i-1] * 1，因為diff[i-1]
        表示i-1和i-2不一樣的方法數，那們再加上一個和i-1一樣的color也不會連三位一樣。

    dp[i] = same[i] + diff[i]
          = diff[i-1] + dp[i-1] * k-1
          = dp[i-2] * k-1 + dp[i-1] * k-1
          = (dp[i-1] + dp[i-2]) * k-1
    可用O(1) space去做。

///////////////////////////////////////////////////////////////
//
// lc277. Find the Celebrity (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先跑一遍去找到candidate，若a knows b，則b是candidate，a不是，這樣跑一圈
    後，只會有一個candiate，其他都會被淘汰。因為若a不知道b，b不可能是candi，
    b會被跳過。初始化candi = 0，
    if knows(candi, i)則 candi = i。
    然後對於candidate，若有一a使得a不知道candi或candi知道a，return -1。

///////////////////////////////////////////////////////////////
//
// lc278. First Bad Version
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本binary search

///////////////////////////////////////////////////////////////
//
// lc279. Perfect Squares (看)* 看遞迴解法。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

用dp解
方法一為iteration，方法二為遞迴。
(1)
    (1-1) 每次跑一個迴圈決定好第i個的數量
        dp[i] = min(dp[i], dp[i-j*j]+1]), j=1; j*j<=i 
    (1-2) 核心思想為dp[i+j*j] = min(dp[i+j*j], dp[i]+1);
          i = 0 ~ n, 
          j = 1; i+j*j <= n;
    (2-1)
        dp[n] = min(dp[n], dp[n-i*i]+1)

///////////////////////////////////////////////////////////////
//
// lc280. Wiggle Sort
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 判斷奇偶數，決定要不要swap。

///////////////////////////////////////////////////////////////
//
// lc283. Move Zeroes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc 26, 27
(1) 紀錄當前最後一個非零的index，遇到非零的數字做swap。
    follow up: 若0往最左邊，那就從後面往前做，比0大的往右移。

///////////////////////////////////////////////////////////////
//
// lc285. Inorder Successor in BST (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 4

(1) inorder recursion，類似lc094。
(2) stack iteration，類似lc094。
(3) morris traversal
(4) 利用bst特性，找到>=p->val的第一個node，類似lc510。
    follow up: inorder predecessor。
    time O(logn) space O(1)

///////////////////////////////////////////////////////////////
//
// lc286. Walls and Gates
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc287. Find the Duplicate Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 將index(0~n)用自己的值(1~n)做串聯，若有重複數字代表有兩個以上指到自己，如此必有環。
    例如第一個index為0，後面n個(index:1~n指到1~n)，假設每個都指到別人且不重複，
    剩下一個點必指到已經被指過的，這樣就會有環。
    可用快慢指針解。
(2) binary search: 
    n+1個洞有1~n，必有一重複。
    若沒有重複數字，每次切中間，左邊的數量應該=mid(條件設<=mid，這樣奇偶都可以cover)，
    然後一直往右推移，若到left=right=n則代表沒有重複數字。
    若>mid代表左邊比較多，right = mid，若<=mid代表右邊比較多，left = mid+1。

///////////////////////////////////////////////////////////////
//
// lc289. Game of Life (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將狀態分為四種：
    00：0變0
    01：1變0
    10：0變1
    11：1變1
    搜尋鄰居時，若周圍有1或3的值代表本來是1，累積次數。

///////////////////////////////////////////////////////////////
//
// lc290. Word Pattern
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc205，用兩個hashmap來建立雙向連接關係。
    注意極端情況如pattern.size() == "" 或 str分割後的數量 != pattern.size()
    return idx == pattern.size() ? true : false;

///////////////////////////////////////////////////////////////
//
// lc295. Find Median from Data Stream (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將左半邊和右半邊用priority queue儲存，左半大到小，右半小到大。
follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it?
利用bucket sort去解。

///////////////////////////////////////////////////////////////
//
// lc297. Serialize and Deserialize Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc449方法2。

///////////////////////////////////////////////////////////////
//
// lc298. Binary Tree Longest Consecutive Sequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，判斷自己跟parent差1，就return max(lv, rv) + 1。

///////////////////////////////////////////////////////////////
//
// lc299. Bulls and Cows
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass，找到對於同個數字，相同的數量，就是total cnt，b 就是從total
    count - a
(2) one pass，對於當前guess digit，如果nums[guess digit] > 0，表示之前
    出現過，是cow，如果nums[secret digit] < 0，表示guess出現過。
    --nums[guess digit]。
    ++nums[secret digit]。

///////////////////////////////////////////////////////////////
//
// lc300. Longest Increasing Subsequence (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個升序序列，利用binary search找到合適點做取代或push_back。
(2) 維持一個升序序列，將當前的index放到序列做binary search找到適合的位子取代
    若適合的位子為尾八且尾八<插入數字，則push_back進入序列。
(3) dp[i] 為最後結尾為nums[i]的升序序列長度
    if (nums[i] > nums[j])
        dp[i] = max(dp[i],dp[j]+1)，where j = 0 ~ i;

///////////////////////////////////////////////////////////////
//
// lc301. Remove Invalid Parentheses (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2，2可以在面試中先提，如果想不到1的話。

類似lc1249。

(1) 先刪除右括號在刪除左括號，對於每一次recursion，找到第一個不合法的括號後，從last_j開始
    到i，刪除一個不合法的括號然後進行recursion。
    last_j: 當前開始刪的位置，last_i，當前開始檢查的位置。
    當刪除好右括號，去跑一次新的recursion刪除左括號，若當前是合法且為刪除左括號的recursion，
    res.push_back(now)。
    The program only generates valid answers. Every path in the search generates 
    one valid answer. The whole search space is a tree with k leaves. The number 
    of nodes in the tree is roughly O(k). But this is not always true, for example 
    a degenerated tree.

    To generate one node it requires O(n) time from the string concatenation among 
    other things. So roughly O(nk). Accurately O(nm) where m is the total "number 
    of recursive calls" or "nodes in the search tree". Then you need to relate m 
    to n in the worst case.

    我的想法，若'))(('，這種只要走四遍，因為連續括號只做一次: O(n) function call，each O(n)
    所以time: O(n^2)。
    best case '(())'，只要走一遍，O(n)。

(2) 利用bfs，對於每一層，若沒有valid就將這個now的每一個位置都刪除一次，加入queue，
    若只要有一個，其他在這一層的not valid就不用處理，因為題目要求的是找到
    刪除最小次數的valid 括號。
    
    time complexity: O(n*2^(n-1))
    Let n be the number of parentheses in the string. While doing BFS we remove one one parantheses 
    character from the given string and keep on doing it till we get a result (even an empty string is also an answer). 
    So, in the worst case we traverse till the end. Therefore,
    
    T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + 1*C(n, 1)
    
    https://leetcode.com/problems/remove-invalid-parentheses/discuss/167659/Time-Complexity-Analysis-O(n*2n)

///////////////////////////////////////////////////////////////
//
// lc303. Range Sum Query - Immutable
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp[i]表示到idx i 的sum
    sum(i, j) -> return dp[j+1] - dp[i]。

///////////////////////////////////////////////////////////////
//
// lc304. Range Sum Query 2D - Immutable
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1314，prefix sum。

///////////////////////////////////////////////////////////////
//
// lc305. Number of Islands II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union by size，紀錄每個parent的cluster數量，少的指向多的。
    對於當前index，找四周，若parent不同，--res，代表島嶼合併。

///////////////////////////////////////////////////////////////
//
// lc307. Range Sum Query - Mutable (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 使用segement tree。
    https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/
    update: O(logN)。
    sumrange: O(logN)。

///////////////////////////////////////////////////////////////
//
// lc309. Best Time to Buy and Sell Stock with Cooldown (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 利用狀態機(state machine)表示dp：
    S0： 不買也不賣。
    S1： 從s0來，必須通過買，正在買入狀態。
    S2： 從s1來，必須通過賣，由於賣完必須強制休息一個回合，因此在這有個S2為cool down
                           (表示至少休息一個回合，至於在休息狀態S0要休息幾輪看DP)。
    S0(i) = max(S0(i-1), S2(i-1));
    S1(i) = max(S1(i-1), S0(i-1)-prices[i]);  
    S2(i) = S1(i-1)+prices[i];  
(2) another view of state machine

///////////////////////////////////////////////////////////////
//
// lc310. Minimum Height Trees (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc207的bfs拓樸排序，將degree為1的點放入que層層去除像洋蔥一樣。
    method 2寫法更簡潔，(洋蔥式bfs)。

///////////////////////////////////////////////////////////////
//
// lc311. Sparse Matrix Multiplication (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) res[i][j] = A[i][k] * B[k][j]，可以先看A[i][k] == 0，若是，res[i][j]
    都 = 0。

///////////////////////////////////////////////////////////////
//
// lc313. Super Ugly Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp iteration，類似lc264。

///////////////////////////////////////////////////////////////
//
// lc314. Binary Tree Vertical Order Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 2-1，2-2。

類似lc987。
(1) dfs，因為無法從上往下，要連row都排序，用map<int, map<int, vector<int>>>。
(2-1) bfs with queue，只用map<int, vector<int>>。 O(nlogn)
(2-2) 也可以用unordered_map，並維持maxcol & mincol。 O(n)

///////////////////////////////////////////////////////////////
//
// lc315. Count of Smaller Numbers After Self (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1389，利用divide & conquer，用idx[i]做排序，
    依照nums[idx[i]]的大小做排序，
    if (nums[idx[i]] > nums[idx[j]]) {
        表示左邊的數字比較大，左邊要加一，且右邊放入cp_idx。
        cp_idx.push_back(idx[j])
        ++lower;
    } else {
        cnt[idx[i]] += lower --> 左邊比較小，將左邊到目前為止比小的都記錄起來。
        cp_idx.push_back(idx[i]);
    }

///////////////////////////////////////////////////////////////
//
// lc316. Remove Duplicate Letters (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1)
    * Pop character from the stack when there is still another same 
        character in the remaining string and this element > now character.
    * every time we process each character, we need to subtract one 
        from counter because this element we would not use anymore into our solution.
    * if the stack contain current character, just ignore this one.

///////////////////////////////////////////////////////////////
//
// lc317. Shortest Distance from All Buildings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對每個building做bfs，注意若下一個點被visit次數<當前處理過的building次數，
    表示不可能碰到，直接跳過。

///////////////////////////////////////////////////////////////
//
// lc322. Coin Change (看) 看遞迴。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) iteration： 利用dp去解，dp[i] = min(dp[i], dp[i-coin]+1)。
(2) recurtion： 利用dp去解，dp[i] = min(dp[i], dp[i-coin]+1)。
    注意遞迴，為避免重複執行，當dp[amount] != INT_MAX，
    有些點真的找不到解法還是會維持INT_MAX，這時要手動給予-1，
    表示這個點已找完，避免這個點其實找不到，但因為還是INT_MAX，就繼續找，導致TLE。

///////////////////////////////////////////////////////////////
//
// lc323. Number of Connected Components in an Undirected Graph
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dfs，用visit[n]紀錄走過的點。
(2) union finding，類似lc1135。

///////////////////////////////////////////////////////////////
//
// lc325. Maximum Size Subarray Sum Equals k
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum，因為要找最長的subarray == k，確認sum-k存在就
    res = max(res, i-map[sum-k])，map[0] = -1。
    若sum不存在，map[sum] = i。

///////////////////////////////////////////////////////////////
//
// lc327. Count of Range Sum (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc315，divide & conquer，先做出prefix sum，然後利用divide & conquer，
    對prefix sum做排序，其中要如何計算upper & lower？
    對於每一個在左邊的index，在右邊找第一個>=lower的index： idx1和第一個>upper的index： idx2
    這樣就可以算出區間數量，res += idx2 - idx1，這些index都是符合題目要求，
    為甚麼要sort array？
    這樣找upper & lower很好找，且上一輪的idx1，idx2，可以繼續用在下一個在左邊的index。

///////////////////////////////////////////////////////////////
//
// lc328. Odd Even Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

一次看兩個：now，now->next，兩個指向odd和even，(dummy1，dummy2)。

///////////////////////////////////////////////////////////////
//
// lc329. Longest Increasing Path in a Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: O(mn)
    dfs recurion with memorization。
(2) time: O(mn)
    dag + bfs，也可dag + dfs。
    類似lc1340。

///////////////////////////////////////////////////////////////
//
// lc331. Verify Preorder Serialization of a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 發現規律: 有數字則#數量+1
    當前 # < 0，若長度>1 -> false;
    當前 # = 0, 若當前idx != 長度-1 -> false

///////////////////////////////////////////////////////////////
//
// lc332. Reconstruct Itinerary (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

利用unordered_map<string, multiset<string>> map，
Let N be the number of tickets. Let D be the largest outgoing degree of a vertex.
TIME: insert map: O(NlogD), traverse: O(N)
SPACE: O(N)
想像一條路走到底不能再走，就push_back(那個node)，所以路線是從尾往前，
最後要reverse。
(1) iteration
(2) recursion

///////////////////////////////////////////////////////////////
//
// lc333. Largest BST Subtree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似 lc098，維持一個區間，差別是這邊用postorder。
(1) 維持一個區間，postorder對當前node檢查left child的maxv < root->val
    且right child的minv > root->val，且在這層決定minv和maxv，
    若上述條件不符合，return max(left_cnt, right_cnt)。

///////////////////////////////////////////////////////////////
//
// lc334. Increasing Triplet Subsequence (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持:
        (a) 到目前為止有序的最小
        (b) 到目前為止有序的第二小
    遇到數字先和最小比較，比最小的小更新最小，
    若沒有和二小的比，比第二小的小，更新第二小的。
    NOTE: 更新順序從最小到第二小的目的是要維持到目前為止有序的第二小(前面必有比他小的)
    ->以便找出第三小。

///////////////////////////////////////////////////////////////
//
// lc336. Palindrome Pairs (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) trie tree
    add: 將word從後面往前插入tree，若當前0~i為pali，將這個word的index放入該層的list
    search: 將word從頭往後進入tree搜尋，若當前root->index >= 0 && 不等同當前word index
            去看該word i~word.size()-1是否為pali。
            到底層，去看該root->list，一個一個去插入res
    time: O(n*k^2), k is word lenth

///////////////////////////////////////////////////////////////
//
// lc337. House Robber III (看) 第二種方法，第一種不用(第三種已會)。
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) 維持一個dp數組來確認當前node有沒有被跑過。
(2) 對每一個node維持一個res，res[0]表示不含此node最大值，
                            res[1]表示含此node最大值。
    因此跑遞迴得到左孩子和右孩子的res後，即可得到此node的res。
    res[0] = max(left[0], left[1]) + max(right[0], right[1]);
    res[1] = root->val + left[0] + right[0];
(3) 維持當前node左邊最大值和右邊最大值，以及call recursion後得到的ll，lr，rl，rr。
    對當前最大值計算為 max(root->val+ll+lr+rl+rr, l+r)。

///////////////////////////////////////////////////////////////
//
// lc338. Counting Bits (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似因式分解，當前i為i/2的1個數加上i%2的餘數。

///////////////////////////////////////////////////////////////
//
// lc339. Nested List Weight Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc340. Longest Substring with At Most K Distinct Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc992。差別這是算出現最多k次的最大長度，992是算剛好出現k次的個數。
    用sliding window。

///////////////////////////////////////////////////////////////
//
// lc341. Flatten Nested List Iterator
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) recursion在construcor建好list。
(2) stack實作在has next。

///////////////////////////////////////////////////////////////
//
// lc343. Integer Break
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp iteration： dp[i] = max(dp[i-j]*j, max((i-j)*j, l_max));
    O(n^2)。
    或： dp[i] = 3 * max(dp[i-3], i-3)。
(2) 數學解法：找規律，用3拆分，拆到4為止結束。
    O(n)。

///////////////////////////////////////////////////////////////
//
// lc344. Reverse String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從i = 0 ~ n/2-1 和對應位互換。

///////////////////////////////////////////////////////////////
//
// lc345. Reverse Vowels of a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到母音然後swap。

///////////////////////////////////////////////////////////////
//
// lc346. Moving Average from Data Stream
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) time using que。
    類似lc622。

///////////////////////////////////////////////////////////////
//
// lc347. Top K Frequent Elements (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) priority queue，以次數做排序。
(2) bucket sort，以次數作為籃子從大到小取出。

///////////////////////////////////////////////////////////////
//
// lc348. Design Tic-Tac-Toe
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用row_v[n], colv[n]，代表每一row或col的圈或叉數，圈 = 1，叉 = -1。
    對腳和斜對角特別處理，若任一值絕對值 = n，return player。

///////////////////////////////////////////////////////////////
//
// lc349. Intersection of Two Arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 用set來做。
(2) 排序後，雙指針來做。

///////////////////////////////////////////////////////////////
//
// lc350. Intersection of Two Arrays II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用map來做。
(2) 排序後，雙指針來做。

///////////////////////////////////////////////////////////////
//
// lc356. Line Reflection
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) time and space
    找到max and min of x position，對於每一個點就可以用
    max + min - x 來確認有沒有對稱點。
    用unordered_set去儲存string(x_y)。

///////////////////////////////////////////////////////////////
//
// lc359. Logger Rate Limiter (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) map
follow up: thread safe:
    It's possible that the Logger is called with the same message at 
    the same time from multiple sources. In that case the HashMap might 
    not have been updated fast enough when the second duplicate message arrives.
    time: O(1), space(O(n))

(2) use queue and set to maintain a window list
    time: O(1), space(O(m)), m: max # of unique string in window size
    若時間區段內有很多call，然後隔很久後再一個call，這時候time: O(m)。

///////////////////////////////////////////////////////////////
//
// lc360. Sort Transformed Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc977，要注意的是a<0要從頭開始。

///////////////////////////////////////////////////////////////
//
// lc362. Design Hit Counter (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 用一array紀錄該slot的天數，若與當前不符，hit[slot] = 1，else
    ++hit[slot]。
(2) 利用queue紀錄{time, hit}，在hit和gethit都去pop。

///////////////////////////////////////////////////////////////
//
// lc364. Nested List Weight Sum II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) top down，若當前vec[i]是integer，放入unweighted，跑完當前迴圈，
    weighted += unweighted，unweighted是累加的。
    上一輪的unweighted的總和，要必須到下一輪使用，因為depth是從底部算起，
    最上層一定是最深的，所以每一次都要加到。
    收集不是integer的element，若不是empty，跑新的迴圈。
    ex : [1, [2, [4]]]
    1 round: 1          -> unweighted
    2 round: 1 + 2      -> unweighted
    3 round: 1 + 2 + 4  -> unweighted

///////////////////////////////////////////////////////////////
//
// lc366. Find Leaves of Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder，有點像是level order traversal倒過來，由下往上做。

///////////////////////////////////////////////////////////////
//
// lc368. Largest Divisible Subset (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) space, dp
    先將數組排序(小到大)，i>j， if nums[j]%nums[i] == 0，表示j也可以整除所有i能整除的。
    -> dp[i] = max(dp[j])+1，for j = 0~i-1。
    所以維持一個陣列output[i] = j表示nums[i]整除nums[j]，則最後將此陣列的nums取出即為答案。
    -> O(n) space。

///////////////////////////////////////////////////////////////
//
// lc369. Plus One Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，two pointer，找到最後一個不是9的，表示之後都是9，
    若最後一個不是9，直接加1，不然就將最後一個不是9的加1，其後面全改成0。
(2) O(n) space，recursion。

///////////////////////////////////////////////////////////////
//
// lc373. Find K Pairs with Smallest Sums (看) min heap。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) priority queue： 方法2的優化，min heap，one time pass。
(2) priority queue： max heap。

///////////////////////////////////////////////////////////////
//
// lc374. Guess Number Higher or Lower
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用binary search。

///////////////////////////////////////////////////////////////
//
// lc375. Guess Number Higher or Lower II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) k = j+1~i-1
    利用minimax，dp[j][i] = min(k + max(dp[j][k-1],dp[k+1][i]))
(2) recursion for minimax。

///////////////////////////////////////////////////////////////
//
// lc376. Wiggle Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp solution，維持up和down代表當前為該方向的方法數。
    if nums[i] > nums[i-1] -> up = down + 1
    if nums[i] < nums[i-1] -> down = up + 1
(2) greedy，若持續該方向，就不增加res。

///////////////////////////////////////////////////////////////
//
// lc378. Kth Smallest Element in a Sorted Matrix (看)* binary search方法。
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) parition，quick select，類似lc215。
(2) priority queue。
(3) binary search：維持一個mid代表最大最小的一半，每次遍歷整個matrix，
                   做binary search。
                   做value搜索時要做到left = right。

///////////////////////////////////////////////////////////////
//
// lc380. Insert Delete GetRandom O(1) (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map紀錄有沒有在set，因為unordered_map刪除或插入都O(1)。
    取隨機則是利用vector：nums來做操作，所以map的key紀錄val，
    value紀錄在nums這vector的idx。另外刪除就是將所在的idx和尾巴swap後pop_back就好。
    ***---注意刪除時交換的方法。

///////////////////////////////////////////////////////////////
//
// lc381. Insert Delete GetRandom O(1) - Duplicates allowed (看)
//
///////////////////////////////////////////////////////////////

(1) 因為有重複的，為了要確認和哪一個val有交換，必須對於每一個val紀錄他在
    map裡的位子
    unordered_map<int, vector<int>> map;
    vector<pair<int, int>> arr;
    map[arr[i].first][arr[i].second] = i;

ex: insert 1 1 2 2 3 3
    delete 1 2 2 1 3
    insert 4
    delete 3
    random should be 4

///////////////////////////////////////////////////////////////
//
// lc382. Linked List Random Node
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc398，用resivoir sampling。
    要不要選當前node，看當前餘數有沒有=0。

///////////////////////////////////////////////////////////////
//
// lc383. Ransom Note
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用一個vector儲存magazine的字元出現字數，再去對每個出現在ransom note
    的字元去做減去，若有<0的，return false。

///////////////////////////////////////////////////////////////
//
// lc384. Shuffle an Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc398，用resivoir sampling。
    換的長度要在當前idx內，才符合resivoir sampling的1/i。

///////////////////////////////////////////////////////////////
//
// lc386. Lexicographical Numbers (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) iteration：
    對於當前cur，
    若cur*10 <=n，則cur *= 10，
    else，cur >= n，cur /= 10
          ++cur，加到while (cur % 10 == 0)，
                    就 cur /= 10。
(2) recursion：
    對於1~9跑遞迴，每次push進去res，且對於當前數字跑0~9遞迴，
    遞迴行事為：cur*10 + i。

///////////////////////////////////////////////////////////////
//
// lc387. First Unique Character in a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1
(1) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc388. Longest Absolute File Path
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc071。
    maintain total len of current stack and depth of current file path
    when we meet '\n', check last string we have that is file or path
    also # of '\t' to determine if we need to pop stack or not。

///////////////////////////////////////////////////////////////
//
// lc389. Find the Difference (看) bit解法。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 計算s所有字母出現字數，並在t中剪掉，若<0表示為多出來的。
(2) 類似lc136，利用xor特性來找出多出來的字母。

///////////////////////////////////////////////////////////////
//
// lc392. Is Subsequence (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用雙指針來對兩個string遍歷。
follow up: pos[i][j]表示從i開始，'a'+j第一個出現的位置。
           遍歷pos要從後往前。

///////////////////////////////////////////////////////////////
//
// lc394. Decode String (看) iteration作法
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs：
    維持一個now_str表示當前level(同個括號層級)的字串。
    遇到數字就進入遞迴，return括號內的結果字串，iterative的加入這層level的now_string。
    最後idx=s.size()或是遇到']'就ans = now_string，並且return。
(2) iteration：
    維持兩個stack，一個次數，一個外層string。
    遇到'['就進入下一層，將當前string和cnt放入stack。
    遇到']'就計算當前now_str次數並將str_stack.top拿出加入now_str並對兩個stack都pop。
    return now_str。
(3) follow up
    string test = "xx(ab(d){3}){2}xx(abc){3}";
    xxabdddabdddxxabcabcabc

///////////////////////////////////////////////////////////////
//
// lc395. Longest Substring with At Least K Repeating Characters (看*) 1和3。
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) 維持一個mask，若在對應位有出現數字但不滿k次，給1，反之，給0。
    當mask = 0，表示到目前為止符合題目要求。
    跑(最大)n次迴圈，因為每次一頭開始往後找最大重複子字串。
    time: O(n^2)。
(2) 遞迴：
    先算好所有字母出現次數，跑一次迴圈，對當前idx的字母沒有達到k次，計算這之前的最大長度(從max_idx到當前去遞迴)。
    因為最後一次到邊界的沒辦法在迴圈跑，所以當前function return時跑一次以最後(idx = n)為當前位置的遞迴。
    time: O(n)
(3) 遞迴：(我喜歡)，類似binary search。
    跑一個迴圈執到第一個沒到達K次的字母。
    對左半邊跑遞迴。 -> 0 ~ idx-1。
    右半邊則是繼續去找到第一個達到k次的字母，對剩餘字串跑遞迴。 -> idx ~ n-1。
    return max(left, right)。
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc397. Integer Replacement (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 遞迴找最小，n == 1時return 0。
(2) 找規律，當前為奇數時，若不是3且第二個bit是1(n&2 == 1)，則+1，
    因為+1後會變成4的倍數，反之則-1。

///////////////////////////////////////////////////////////////
//
// lc398. Random Pick Index (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用resivoir sampling，對於當前等同於target的數量cnt，代表有1/cnt機率選取當前i。

///////////////////////////////////////////////////////////////
//
// lc399. Evaluate Division (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find
    維持一map val表示node到parent的val。
    若union(x, y)表示 找到他們兩個的parent，xp, yp
    parent[xp] = yp，val[xp] = val * val[y] / val[x]
    這樣就把xp指向yp，且xp到其parent (yp)的val也設定好了。
    做find parent時，利用path compression，計算node到parent的val總和，
    因為做了compression，所以val總和只要算一次。

(2) dfs。

///////////////////////////////////////////////////////////////
//
// lc401. Binary Watch (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit manipulation，算出小時和分鐘的bit為1總和 == num
    time: O(60*12)。
    space: O(1)
(2) dfs，找到所有組合
    time: C(4+6, num)
    space: C(4+6, num)

///////////////////////////////////////////////////////////////
//
// lc402. Remove K Digits (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若input為升序，去掉後面k個，因此利用升序序列，當val比res.back()小，去掉
    res.back()。
    follow up: 找largest number (維持一個降序序列來做就好)。

///////////////////////////////////////////////////////////////
//
// lc403. Frog Jump (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp recursion with memo
    visit[i][j] 表示位置i且跳的格數j。
    time: O(n^2)
    space: O(n^2)
(2) dp iteartion
    dp[i][j] 表示位置i且跳的格數j。
    time: O(n^2)
    space: O(n^2)

///////////////////////////////////////////////////////////////
//
// lc404. Sum of Left Leaves
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要求左子葉的和，表示當前node是上一個node的左孩子外加上當前node沒有孩子，
    因為葉子不會有孩子。

///////////////////////////////////////////////////////////////
//
// lc406. Queue Reconstruction by Height (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 題目要找出一個排序是任一index前面高度大於等於自己的數量等同於自己的inputp[1](即k)，
    因此先由高到低排序，這樣就達成先排高的再排矮的，矮的調換不會影響到高的k，
    排序完，跑迴圈(0~n-1)，再利用k依照index插入即可。

///////////////////////////////////////////////////////////////
//
// lc407. Trapping Rain Water II (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dijkstra
    每個node攜帶自己的高度，每次取最小的，找出四周，若有比當前依照最小的方式取出
    所算出的最大高度還要小的，則res += mh-current_height。
    另外利用visit記錄每個點只走一次。

///////////////////////////////////////////////////////////////
//
// lc409. Longest Palindrome
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為最大回文字數一定是全偶字母配最多一奇數個數的字母，
    因此只要將出現個數全部相加，遇到奇數就減一(代表選偶數個數)，
    迴圈結束後，若有出現至少一次奇數個數字母，就將sum再加1(代表只選一個奇數個數的字母)

///////////////////////////////////////////////////////////////
//
// lc410. Split Array Largest Sum (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) binary search，難想，left為數組中最大值，right為sum總和。
    每次取mid，若可以被分割，表示mid可以再更小，若不能被分割，表示mid太小導致分割數量太多，
    mid必須增大。
    利用mid控制分割數量，這樣right就是最佳分割數量的最小值。當可以分割表示邊界太大，
    導致mid太大，這時讓mid變小，可以在可分割的情況下使subarry sum變小(mid控制subarry sum的最大值)。
    time complexity: nlogn。
(2) dp recursion，dp[i][j]表示0~j用了i條分割線得到的minimum of largest sum。
    space：O(m*n)
    time：O(n^2*m)，
    首先recursion function會被call幾次？ -> m*n，因為要填滿每一個dp data位置，
    再來，每個recursion有跑一次n linear search，所以m*n*n。
    可improve到logn by binary search。

///////////////////////////////////////////////////////////////
//
// lc412. Fizz Buzz (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用counter計算當前是不是3或是5。

///////////////////////////////////////////////////////////////
//
// lc414. Third Maximum Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 用pointer存。
(2) 用ordered set存。

///////////////////////////////////////////////////////////////
//
// lc415. Add Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear add from right to left。

///////////////////////////////////////////////////////////////
//
// lc416. Partition Equal Subset Sum (看)* 第一種方法。
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 利用bit vector解，
    跑一個陣列迴圈，若遇到數字為n，向左移n位表示當前數字都加上n。
    然後再和本來的bit vect做 or，這目的是除了加上n的數字，也要保有本來的數字。
    結束迴圈後，找sum/2的位置是否為1即可。
(2) 利用dp解，dp[i]表示和為i可被num vector中幾項做總和相同，
    所以dp[i] is true if dp[i] || dp[i-num] (表示i-num可被拆分且num存在於num vector)
    確定每個number都只能用一次，並對於這個num找尋dp[i-num]是否存在。
    所以i要從target往num走(--j)，
    因為如果從num走，會讓所有dp都是true，進而失去dp意義(重複使用num)。
    (here we must start from 'half' downto 'num', 
    otherwise current 'num' might be multiply used. )

///////////////////////////////////////////////////////////////
//
// lc417. Pacific Atlantic Water Flow (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs with queue，做兩遍bfs，第一遍找pac，第二遍找atl，看結果兩個都有visit
    到的丟入res。

///////////////////////////////////////////////////////////////
//
// lc419. Battleships in a Board
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為只會有直線或橫線，只要確認是直線或橫線的最後一個才res++。
    (也就是算這條是battleship只有在戰艦的最後一位)。

///////////////////////////////////////////////////////////////
//
// lc424. Longest Repeating Character Replacement
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1004。
    sliding window
    維持區間內最多k個與區間內當前最大同種字母不同的數量，
    意即每次iteration動態維持當前字母出現次數的最大數量，
    且計算區間內與此自此不同的數量(i-start+1 - maxCnt)，若大於k，移動start，
    直到上述計算值 <= K。

///////////////////////////////////////////////////////////////
//
// lc426. Convert Binary Search Tree to Sorted Doubly Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) inorder traversal，利用**pointer去做。
    node->left = *last_node;
    (*last_node)->right = node;
(2) morris traversal O(1) space。

///////////////////////////////////////////////////////////////
//
// lc427. Construct Quad Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bottom up, time: O(n^2), space: O(n^2)
    判斷若四個孩子都是leaf且val相同，當前改成leaf，
    不然連接這四個孩子。

///////////////////////////////////////////////////////////////
//
// lc428. Serialize and Deserialize N-ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc449。
(1) 利用"#"作為該node的children結束tag。

///////////////////////////////////////////////////////////////
//
// lc429. N-ary Tree Level Order Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc102，lc107，可用preorder(dfs)或是bfs去做。

///////////////////////////////////////////////////////////////
//
// lc430. Flatten a Multilevel Doubly Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到孩子就將孩子的那條尾巴的node接到當前的next。
(2) 遇到孩子就將當前的next放到stack。
    若當前為NULL，把當前=stack的top。

///////////////////////////////////////////////////////////////
//
// lc431. Encode N-ary Tree to Binary Tree (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前所以children，child[0]->right = child[1]，child[1]->right = child[2]...
    node->left = child[0]。
            1
        3   2   4
      5   6

               1
        3
    5      2
      6      4

///////////////////////////////////////////////////////////////
//
// lc435. Non-overlapping Intervals
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc452。
    對end做sort。
    若當前start < cur_end，這個interval要remove，++res。

///////////////////////////////////////////////////////////////
//
// lc437. Path Sum III (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc560，利用prefix sum搭配dfs。若當前總和val，則res += map[val-sum]。
    因為val-sum在之前出現過k次，則加上sum = val，所以res加上k次。
(2) 較直覺，兩層遞迴，第一層正常dfs，
    第二層則是對於dfs走訪的每個點往leaf做加總去計算=sum的次數。

///////////////////////////////////////////////////////////////
//
// lc438. Find All Anagrams in a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc567。
(1) 每次往右移動，若<0，滑動左邊直到 == 0，每次都檢查i-left+1有沒有等同
    p.size()。

///////////////////////////////////////////////////////////////
//
// lc441. Arranging Coins
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，注意overflow。

///////////////////////////////////////////////////////////////
//
// lc442. Find All Duplicates in an Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

三種方法都在確認idx: abs(nums[i])-1 有沒有被走訪過。
(1) 負數確認
    若idx: abs(nums[i])-1的值為負的，代表有兩個值指到他，為重複。
(2) swapping
    如果nums[i] 和 nums[nums[i]-1]不同，將這兩個做交換，且i--，
    這邊i-1原因是一定要確認當前nums[i] = nums[nums[i]-1]才能往下一位走。
    若都沒有重複，交換完應該為1~n。
(3) 2n確認
    對於指到的數字(index為nums[i]-1的val)加上n，跑完一遍看哪個數字>2n表示該index為重複的。

///////////////////////////////////////////////////////////////
//
// lc443. String Compression
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，two pointer。

///////////////////////////////////////////////////////////////
//
// lc445. Add Two Numbers II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) stack operation：
    利用stack將list倒著放，(不直接reverse list)。
(2) recursion：
    先找出兩個list長度並計算差值，此差值是用來看每層遞迴的list長度有沒有對等，
    也就是l1的digit有沒有對到l2的digit。
    當差值不等於0，當前node = l1->val，若差值=0，當前node = l1->val+l2->val。
    遞迴找出下一位的值同時傳入diff-1，將這一位指向return的下一位node。
    並對下一位node：pos檢查值有沒有>0，若有，當前這位+1。
(3) reverse input list

///////////////////////////////////////////////////////////////
//
// lc448. Find All Numbers Disappeared in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc442方法一。

///////////////////////////////////////////////////////////////
//
// lc449. Serialize and Deserialize BST (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 3

類似lc1008。
(1) 轉string時，利用preoreder和ostringstream來做輸入，
    轉tree時，利用stack維持一個降序序列，
    (a) 若當前比top大，找到最後一個比top大的，
    (b) 比她大的->right = 當前。
        反之，top->left = 當前。
(2) 轉tree用recursion。
(3) 利用bst特性。

///////////////////////////////////////////////////////////////
//
// lc450. Delete Node in a BST (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 利用preorder(dfs)，找到root->val == key，
    若!left || !right，代表只要return不是NULL的孩子，
    若兩者都null，return null，
    若兩者都不是null，選left的最右邊，其->right = root->right，return root->left。
(2) iteration，找到點，將now->left->最右邊接到now->right，再判斷自己是
    左孩子還是右孩子，來讓p->left or p->right去接新的點。
    若now->left is null，則直接去接now->right (now->right是新的點)。

///////////////////////////////////////////////////////////////
//
// lc451. Sort Characters By Frequency
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort
(2) priority queue

///////////////////////////////////////////////////////////////
//
// lc452. Minimum Number of Arrows to Burst Balloons
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為對於不增加射箭數量，每個term的start都要在維持的min end裡面，所以我們
    可以對end做排序。

///////////////////////////////////////////////////////////////
//
// lc453. Minimum Moves to Equal Array Elements (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 題目要求的是，每次選n-1個加上1，問最少加的次數使得每個val一樣，
    換種思考，每次選n-1個加上1，這樣是一次，那就是每次選個扣掉1，也是一次，
    所以對於每一個直，算出他和minv的diff，加總即可。
    nums[0]-minv + nums[1]-minv + ... + nums[n-1]0-minv
    = sum(nums[0...n-1]) - n * minv;

///////////////////////////////////////////////////////////////
//
// lc454. 4Sum II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先用map儲存a,b的和與其a,b的index，再對c,d找和*(-1)看有沒有在map裡面，
    有得話，++res。
    time: O(n^2)。

///////////////////////////////////////////////////////////////
//
// lc455. Assign Cookies
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) double pointer，若當前g[i] <= s[j]，++i，return i。

///////////////////////////////////////////////////////////////
//
// lc456. 132 Pattern (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用降序stack，想像從後往前遍歷，當nums[i] > sk.back()，我們要讓third
    越大越好，所以一直pop_back()到nums[i] <= sk.back()。

*** follow up: 找出所有132 pattern。
*** follow up: 312 pattern。

///////////////////////////////////////////////////////////////
//
// lc457. Circular Array Loop (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc287。
    Since in this problems, we can find a loop when we start from any index. 
    All we need to do is check if this loop has correct direction and loop cycle greater than 1.
    We mark all position we have been to 0. 
    so any point we travese will not more than 3 -> linear time complexity.
    time: O(n)
    space: O(1)

///////////////////////////////////////////////////////////////
//
// lc459. Repeated Substring Pattern (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) KMP算法中的next，也就是算出到第n位，最大重複字串長度為l，
    則return n % (n-l) == 0
(2) 利用字串長度匹配，因為可以拆分，從i = n/2 ~ 1 去找出的res。
    substr(i) == substr(0, n-i)

///////////////////////////////////////////////////////////////
//
// lc460. LFU Cache (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持 
    unordered_map<int,list<pair<int,int>>::iterator> map;
    此為key對應其所在位置

    unordered_map<int, list<pair<int,int>>> ll;
    此為key出現次數，對應list，將list用出現次數做分類

    unordered_map<int,int> key_cnt;
    此為key的出現次數

    此外維持min_cnt表示當前最小的key出現次數。
    有兩個地方要更新:
    (a) 若get key，使得ll[min_cnt].size() == 0，min_cnt++
    (b) 若pop key，使得ll[min_cnt].size() == 0，min_cnt++

///////////////////////////////////////////////////////////////
//
// lc461. Hamming Distance (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) n = x^y，計算1的個數，
    n &= (n-1)，表示移除最右邊的1。所以用while來看可移除幾個1即為答案。

///////////////////////////////////////////////////////////////
//
// lc463. Island Perimeter (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs，initial當前周長4，當前周圍有聯通點就-1。
(2) 4*count-2*repeat，計算總邊長再減去內部邊長*2。

///////////////////////////////////////////////////////////////
//
// lc468. Validate IP Address
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) parse string

///////////////////////////////////////////////////////////////
//
// lc472. Concatenated Words (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 類似lc139，lc140。利用idx紀錄當前位置以及cnt，往後比較在set內有沒有。
    若有->遞歸。
    若idx == s.size() && cnt >= 2，return true。
    * time分析類似lc131：n*2^n
(2) 不用cnt，改用一個map<int,int>紀錄當前位置的次數，memorization。

///////////////////////////////////////////////////////////////
//
// lc474. Ones and Zeroes (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp[m][n] = max(dp[m][n], dp[m-zeros][n-ones]+1)
    類似lc416，lc494。

///////////////////////////////////////////////////////////////
//
// lc476. Number Complement (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每個bit取出(&1)後做xor(^1)。
(2) mask

///////////////////////////////////////////////////////////////
//
// lc477. Total Hamming Distance (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

對於每1bit，可以發現不同數量總和就是有多少種0和1配對，
因次將同1bit的0和1計算出來數量後相乘。

///////////////////////////////////////////////////////////////
//
// lc480. Sliding Window Median (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用multiset and iterator，
    注意插入比自己小的，--median，
    刪除小於等自己的，++median。
(2) 利用two set，類似lc295。

///////////////////////////////////////////////////////////////
//
// lc482. License Key Formatting
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後往前做即可。

///////////////////////////////////////////////////////////////
//
// lc485. Max Consecutive Ones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到0將cnt設為0。

///////////////////////////////////////////////////////////////
//
// lc486. Predict the Winner (看) 注意跑遞迴要用dp來避免重複計算。
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

(1) 一般遞迴：
    利用兩個sum來記錄兩個玩家選取的總和，當前玩家要贏代表選完後的下一輪玩家會輸。
(2) dp recursion：
    利用dp[start][end]代表這區間內贏最多的量(不管玩家是誰)，return dp[0][n-1] >= 0。
    time: O(n^2)
(3) dp iteration：類似方法2，一樣去找區間內贏做多。
    從長度1去延伸到長度n
    dp[start][end] = max(nums[start]-dp[start+1][end], nums[end]-dp[start][end-1]);
    優化: O(n) 類似lc1035, lc1143, lc583

///////////////////////////////////////////////////////////////
//
// lc487. Max Consecutive Ones II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer，類似lc1004。

///////////////////////////////////////////////////////////////
//
// lc488. Zuma Game (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) "RRWWRRBBRR", "WB" = 2
    RRWWRRBBRR -> RRWWRRBBR[W]R -> RRWWRRBB[B]RWR -> RRWWRRRWR -> RRWWWR -> RRR -> empty
    "WWBBWBBWW", "BB" = -1
    插入每個位置去試。
    dfs with memorization。

///////////////////////////////////////////////////////////////
//
// lc489. Robot Room Cleaner (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為機器人不知道面朝哪個方向，需要有個dir表示當前機器人朝的方向，也要用set
    記錄走過的路。

///////////////////////////////////////////////////////////////
//
// lc490. The Maze (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

重點： 紀錄停留點，確保停留點不會被走。
(1) 利用dfs，當可以走，就繼續走，走到下一個是邊緣或1就停，紀錄這個停留點，確保
    下次不會走。
(2) 利用bfs，和dfs一樣的解法。

///////////////////////////////////////////////////////////////
//
// lc491. Increasing Subsequences (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，類似subset重複題目：lc090，唯一差別是重複數字不一定相鄰，
    所以要用vector紀錄該層的出現情況。
    -> 因為不能排序，用set記錄這一輪走過的點，走過就跳過。
(2) iteration，類似lc090的作法，差別在於lc090的重複是連續的，這題是不連續，
    所以必須用map紀錄上一次插入的位置。

///////////////////////////////////////////////////////////////
//
// lc493. Reverse Pairs (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用divide & conquer
    類似lc315，lc327，lc1389。
    對nums[i]做排序，且對於每一輪找到第一個nums[i] > 2*nums[j]
    res += j-mid-1。

///////////////////////////////////////////////////////////////
//
// lc494. Target Sum (看)** 三種方法都看
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 3

建立dp，dp[i][n]為計算到i-1個idx，且和為n的方法數

(1) recursion：dp[i][n] = dp[i-1][n-nums[i-1]] + dp[i-1][n-nums[i+1]];

(2) iteration：dp[i+1][n+nums[i]] += dp[i][n];
               dp[i+1][n-nums[i]] += dp[i][n];
               可優化空間從O(n^2)至O(n)。
(3) 高級寫法，轉完lc416。
    ex: a+b-c=s -> a+b = c+s
    可將題目轉為當前數組with s，可不可以分成兩半。

///////////////////////////////////////////////////////////////
//
// lc496. Next Greater Element I (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc503，利用stack iteration並看用map去將有找到next的數字記錄起來，
    這樣nums1去找如果有在map裡就可以有next greater element，反之則-1。
(2) 對於nums1的每一個數字去找nums2中對應位置，以及其next greater element，
    若找不到則為-1。

///////////////////////////////////////////////////////////////
//
// lc497. Random Point in Non-overlapping Rectangles (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc528。
    做出prefix sum based on 每個方形面積。
    並算出當前的weight，point_index = weight - 1。
    x = point_index % x_side + x_start
    y = point_index / x_side + y_start
    time: O(logN)
(2) 也可以用resivoir sampling，對於每一個跑n次rect，若當前rand%sumarea < current area，
    使用這個rect。

///////////////////////////////////////////////////////////////
//
// lc498. Diagonal Traverse (看) method 2。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1)找出規律，若右上結束，先往右，不能的話再往下。
            若左下結束，先往下，不能的話再往右。

(2) 若往右上，
        邊界：  (1) c>=col -> c--，r+=2;
                 (2) r < 0  -> r++;
                 換方向。
    若往坐下，
        邊界：  (1) r>=row -> r--，c+=2;
                 (2) c < 0  -> c++;
                 換方向。

follow up：一直右上對角或是一直左下對角。

///////////////////////////////////////////////////////////////
//
// lc500. Keyboard Row
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用unordered_set來選擇有沒有同一個row。

///////////////////////////////////////////////////////////////
//
// lc501. Find Mode in Binary Search Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，因為是bst，利用indorder可以走訪有序排列，隨時維持到上一個node (pre)
    最大數量，若當前val!=上一個node->val，看看pre node出現次數有沒有比max_cnt多。
    注意！！！跑完遞迴要再檢查一遍，因為可能右下角node數量>=max_cnt。

///////////////////////////////////////////////////////////////
//
// lc503. Next Greater Element II (看)* 注意第二遍。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 跑兩遍，對每一個數字若大於stack的top代表是top的第一個最大。

///////////////////////////////////////////////////////////////
//
// lc505. The Maze II (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) Dijkstra, O(n^2 + nlogn)
(2) bfs with normal queue, O(n^2)
(3) dfs, O(n!)
    since every nodes may be updated after it has been visited. 
    Therefore, the DFS tree should have n children in general.

///////////////////////////////////////////////////////////////
//
// lc506. Relative Ranks (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 排序後，將其index保留，最後依照index依序給名次。

///////////////////////////////////////////////////////////////
//
// lc507. Perfect Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc204，計算因數，用 i = 2 ~ sqrt(n)去找。若nums % i == 0，
    sum += i + num/i，若完全平方數，sum += i (意即i*i = num)。

///////////////////////////////////////////////////////////////
//
// lc508. Most Frequent Subtree Sum 
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs配上unordered_map。

///////////////////////////////////////////////////////////////
//
// lc509. Fibonacci Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc91，O(1) space。

///////////////////////////////////////////////////////////////
//
// lc510. Inorder Successor in BST II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc450，lc285，利用bst特性，往right的最左，沒有的話，往parent，若
    parent->left == now，return parent。

///////////////////////////////////////////////////////////////
//
// lc513. Find Bottom Left Tree Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) bfs找上一層qsize等於0時的當前queue head的值。
(2) dfs找當前層樹高度比最大層樹大的值，因為同層最左邊的點在dfs一定第一個被找到。

///////////////////////////////////////////////////////////////
//
// lc515. Find Largest Value in Each Tree Row
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

基本走訪tree的題目。
(1) bfs
(2) dfs

///////////////////////////////////////////////////////////////
//
// lc516. Longest Palindromic Subsequence (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc647，lc005。
    space O(n^2)
    s[i] == s[j] -> dp[i][j] = dp[i+1][j-1]+2, 
    s[i] != s[j] -> dp[i][j] = max(dp[i+1][j], dp[i][j-1])。
    也可用遞迴。

///////////////////////////////////////////////////////////////
//
// lc518. Coin Change 2 (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp iteration：
    dp[i] += dp[i-coins[j]];
(2) dfs recursion：
    因為沒有min，max的比較，不能用一般的dp recursion，這邊使用dfs，
    盡可能用完一個硬幣再往下一個硬幣做使用，並且儲存目前amount和使用到的硬幣作為
    記憶，避免重複運算。

///////////////////////////////////////////////////////////////
//
// lc523. Continuous Subarray Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

prefix sum。
類似lc560，lc713，lc974。
(1) 利用dp，因為要求至少長度為2，所以紀錄相同餘數第一次和當前i，
    if (i-map[rem] > 1) return true。
    注意：餘數0的initial index為-1。

///////////////////////////////////////////////////////////////
//
// lc524. Longest Word in Dictionary through Deleting
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc392, lc792

(1) 單純two pointer
(2) map[i][j]表示從index i開始下一個ch (j+'a')出現的位置
(3) 走一遍s就好，每個s[i]的vec裡面找出已走完的dic word去和res做比較


///////////////////////////////////////////////////////////////
//
// lc525. Contiguous Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum。
    因為要計算最大區間同樣0，1數量，可將0作為-1，做累加，若當前和之前遇過，
    代表這區間0，1數量一樣。

///////////////////////////////////////////////////////////////
//
// lc526. Beautiful Arrangement (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 利用swap找到這個位置符合條件的再往下一個位置走，再來從後面開始是因爲
    若從頭開始，小的數字容易符合條件然後走太深但卻沒不成功，大的數字開始，往
    頭走很容易就失敗，這樣就比較有效率。

///////////////////////////////////////////////////////////////
//
// lc528. Random Pick with Weight (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，先用prefix sum將每個weight加總，再random generate
    一個index，用binary search找到其對應的index for sum。

///////////////////////////////////////////////////////////////
//
// lc529. Minesweeper
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) dfs
(2) bfs

///////////////////////////////////////////////////////////////
//
// lc530. Minimum Absolute Difference in BST
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) inorder找相連兩個node的差值。
(2) preorder，維持一個minv和maxv區間，類似lc098。

///////////////////////////////////////////////////////////////
//
// lc531. Lonely Pixel I
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) 對於當前有'B'，往該row和col找，若有，標示那一row or col已有，之後再經過
    那row or col，直接跳過。
(2) 先計算整個matrix每個row和col有多少'B'，再遍歷一次，若當前是'B'，且該row和
    col都是1(只有這個'B')。
    O(mn) time, O(m+n) space
(3) 第二遍for loop時，去找若當前row只有一個b且該j在cc[j] == 1，++res。
    O(mn) time, O(n) space

///////////////////////////////////////////////////////////////
//
// lc532. K-diff Pairs in an Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use map，因為同樣的pair只能處理一次，所以第一次遇到num[i]，檢查num[i]+k和num[i]-k
    有沒有存過。
    若k == 0，只有在map[nums[i]] == 1時++res。
(2) 先跑一遍計算個數，再遍歷map，找m.first+k存在或!k且m.second > 1，++res。

///////////////////////////////////////////////////////////////
//
// lc535. Encode and Decode TinyURL (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 看下列解釋

https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/100268/Two-solutions-and-thoughts

///////////////////////////////////////////////////////////////
//
// lc536. Construct Binary Tree from String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs，對於左孩子或右孩子要不要跑recursion，看當前s[idx] == '('。
    接完要++idx，跳過')'。

///////////////////////////////////////////////////////////////
//
// lc537. Complex Number Multiplication
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本複數運算。

///////////////////////////////////////////////////////////////
//
// lc538. Convert BST to Greater Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

基本inverse inorder。
(1) recursion
(2) stack iteration
(3) morris traversal

///////////////////////////////////////////////////////////////
//
// lc539. Minimum Time Difference
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(nlogn)，做排序，前後比較。
(2) O(n)，總數量1440，可填進去做one pass check，bucket sort。

///////////////////////////////////////////////////////////////
//
// lc540. Single Element in a Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，找出左邊還是右邊個數為奇數，往奇數的方向找。

///////////////////////////////////////////////////////////////
//
// lc541. Reverse String II (看) 這種要細心。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每2k位中的前k位，reverse，若不及k位，reverse 從i往後s.size()-i位。

///////////////////////////////////////////////////////////////
//
// lc542. 01 Matrix (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) double pass，第一遍檢查左上的最小值與自己相比，第二遍檢查右下的最小值與自己相比。
    第一遍碰到非零的要比較，第二遍碰到非0或1的要比較。 
(2) bfs：對0的點全部加入queue，在queue中檢查鄰近有1(且值比當前+1還要來得大)的加入queue，
         且改為0，如洋蔥式解法。
(3) dfs：對有1(有1代表旁邊是0，對原本為1且旁邊都是1的改為INT_MAX)的丟入dfs，
         在鄰近中值比當前+1來得大的繼續dfs。

///////////////////////////////////////////////////////////////
//
// lc543. Diameter of Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder
    算出一棵樹最長的路徑，其實也就是對於任一node，找出其左右子樹深度和的最大。

///////////////////////////////////////////////////////////////
//
// lc545. Boundary of Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，將tree分成兩部分，維持兩變數表示當前是left boundary或right boundary。
    以左邊為例，左邊不能走時要往右走，
    left_bound = left_bound & !root->left
    若可以往左走，
    left_bound = left_bound & root->left
    右邊一樣。

///////////////////////////////////////////////////////////////
//
// lc547. Friend Circles
//
///////////////////////////////////////////////////////////////

最佳解： method 1

為避免重複查找，紀錄查找過的人 (visit[i])。
(1) dfs。
(2) bfs。

///////////////////////////////////////////////////////////////
//
// lc549. Binary Tree Longest Consecutive Sequence II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc298。
(1) postorder，分case去討論，維持一個diff，表示current node和child node的
    difference。

///////////////////////////////////////////////////////////////
//
// lc556. Next Greater Element III
//
///////////////////////////////////////////////////////////////

(1) 類似lc031，多了一個boundary check。

///////////////////////////////////////////////////////////////
//
// lc557. Reverse Words in a String III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) reverse string when facing space
    類似lc 151 method 1。

///////////////////////////////////////////////////////////////
//
// lc559. Maximum Depth of N-ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc104，lc111。
(1) 利用postorder來算出深度。

///////////////////////////////////////////////////////////////
//
// lc560. Subarray Sum Equals K (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum解法，記錄當前sum出現次數，
    若當前sum-k之前有出現過，代表在idx以前某一處之和道當前idx差距為k，
    將這些和到idx累積的sum差距k的次數加入res。
*** follow up: find maximum subarray that sum equal to k

(2) 一般O(n^2)解法，類似lc300的dp。(方法三)

///////////////////////////////////////////////////////////////
//
// lc561. Array Partition I (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 因為兩兩一組，若都把大的和小的分一組，這樣一定會比小小一組，大大一組來的小，
    因此先排序，每兩個取第一個加在res極為所求。
(2) Counting sort，維持一個變數，決定當前的數字要不要加入。

///////////////////////////////////////////////////////////////
//
// lc563. Binary Tree Tilt
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，postorder，從底層開始隨時記錄到目前為止(包含自己)所有的和，
    和res(tilt)。

///////////////////////////////////////////////////////////////
//
// lc565. Array Nesting
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遍歷一次，每次走循環，紀錄最大長度。
    ***空間優化：對於使用過的應該再它原來的位置，
    所以，
    while (i != nums[i])
        swap(nums[i], nums[nums[i]]);

///////////////////////////////////////////////////////////////
//
// lc566. Reshape the Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n*m)。

///////////////////////////////////////////////////////////////
//
// lc567. Permutation in String (看)* 看方法二。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc438。

兩個都用slding window，但方法2只要一個hash table。
(1) 計算出現次數每次滑動一格計算tmp有沒有等於res。
(2) 向右滑動直到==0比較right-left+1 == n，return true，
    若<0，left向右移動直到==0，此目的是恢復那個-1的字母，也代表被中斷，從
    中斷的字母向右一個為新的left邊界。

///////////////////////////////////////////////////////////////
//
// lc572. Subtree of Another Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若當前node值一樣，直接比較兩棵樹是否相同。
    若不一樣，比較s->left和t，以及s->right和t
    time: O(nm) space: O(max(m, n))
(2) 類似lc652。
    time: O(n+m) space: O(max(m, n))

///////////////////////////////////////////////////////////////
//
// lc575. Distribute Candies (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找出kind種類，若 > 一半糖果數量，則return 一半糖果數量，否則return kind數量。
    return 一半糖果數量是因為最多sister只能拿一半的糖果，就算kind數量多於一半糖果數量。

///////////////////////////////////////////////////////////////
//
// lc581. Shortest Unsorted Continuous Subarray (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) 對於每個非升序的node，找到其該插入的位置並記錄start，則res = i-start+1。
    這res會隨著每個非昇序的node update一次，且start要選插入中最小的位置。
(2) 先創一個tmp vector並將他排序，這樣便一一對照nums來找到第一個不等的
    和最後一個不等的index。
(3) ！！！最好解法，跑兩遍，一遍找最大值，且確認最大值有沒有大於nums[i]，
    若沒有代表右邊界，最小值反之。

///////////////////////////////////////////////////////////////
//
// lc582. Kill Process
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

先建立data structure，unordered_map<int, vector<int>> child

(1) dfs recursion to add child
(2) use queue, bfs

///////////////////////////////////////////////////////////////
//
// lc583. Delete Operation for Two Strings (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1143，O(n) space。

///////////////////////////////////////////////////////////////
//
// lc589. N-ary Tree Preorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc114，利用stack iteration。

///////////////////////////////////////////////////////////////
//
// lc590. N-ary Tree Postorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 2, 3

(1) recursive solution
(2) iterative solution using stack (same as lc145)
(3) 後敘可用前敘的結果顛倒，
    但要注意的是放入stack要從左到右放(前敘放入stack是從右到左放)。

///////////////////////////////////////////////////////////////
//
// lc594. Longest Harmonious Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 使用map，對於map中的數字若存在+1，計算兩著的val和
(2) 先排序，利用sliding window去維持一個差距1的區間。

///////////////////////////////////////////////////////////////
//
// lc598. Range Addition II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每次operation找出最小值，return minr*minc。

///////////////////////////////////////////////////////////////
//
// lc599. Minimum Index Sum of Two Lists
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map，將list1的插入map，在跑list2時，只看list2[i]在map出現過，計算其
    index總合後，以最小的index和的list2[i]加入res。

///////////////////////////////////////////////////////////////
//
// lc605. Can Place Flowers
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前和左邊和右邊是空的，n--，當前更新為1。
    n = 0 直接return true。

///////////////////////////////////////////////////////////////
//
// lc606. Construct String from Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若左孩子空但右孩子非空，需要加()在root後面。

///////////////////////////////////////////////////////////////
//
// lc611. Valid Triangle Number (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n^2logn)
    先排序，因為完成三角形是任兩邊大於三邊，其實可以用小技巧：最短兩遍大於第三邊就代表是三角形。
    所以決定好兩邊以後第三邊可用binary search。
(2) O(n^2)
    從後面遍歷，每次跑一個迴圈固定符合題目的區間：
    while (left < right)
        if (nums[left] + nums[right] > nums[i])
        表示left~right-1都是邊長nums[right]和nums[i]的候選人。

///////////////////////////////////////////////////////////////
//
// lc617. Merge Two Binary Trees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，注意當遇到t2 = NULL, return t1，反之。

///////////////////////////////////////////////////////////////
//
// lc621. Task Scheduler
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 因為目標是計算要填多少個idle，對於每個同樣task要隔n個slot，先找出出現最多次(max_len)的字母和
    有多少個這樣的字母(max_cnt)，對於每個pair(長度：n+1)，數量：max_len-1，
    則每個pair還可填空n-(max_cnt-1)->employment_slot
    目前用了(max_len) * max_cnt，所以avalible_slot為len(tasks) - (max_len) * max_cnt)。

    idle 為 max(0, employment_slot - avalible_slot)，若右項為負表示填完所有pair，
    還有剩的字母，代表用原長度就好了。
    return len(tasks) + idle。
(2) 找出最多次數的種類個數，單foor loop即可完成。
    則：
    return max((maxcnt-1)*(1+n)+kind, (int)tasks.size());

///////////////////////////////////////////////////////////////
//
// lc622. Design Circular Queue
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc641。

(1) 用length當作判斷標準。
(2) 用一boolean tag和頭尾index當作判斷標準，比較難想。

///////////////////////////////////////////////////////////////
//
// lc623. Add One Row to Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion
(2) bfs iteration

///////////////////////////////////////////////////////////////
//
// lc624. Maximum Distance in Arrays (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要選的minv和maxv去算的距離不能同一個，維持minv和maxv，遇到新的arrays[i]，
    先去和arrays[i]的頭尾計算最大值，再去更新minv和maxv，這樣計算最大值
    就不會用到同一個arrays[i]的值。

///////////////////////////////////////////////////////////////
//
// lc628. Maximum Product of Three Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(nlogn)，先排序，找出任三數最大只有兩種組合，兩負一正或三正，兩負的最小
    可取排序後的前兩個，三正最大就取最後三個。
(2) O(n)，找到最大三個和最小兩個。

///////////////////////////////////////////////////////////////
//
// lc636. Exclusive Time of Functions (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用stack，若stack不為空，將res[sk.top()] += time - last_time，
    last_time為上一次log的時間
    遇到start，把func id push到stack，
    遇到end，將res[sk.top()]++，且last_time++，因為end time + 1，
    last_time也要跟著更新而加一。

///////////////////////////////////////////////////////////////
//
// lc637. Average of Levels in Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 基本dfs。
(2) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc638. Shopping Offers (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持當前needs * prices，當作最大需要金額，對於當前needs，若存在一個
    special使得needs各項 >= 0，就算出remain放入dfs，
    比較 money = min(money, special_price + dfs())。

///////////////////////////////////////////////////////////////
//
// lc641. Design Circular Deque (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc622。

(1) 用len去判斷，注意edge case，也就是len == 0時做enque或len == 1時做
    deque，這兩個edge case，start或end指針不移動。
(2) 用start和end去想，不用考慮edge case。

///////////////////////////////////////////////////////////////
//
// lc643. Maximum Average Subarray I
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於前k位，累加，對於之後的位數 sum += num[i]，sum == nums[i-k]。

///////////////////////////////////////////////////////////////
//
// lc645. Set Mismatch (看) 第三種解法。
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) 利用總合來算出少哪一個數字。
(2) 類似lc442，找出重複項就是將那個nums[abs(nums[i])-1]是不是負的，
    若是代表之前就被指過一次。找沒出現過的就是指過去為正的代表沒被指過，意即沒有出現。
(3) method 2的better version，只用一次for loop。

///////////////////////////////////////////////////////////////
//
// lc646. Maximum Length of Pair Chain (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 先排序，再來進行一次遍歷，
    對於當前尾端比min小的話min = 當前尾端。 這是因為一直維持尾端最小才能找出最常鍊子。
    若當前頭比min大，min = 當前尾端，且len++。
(2) 也可對尾端進行排序。

///////////////////////////////////////////////////////////////
//
// lc647. Palindromic Substrings
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 類似lc005。
(2) dp： dp[i][j] = 1 if (j-i<2) || dp[i+1][j-1] == 1

///////////////////////////////////////////////////////////////
//
// lc648. Replace Words (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 字串處理，dict排序後，將同樣字母頭的放到對應為中check[26],
    再將sentence以空白分開，每個去跑對應的check，因為dict有排序過，第一個
    碰到的就取代sentence中的單字。
    n: # of dict, m: avg len of wd in dict, p: # of wd in sentence
    time: nlogn + pnm
(2) 利用prefix tree，先將dict加入tree，再對sentence中每個單字去找有沒有遇到prefix。    
    x: avg len of wd in sentence
    time: nm + px

///////////////////////////////////////////////////////////////
//
// lc650. 2 Keys Keyboard (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) dp iteration，dp[i]為長度i的次數。
    對於這種題目，需要舉例來找規律，對於n，其最大次數為n，但其實n可以被整除n的長度所
    複製貼上，所以dp[n] = dp[i] + n/i。
    n/i表示用n長度需要做的次數，通常為複製一次和貼上次數。
    ex: dp[6] = dp[3]+6/3，也就是已有長度3的次數，複製一次長度3再貼上一次，
    所以操作3次。
    O(n) space, O(n^2) time greedy

(2) 利用greedy，盡可能複製大的長度，這樣貼的就比較小 -> return n/i + minSteps(i);
    所以，n/i越小越好，minsteps(i)想像成複製程度，n/i想像成貼的次數。
    O(log(n)) space, O(nlogn) time greedy

(3) O(1) space, O(nlogn) time greedy
    greedy的原則就是：盡量分得塊越大越好，這樣得到的塊複製和貼上的次數越少

*** Note: 可修改為recursion。

///////////////////////////////////////////////////////////////
//
// lc652. Find Duplicate Subtrees (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 使用postorder，將得到的當前tree用 f表示，並用map紀錄有沒有出現過。
    丟到res只在目前出現一次，超過一次都不丟，目的是重複substree只丟一次避免重複丟。

///////////////////////////////////////////////////////////////
//
// lc653. Two Sum IV - Input is a BST
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 可用set，來判斷當前root->val 有沒有在set中，
    set中數字都是之前k-root->val的候選人，inorder。
(2) 建立兩個sk，存往左邊和往右邊的node，再利用inorder去跑2 sum。

///////////////////////////////////////////////////////////////
//
// lc654. Maximum Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) ***難想：
    維持一個降序陣列。
    當陣列空的，push當前值
    當陣列不為空：
        遇到當前的數字若比vector中最後一個小，vector最後一個->right = 當前。
        跑回圈從陣列後面找，直到最後一個比當前小的(這中間都pop，包含這最後一個比當前小的)，
        當前->left=最後一個。且將當前push到陣列裡，陣列最後一個->right = 當前。
(2) 遞迴遍歷數列找最大值當root建樹。

///////////////////////////////////////////////////////////////
//
// lc655. Print Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先算出高度，然後跑一遍preorder，維持左右邊界，mid = (l + r ) / 2
    res[h][mid] = val。

///////////////////////////////////////////////////////////////
//
// lc657. Robot Return to Origin
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似valid paratheness。

///////////////////////////////////////////////////////////////
//
// lc658. Find K Closest Elements (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) binary search找到第一個大於x的數字，左右一起搜尋。
(2) 高級寫法：binary search
    若左右邊界和x相同，right = mid;
    想像成
    每次有兩個arr比較誰靠近x，第一個mid~mid+k-1，第二個mid+1~mid+k，
    所以比較第一個左邊界和第二個右邊界來決定。
    若右邊界靠近x，left = mid+1;
    若左邊界靠近x，right = mid;
    若相同，選左邊的arr。    

///////////////////////////////////////////////////////////////
//
// lc659. Split Array into Consecutive Subsequences (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(1) space
    維持p1, p2, p3, c1, c2, c3，p表示以上一個數字(不等同現在的)結尾的長度為1
    or 2 or 3的個數，分三個case，
    (a) nums[i-1] == nums[i]
        表示可以將p_x 接到當前的c_x+1，x從小的接。
    (b) nums[i-1] + 1 == nums[i]
        表示當前c_x可以變長，在此確認p1和p2必須 == 0，否則return false
        因為c這時要變成p，若p1或p2還有值，表示儘管c == p+1，且新增c讓p減少，但還是
        有p1和p2沒有都是0，意即c不夠讓p1和p2都是0。
    (c) nums[i-1]+1 < nums[i]
        重置c1 = 0，其餘都=0，在此前要確認c1和c2都要等於0，否則return false。
(2) O(n) space
    two pass
    維持last[i]表示以i結尾的個數。
    優先看前面有沒有，ex: 1,2,3,4,5,6,7
    若先往後看，7沒辦法配對。
    (a) 若當前可以加入last[i-1]，last[i-1]--，last[i]++。
    (b) 若不行，則以現在開始往右兩個，三為一組當sequence，
        cnt[i+1]--，cnt[i+2]--，但若這兩個沒有>0，則return false，因為沒辦法
        組成3 sequence。

///////////////////////////////////////////////////////////////
//
// lc661. Image Smoother (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc289。
    因為8位(0-255)，可以開16bit，左8bit儲存結束value，右8bit儲存本來的value。
    取周圍的值可以用 M[i][j] & 0xFF。

///////////////////////////////////////////////////////////////
//
// lc662. Maximum Width of Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若用dfs，會overflow，對於每一層都減掉最左邊node的值，這樣才不會overflow。

///////////////////////////////////////////////////////////////
//
// lc663. Equal Tree Partition (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1339。
    利用set將出現過的sum都紀錄，找到sum/2在set有出現且sum % 2 == 0，
    return true。

///////////////////////////////////////////////////////////////
//
// lc665. Non-decreasing Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) check last, nums[i], nums[i+1], next
    if last > nums[i+1] && nums[i] > next
        return false。

///////////////////////////////////////////////////////////////
//
// lc666. Path Sum IV (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) top down，若val[parent] > 0, res -= val[parent]，且val[parent] *= -1，
    避免重複扣除在res。
    將parent valeu加到當前的val[node]，
    res += val[node]。

///////////////////////////////////////////////////////////////
//
// lc669. Trim a Binary Search Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc938。
(1) 對於當前node先移動的區間內，再來利用dfs對於左孩子和右孩子重複上述的動作。
(2) iteration O(1) space，先找到第一個區間內的點，對左和右trim。
    因為root已經固定，盡可能地往左走和往右早找最左和最右邊在區間的點。

///////////////////////////////////////////////////////////////
//
// lc670. Maximum Swap (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find the last pair that num[i] < num[maxi] through loop from
    end to the start of the array。

///////////////////////////////////////////////////////////////
//
// lc671. Second Minimum Node In a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 利用postorder，當發現當前val != root val，直接return，因為沒必要
    往下走，這個val是從其往下走的subtree中最小的。
(2) preorder，當發現當前val != root val，因為可能是second minimum，
    res = min(res, root->val)，並且不用繼續往下走。

///////////////////////////////////////////////////////////////
//
// lc673. Number of Longest Increasing Subsequence (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) nlogn hard
    開一個dp裡面每個洞儲存以idx為長度，結尾為val的vector： (val, cnt)
    並且越晚插入的要累加最後一個val的cnt和自己當前的cnt(當前的cnt由上一個洞計算而來)
    資料結構：dp<vector<pair<int,int>>>。
    上一個洞也是用bs找，找到適合的點，其cnt(left-1)要從該欄位的最後一個cnt扣掉。

(2) dp，利用額外一個陣列len[i]來儲存當前idx i的最長子字串個數，
    若dp[i] < dp[j]+1表示len[i] = len[j]
    若dp[i] == dp[j]+1表示有相同最大子字串長度-> len[i] = len[i] + len[j]。
    類似lc 300 dp解。

///////////////////////////////////////////////////////////////
//
// lc674. Longest Continuous Increasing Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遍歷一遍nums，若當前小於等於上一個，就將當前長度和最大長度做比較。

///////////////////////////////////////////////////////////////
//
// lc678. Valid Parenthesis String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為*可以作為'(', ')', '*'，維持low，high。
    low: 最少需要')'數量
    high: 最多需要')'數量
    low 不可<0，否則之後可能會造成invalid string
    ex: (*)(

///////////////////////////////////////////////////////////////
//
// lc680. Valid Palindrome II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為比錯一次就false，當前若遇到比不對的，直接比較去掉最右邊是否回文和去掉最左邊
    是否回文。

///////////////////////////////////////////////////////////////
//
// lc681. Next Closest Time
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後往前，對於當前，若可以找到比較大的且小於limit，就return。

///////////////////////////////////////////////////////////////
//
// lc682. Baseball Game
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one pass。

///////////////////////////////////////////////////////////////
//
// lc684. Redundant Connection (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) union find
(2) bfs，類似lc207，lc310。

///////////////////////////////////////////////////////////////
//
// lc685. Redundant Connection II (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find，分三種case，
    a. 沒有一個點被兩個點指到，找到ap == bp，return 那條邊。
    b. 有一個點被兩個點指到，第二條邊的destination設置成0，目的是不做union find。
        因為這條邊是晚加入的，若沒有環，就移除重複被指到的第二條邊。
        b-1 若找到ap == bp，return 第一條邊，因為第二條邊沒被考慮到的情況下，
            還可以成環，第一條邊必須移除。
        b-2 若都沒找到，表示沒有環，return 第二條邊，也就是晚加入的

    第二條邊不做union find的原因是，若做的話，那他就會被考慮進去(在發現環的邊前)，到時發現環時，
    移除的邊是第一條邊，但這條邊可能不是造成還的
    ex: x - 1 - > x <- 2 ----\
                  |           x
                  3 -> x ->4 /

///////////////////////////////////////////////////////////////
//
// lc687. Longest Univalue Path
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder

///////////////////////////////////////////////////////////////
//
// lc690. Employee Importance
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) simple bfs
(2) simple dfs

///////////////////////////////////////////////////////////////
//
// lc692. Top K Frequent Words 
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

類似lc347
(1) priority queue
(2) bucket sort

///////////////////////////////////////////////////////////////
//
// lc694. Number of Distinct Islands
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，紀錄方向，注意當前結束遞迴要加tag，不然分不出來，
    ex: 1 1  and  1 1 。
          1       1

///////////////////////////////////////////////////////////////
//
// lc695. Max Area of Island
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dfs。
(2) bfs。

///////////////////////////////////////////////////////////////
//
// lc696. Count Binary Substrings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持pre, cur，表示上一個和當前的同樣字元的長度
    當s[i] != s[i+1], res += min(pre, cur)。
(2) 當s[i] != s[i+1], 計算最長長度，更新i = right-2。

///////////////////////////////////////////////////////////////
//
// lc697. Degree of an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用兩個unoredered_map，一個找出nums[i]的起始位置，另一個找出nums[i]出現
    次數。

///////////////////////////////////////////////////////////////
//
// lc698. Partition to K Equal Sum Subsets
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1)

///////////////////////////////////////////////////////////////
//
// lc700. Search in a Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 基本dfs。
(2) iteration using bst。

///////////////////////////////////////////////////////////////
//
// lc701. Insert into a Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 基本dfs。
(2) O(1) space。

///////////////////////////////////////////////////////////////
//
// lc703. Kth Largest Element in a Stream
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) priority queue

///////////////////////////////////////////////////////////////
//
// lc704. Binary Search
//
///////////////////////////////////////////////////////////////

最佳解： method 1

基本binary search，注意跳出迴圈要檢查nums[left]是否等於target。

///////////////////////////////////////////////////////////////
//
// lc705. Design HashSet (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2, 3

(1) 用double array
(2) array of list: 利用list來處理collision的問題。hash(int)達到random
    access O(1)。
(3) bst node
    實作insert, remove，注意remove 若當前left和right都不為null，找到比當前大的
    最小node當新的root。 類似lc450。

///////////////////////////////////////////////////////////////
//
// lc706. Design HashMap (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 用double array
(2) array of list: 利用list來處理collision的問題。hash(int)達到random
    access O(1)。

///////////////////////////////////////////////////////////////
//
// lc708. Insert into a Sorted Circular Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到interval
    (a) now_v <= val <= next_v
    (b) now_v > next_v && (now_v <= val || val <= next_v)

///////////////////////////////////////////////////////////////
//
// lc709. To Lower Case
//
///////////////////////////////////////////////////////////////

最佳解： method 1

將大寫改成小寫，利用diff = 'A'-'a'。

///////////////////////////////////////////////////////////////
//
// lc713. Subarray Product Less Than K (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc209。
(1) 注意區間subarray計算為right-left+1。

///////////////////////////////////////////////////////////////
//
// lc714. Best Time to Buy and Sell Stock with Transaction Fee 
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc122。

///////////////////////////////////////////////////////////////
//
// lc716. Max Stack (看*)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lru cache。lc146。
    建立一個map<int, vector<list<int>::iterator>> map
    和一個list，list做為stack使用。
    read: O(1), write: O(logn)。

///////////////////////////////////////////////////////////////
//
// lc717. 1-bit and 2-bit Characters (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 從前面走。
(2) 從後面往回看，因為input合法，往前找1的個數，直到遇到0，若1為偶數，表示最後
    一個必為0，反之，奇數表示最後兩個bit為"10"。

///////////////////////////////////////////////////////////////
//
// lc718. Maximum Length of Repeated Subarray (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 利用dp iteration：tmp[j] = max(tmp[j], dp[j-1]);
    要用一個tmp dp的原因是這個dp數組不是升序或降序更新，為了避免這次更新到的數值
    影響到還未更新的數值，需要用一tmp dp來暫存。
    follow up : 這題其實就是longest commom subsequence。
    類似lc1143。
(2) O(n) space dp
    if (s[i] != s[j])
        dp[j] = 0;

///////////////////////////////////////////////////////////////
//
// lc720. Longest Word in Dictionary (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) sort, O(nllogn), n: # of words, l: average lenth of a word.
(2) trie tree
    time: O(nl), space: O(nl*26)

///////////////////////////////////////////////////////////////
//
// lc721. Accounts Merge (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs+queue，找出每個擁有這個信箱的使用者加到queue中。
    time: n + aloga, a is total mails
(2) union find，類似lc1135。

///////////////////////////////////////////////////////////////
//
// lc722. Remove Comments (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) We need to check three symbols

// : valid if we do not have /* before
/* : valid if we do not have /* before, skip to right next ch after '*'
*/ : valid if we have /* before, skip to right next ch after '/'

注意若*/ 的上一個match對象不是當前這一行，connect = 1，表示要和最後一line做連接。

///////////////////////////////////////////////////////////////
//
// lc723. Candy Crush (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找連續三個以上的candy，可以對於當前的往右和往下找連續三個以上，將所有
    一樣的標記負數。
    在drop candy時，對於每一column，從row-1往前將每個board[i][j] > 0的
    放到最尾端，用一個計數器來達成，最後計數器的位置到index 0全部標記成0。
    這樣就將crush candy都消除且將可以drop的candy全部drop。

///////////////////////////////////////////////////////////////
//
// lc724. Find Pivot Index
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於index左右兩邊和一樣，可以先算一遍sum，然後對於左邊保持一個變數cursum，
    若sum-nums[i] = cursum*2，return i。

///////////////////////////////////////////////////////////////
//
// lc725. Split Linked List in Parts (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先算出list長度，再對k求商數和餘樹，餘數即為從首相算要多加一個的欄位。

///////////////////////////////////////////////////////////////
//
// lc726. Number of Atoms
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc394。
    利用map<string, int>表示該層所有原子出現的數量。

///////////////////////////////////////////////////////////////
//
// lc727. Minimum Window Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc076。

///////////////////////////////////////////////////////////////
//
// lc729. My Calendar I (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) map，upper_bound找到前後兩個event，
    若next->start < end || prev->end > start
    return false;
(2) O(n^2) search
    兩者相交表示
    max(start1, start2) < min(end1, end2)

///////////////////////////////////////////////////////////////
//
// lc731. My Calendar II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 若start time ++, end time --，
    計算event重複最大的數量。
    O(n*(n+logn))
(2) 維持兩個vector，一個one，一個two，two表示區間都是兩個event佔據。
    O(n^2)

///////////////////////////////////////////////////////////////
//
// lc733. Flood Fill
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若當前顏色和newColor相同，直接return。反之做dfs，將四周的tagColor的
    顏色改成newColor。
    類似lc1034。

///////////////////////////////////////////////////////////////
//
// lc734. Sentence Similarity
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) union find，但不能transition，(a,b) (b,c)， a和c沒關係。
    用unordered_map<string, unordered_set<string>> map紀錄每個和這個
    words相關的所有similar words。
(2) 利用set，紀錄pairs[0] + " " pairs[1] 和 pairs[1] + " " + pairs[0]

///////////////////////////////////////////////////////////////
//
// lc735. Asteroid Collision
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若input < 0，check與stack back()的關係。

///////////////////////////////////////////////////////////////
//
// lc737. Sentence Similarity
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find，類似lc1135。

///////////////////////////////////////////////////////////////
//
// lc738. Monotone Increasing Digits (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要monotone increasing digits，從尾巴往前走。
    若nums[idx-1] > nums[i]，為了找到單調最大，--nums[idx-1]，
    且flush = i。
    flush是用來設置成從flush往後全部變成9。

///////////////////////////////////////////////////////////////
//
// lc739. Daily Temperatures
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc907，lc977，lc1019，lc1130，
利用stack來維持降序陣列。

///////////////////////////////////////////////////////////////
//
// lc740. Delete and Earn (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc198，dp[i] = max(dp[i-1], dp[i-2]+nums[i]);
    因為只能隔著拿，所以當前要當作錢的話，上一個就不能拿，要看上上個所賺的錢加上當前的錢。

///////////////////////////////////////////////////////////////
//
// lc742. Closest Leaf in a Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用dfs來build graph，用bfs來算出先到leaf的點。
    root的parent為0，且visit[0] = 1，防止visit到這個點(防止把這個點當成leaf)。

///////////////////////////////////////////////////////////////
//
// lc743. Network Delay Time (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2，3

(1) 利用dijkstra，對於加過的邊，只要可以更新就加入，隨時更新node的val。
(2) 對於有值的邊，只要val[i] > val[now]+res[now][i]，就更新並push i。
    不能把邊刪掉，因為不是用dijkstra。
    ex:
    [0, 1] = 1
    [1, 2] = 2
    [2, 4] = 2
    [0, 3] = 3
    [3, 4] = 4
    [4, 5] = 2
    [4, 5] 不能被刪掉，不然4被更新最小值後，無法更新node 5。
(3) Bellman Ford，最多跑n個點，想像成最多一輪更新一個點的最小值，每一輪，
    發現val[now] != max且val[i] > val[now]+res[now][i]，就更新val[i]

///////////////////////////////////////////////////////////////
//
// lc744. Find Smallest Letter Greater Than Target
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search

///////////////////////////////////////////////////////////////
//
// lc746. Min Cost Climbing Stairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space, dp
    n_1表示上一位方法數，n_2表示上上一位
    cur = min(n_1, n_2) + cost[i]
    n_2 = n_1
    n_1 = cur
(2) now = min(i_1+cost[i-1], i_2+cost[i-2]);
    i_2 = i_1;
    i_1 = now;

///////////////////////////////////////////////////////////////
//
// lc747. Largest Number At Least Twice of Others
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) Just maintain largest number index and second largest number index.

///////////////////////////////////////////////////////////////
//
// lc752. Open the Lock (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc126。
(1) bfs，O(k^d)。
(2) bidirectional bfs，O(k^(d/2))

///////////////////////////////////////////////////////////////
//
// lc754. Reach a Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為-10 和 10 次數都一樣，所以先將input轉成正的，再來累加到超過target。
    若sum和target差距為偶數d，表示其中一項d/2可以轉相反號(cnt)，若差奇數，判斷當前now，
    若now為奇數，則加上now(cnt+1)，若now為偶數，則加上now和now+1(cnt+2)

///////////////////////////////////////////////////////////////
//
// lc756. Pyramid Transition Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前level，跑到底，若到底，往下個level，較快，因為不用使用vector<string>
    去算出在單一level所有可能性的string。
(2) time complexity: O(a^n)，
    對於每個level算出所有可能性的string。    

///////////////////////////////////////////////////////////////
//
// lc759. Employee Free Time
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 建立merge interval array，則每一個interval之間即是free time
(2) 直接merge ，依照開始時間，到時候跑一次linear search當前比上一個大就是
    free time，這樣return arr只是merge based on start time，並沒有真的
    產生一個merge interval。
    兩個都是klogk*n, k: # of lists, n: # of element in a list

///////////////////////////////////////////////////////////////
//
// lc760. Find Anagram Mappings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用map紀錄index。

///////////////////////////////////////////////////////////////
//
// lc763. Partition Labels
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass，
    第一個pass找到每個字母的最後出現indx，
    第二個pass利用每個字母最後出現的indx找到最長重複字串。
    ->維持start,end，若當前字母的index > end，則計算end-start+1。

///////////////////////////////////////////////////////////////
//
// lc765. Couples Holding Hands (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用union find，兩兩一組，parent[i] = parent[i+1] = i。
    若當前兩兩部為一組，merge them，cnt++。
    return cnt。
    想像在同一個group的可以任意換位子，都還是合法。

///////////////////////////////////////////////////////////////
//
// lc766. Toeplitz Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 比較matrix[i][j] == matrix[i+1][j+1]。

///////////////////////////////////////////////////////////////
//
// lc767. Reorganize String (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 類似lc621，將最大的字母算出來，先填入，接下來依字母由a~z依序填入就好。

///////////////////////////////////////////////////////////////
//
// lc768. Max Chunks To Make Sorted II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 若當前可分成兩塊表示left_max[i] <= right_min[i+1]，因為從0~i的最大值比
    i+1~n-1的最小值來的要小，表示這邊可切割。分成兩塊去sort。
(2) 利用stack維持一個升序序列，若有比top小，就要判斷他可以插入到哪，也就是說
    從top到他插入的位置都是一塊，中間的stack成員都要刪除，return sk.size()
    表示可分成幾塊，其中的數值是個區間的最大值。

///////////////////////////////////////////////////////////////
//
// lc769. Max Chunks To Make Sorted
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持當前最大值maxv，當i > maxv或i == arr.size()-1，++res。
    類似lc763。

///////////////////////////////////////////////////////////////
//
// lc771. Jewels and Stones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，bucket sort，開一個128 size for all problems->
    constant space。
    O(j + s) time 。

///////////////////////////////////////////////////////////////
//
// lc772. Basic Calculator III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) recursion + stack。
    對於()裡面expresion，用stack紀錄。

///////////////////////////////////////////////////////////////
//
// lc776. Split BST (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc450。

(1) 維持兩個，一個比v要小或等於，一個比v大。
    若當前root->val <= v，則往root->right走，且return的兩個tree，
    root->right = res_return[0]，res_return[0] = root。
    
    若當前root->val > v，則往root->left走，且return的兩個tree，
    root->left = res_return[1]，res_return[1] = root。

///////////////////////////////////////////////////////////////
//
// lc777. Swap Adjacent in LR String (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer，比較當前非'X'值，
    若不一樣，return false   
    對於'L'， (i in start) >= (j in end)
    對於'R'， (i in start) <= (j in end)
    若有一條走完，檢查另一條有沒有非'X'值，若有，return false。

///////////////////////////////////////////////////////////////
//
// lc783. Minimum Distance Between BST Nodes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本inorder traversal。

///////////////////////////////////////////////////////////////
//
// lc784. Letter Case Permutation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

！！！注意大小寫轉換可以用c^32，因為英文字母大小寫差了32。
(1) 遞迴。
(2) 類似lc078的iteration，起始vector為{""}。

///////////////////////////////////////////////////////////////
//
// lc785. Is Graph Bipartite?
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，若自己的next和自己同一個group，return false。

///////////////////////////////////////////////////////////////
//
// lc791. Custom Sort String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count priority

///////////////////////////////////////////////////////////////
//
// lc792. Number of Matching Subsequences (看)方法2。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc392。
(1) 用double pointer和hashmap去做。
(2) 用一vector of pair,size 26，儲存每個words[i]到目前為止的匹配進度和
    其下一個字母index，若下一個字母index = words[i].size，++res，相反就
    移到對在vector所在的index並push_back進去i和其words[i]下一個index。
    vector<pair<int, int>> map[26]

///////////////////////////////////////////////////////////////
//
// lc796. Rotate String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 遍歷整個A，切割旋轉並與B比較，看是否相同。
(2) 因為若B為A的旋轉字串，其必在A+A之間，因此用string.find去找。

///////////////////////////////////////////////////////////////
//
// lc797. All Paths From Source to Target (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc801. Minimum Swaps To Make Sequences Increasing (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為當前要不要交換，也會牽扯到前一位要不要交換，因此利用state machine，
    建立swap[i] 和 noswap[i]兩變數，表示第i位交換的最小交換次數和第i位不交換
    的最小交換次數，則狀態方程可以分成兩個case：
    (1) A[i] > A[i-1] && B[i] > B[i-1]
        這個case本來就不用交換，所以noswap[i] = noswap[i-1]，
        但若i一定要交換則上一位也要交換，swap[i] = swap[i-1]+1。
    (2) A[i] > B[i-1] && B[i] > A[i-1]
        這個case是要交換的case，則swap[i] = min(swap[i], noswap[i-1]+1)，
        因為第i位要交換表示第i-1位不能交換。
        另外也可以第i位不交換，但第i-1位要交換：
        noswap[i] = min(noswap[i], swap[i-1])。
 ***可以優化成O(1) space，類似lc122，lc309。

///////////////////////////////////////////////////////////////
//
// lc802. Find Eventual Safe States
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs以及visit[i]，若當前visit[i] != -1，直接return visit[i]。
    visit[i]表示這個點是不是safe：0->not safe，1->safe。
    對於當前指向的都跑一遍dfs，只要一個return 0，就return visit[i] = 0。
    因為safe state表示怎麼走都要是safe。

///////////////////////////////////////////////////////////////
//
// lc807. Max Increase to Keep City Skyline
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先找到row_max和col_max，再算一次diff。

///////////////////////////////////////////////////////////////
//
// lc809. Expressive Words (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc208。
(1) 利用trie tree，將每個字串變為unique字串以及每個字母出現次數的組合。

///////////////////////////////////////////////////////////////
//
// lc811. Subdomain Visit Count
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) unordered_map 紀錄網址出現次數。

///////////////////////////////////////////////////////////////
//
// lc814. Binary Tree Pruning
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，當前為0且左右子樹為null，當前改null。

///////////////////////////////////////////////////////////////
//
// lc817. Linked List Components
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到斷點，代表有一個component，所以res = res+1。
    可用one pass with unordered_set。

///////////////////////////////////////////////////////////////
//
// lc819. Most Common Word (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先遍歷一遍將大寫轉成小寫，非字母轉成空白，再利用unordered_map與istringstream，
    去計算字串出現次數。
(2) 利用double pointer去比較，若當前字母不一樣，去驗證可不可以延展。
    即s[i-1] == s[i] == s[i+1] or s[i] == s[i-1] == s[i-2]
    為什麼不比較s[i] == s[i+1] == s[i+2]是因為如果在連續字母的第一格s[i] != w[j]
    後面也不用比了，直接return false。

///////////////////////////////////////////////////////////////
//
// lc821. Shortest Distance to a Character (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass，從左到右，第二次從右到左。
    第一次 idx = i-last_loc
    第二次 idx = min(idx, last_loc-i)
(2) 利用idx儲存字元==c的index，利用two pointer method去找左右兩個
    為c的idx和當前的比誰比較小。

///////////////////////////////////////////////////////////////
//
// lc823. Binary Trees With Factors (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dp，先將數組排序後，dp[A[i]] = (dp[A[i]] + dp[A[j]]*dp[A[i]/A[j]]) % M

///////////////////////////////////////////////////////////////
//
// lc824. Goat Latin
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用istringstream做處理。

///////////////////////////////////////////////////////////////
//
// lc828. Count Unique Characters of All Substrings of a Given String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp
https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/129021/O(N)-Java-Solution-DP-Clear-and-easy-to-Understand

///////////////////////////////////////////////////////////////
//
// lc830. Positions of Large Groups
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) check if s[i] != s[i-1] && i-last >= 3。

///////////////////////////////////////////////////////////////
//
// lc832. Flipping an Image
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每一列對調，然好跑一遍迴圈用xor把矩陣顛倒。
(2) 建一個新矩陣，對於每一列，用原矩陣從後面往前一一pushback到新矩陣的列中並xor。

///////////////////////////////////////////////////////////////
//
// lc835. Image Overlap
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n^2) time, O(n^2) space

///////////////////////////////////////////////////////////////
//
// lc836. Rectangle Overlap
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc729, lc731。
    將其轉成2d而已

///////////////////////////////////////////////////////////////
//
// lc838. Push Dominoes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) in place solution，只要注意last是R的case就好。
(2) 
    midlen = right-left-1;
    若d[left] == d[right]，中間都填上d[left];
    若d[left] == 'L' && d[right] == 'R'，中間都填上'.'
    若d[left] == 'R' && d[right] == 'L'，
    中間填上string(midlen/2, 'R') + string(midlen%2, '.') + string(midlen/2, 'L')。

///////////////////////////////////////////////////////////////
//
// lc840. Magic Squares In Grid
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 暴力解，注意magic square只能有1~9，且不能重複。
(2) 找規律，中間只能是5且四個corner是偶數，保持一個pattern："43816729"或
    其reverse。

///////////////////////////////////////////////////////////////
//
// lc841. Keys and Rooms
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) bfs走一遍，每走一個n--，結束後若n != 0 則return false。
(2) dfs，類似bfs，也是要利用一vector紀錄有沒有拜訪過。

///////////////////////////////////////////////////////////////
//
// lc844. Backspace String Compare (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，從尾巴開始，利用一變數來決定還要不要往前走。
(2) O(n) space，stack

///////////////////////////////////////////////////////////////
//
// lc845. Longest Mountain in Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) two pointer one pass, O(n) time, O(1) space
    use dir to specify we are ascending or descending in the mountian.

    dir = -1 : initial status
    dir = 0: uphill
    dir = 1: downhill
(2) no dir using，skip left to start uphill
    use right to uphill and downhill。

///////////////////////////////////////////////////////////////
//
// lc848. Shifting Letters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從右至左跑一遍累加次數，並且shift字母。

///////////////////////////////////////////////////////////////
//
// lc849. Maximize Distance to Closest Person (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要找出0距離1最遠的方法是，對於兩個1之間取中間值就可，但頭尾的話若是0
    不用找中間值，因為另外一邊是邊界。

///////////////////////////////////////////////////////////////
//
// lc852. Peak Index in a Mountain Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search

///////////////////////////////////////////////////////////////
//
// lc856. Score of Parentheses (看) 第一種解法。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space：
    遇到右括號，且上一個是左括號的，計算當前是幾層，就res += 1 << l (l為層數)。
    因為兩個括號一起在一個括號，他們兩個都可以各自當成在一個括號再相加。
    像乘法分配律 2*(a+b) = 2*a + 2*b。

(2) O(n) space：
    用stack，當前為')'
        遇到top是分數，累加直到top是'('。
        遇到top是'('，放入1。

///////////////////////////////////////////////////////////////
//
// lc860. Lemonade Change
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 保持五元和十元的數量去做追蹤，若數量不夠就return false。

///////////////////////////////////////////////////////////////
//
// lc861. Score After Flipping Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy approach，首先首位一定是要1，因為對於二進治：1000>0111。
    如此一來每列接翻轉完畢，再來翻轉每行(第一行不翻，因為已透過每列翻成1)，
    可以觀察到，不管本來是0還是1，只要和該列的頭(也就是首位)一樣的，必是翻完列後同樣的。
    因此可透過此方法來計算翻完列後都一樣的作為1，比較和0的個數誰比較多，作為翻轉的依據。

///////////////////////////////////////////////////////////////
//
// lc862. Shortest Subarray with Sum at Least K (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用prefix sum和deque，
    若A[right] - A[que.front()] >= K，表示這可能是最短，需要pop_front。
    若A[right] - A[que.front()] <= 0，表示這段是負的，對於後面算>=k沒有幫助，需要pop_back
    space: O(n)，time：O(n)。

///////////////////////////////////////////////////////////////
//
// lc863. All Nodes Distance K in Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為tree其實也是graph一種，先用一遍dfs(preorder)將tree的連接情況記錄起來，
    也就是轉成graph，再用bfs，從target開始層層算出k距離的所有點。

///////////////////////////////////////////////////////////////
//
// lc864. Shortest Path to Get All Keys (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，判斷這個點有沒有走過，看我當前的鑰匙種類，如6把key，
    111111，若這點為000001，表示這個點有'a' key，不能用數量去記錄，要用種類的原因是
    鑰匙是unique。用unordered_set紀錄 posx_posy_keytag。

///////////////////////////////////////////////////////////////
//
// lc865. Smallest Subtree with all the Deepest Nodes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於找到一個node其subtree可以包涵所以deepest node，其實就是類似找祖先的概念，
    利用postorder，並且維持左子樹和右子樹深度，當兩深度相同，return 當前node，
    不然就return 左子樹的node或是 右子數的node。

///////////////////////////////////////////////////////////////
//
// lc867. Transpose Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) res[j][i] = A[i][j]。

///////////////////////////////////////////////////////////////
//
// lc872. Leaf-Similar Trees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder，遇到leaf就push到stinrg中，最後比較兩個string有沒有一樣。

///////////////////////////////////////////////////////////////
//
// lc874. Walking Robot Simulation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用set來儲存obstacle。

///////////////////////////////////////////////////////////////
//
// lc875. Koko Eating Bananas
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，類似lc1283。

///////////////////////////////////////////////////////////////
//
// lc876. Middle of the Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本快慢指針問題。

///////////////////////////////////////////////////////////////
//
// lc880. Decoded String at Index (看*)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) stack，維持當前total len表示stack總長+now size。
    k = k%len;
    若k < tlen-now.size()，表示k在stack裡其中一個位置
    tlen = (tlen-now.size())/sk.back().second
    now = sk.back().first。
(2) O(1) space
    維持N表示總長度，一旦k == N停止。
    從i往回跑，若遇到數字，
        N /= digit
        k %= N;
    else 
        if (k == N || k == 0)
            return s[i]
        否則
            --N;

///////////////////////////////////////////////////////////////
//
// lc881. Boats to Save People (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) double pointer，先排序，若當前left+right <= limit，表示可配對，
    left++, --right，若不行，表示right一人坐船，left不用+1，left不能跟right做。

///////////////////////////////////////////////////////////////
//
// lc884. Uncommon Words from Two Sentences
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) map find word appearing once

///////////////////////////////////////////////////////////////
//
// lc885. Spiral Matrix III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc054，遍歷的點在範圍內再放入output中。

///////////////////////////////////////////////////////////////
//
// lc886. Possible Bipartition
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc785，bfs with coloring 0 or 1，inital is -1。

///////////////////////////////////////////////////////////////
//
// lc888. Fair Candy Swap
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 算出兩者之前的diff，(sumb-suma)/2，
    因為一定存在一個互換使得兩邊總和相同。
    a[i]+diff = x，x若在b中表示，是一個互換pair。

///////////////////////////////////////////////////////////////
//
// lc890. Find and Replace Pattern
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立兩個vector，一個映射過去，另一個inverse。當遇到第一個設過去的，也設定inverse。
    下次遇到已經設定過映射的，檢查inverse有沒有對到自己。
    未設定的，映射過去，若inverse已經有值，表示也錯誤。

///////////////////////////////////////////////////////////////
//
// lc892. Surface Area of 3D Shapes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於兩邊相鄰的，只做往右看和往下看，
    並且-2*min(grid[i][j], grid[i+1][j])，
       -2*min(grid[i][j], grid[i][j+1])。
    扣掉兩倍這樣到下個點就不用往左和上面扣了。

///////////////////////////////////////////////////////////////
//
// lc893. Groups of Special-Equivalent Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對每一個string根據index去sort然後用set找出group的數量。

///////////////////////////////////////////////////////////////
//
// lc889. Construct Binary Tree from Preorder and Postorder Traversal (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

O(n)
(1) dfs，利用pre_idx，post_idx，利用pre[pre_idx]搭建tree，
    判斷若root->val != post[post_idx] 則繼續搭建tree。
(2) stack iteration，
    利用pre vector做搭建，維持一個stack，
    若sk.back()->val == post[pos]，則pos++, s.pop_back()，
    若s.back()->left == null，now接左邊，不然now接右邊。
    s.push_back(now)。

///////////////////////////////////////////////////////////////
//
// lc894. All Possible Full Binary Trees (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc095，但因為左右對稱，所以只須要算左半邊的左右子樹(跑一半迴圈)，右半邊直接互換就好。
    中間點不互換，避免重複。
    另外，因為是binary tree，所以當前點數必為奇數點，選完點左右也要必是奇數，
    解法：跑回圈從奇數開始為i = i+2，這樣可以避掉左右為偶數點的情況。

///////////////////////////////////////////////////////////////
//
// lc896. Monotonic Array
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 計算出現次數，若兩者都大於0，return false。
(2) 計算bool of 上升或下降，若兩個都0，代表都不符合上升或下降，return false。

///////////////////////////////////////////////////////////////
//
// lc897. Increasing Order Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc094。
(1) inorder stack iteration，用dummy當作輔助使用。
(2) inorder recursion，利用double link list，因為在function中會改動其值，
    所以不能使用單*，要用雙＊。

///////////////////////////////////////////////////////////////
//
// lc901. Online Stock Span
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1019，維持一個降序stack。
    利用stack紀錄當前price和其持續天數，當進來的price比sk.top的price還大時(>=)，
    sk.pop，並將top的天數加到當前price上，最後將當前price和其天數push進sk。

///////////////////////////////////////////////////////////////
//
// lc904. Fruit Into Baskets (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找連續兩個不一樣，最長subarray，
    若目前長度為 a a a a b b b b b
    若
    (1) c == b -> ++cur, a = b, b = c, cnt_b++
    (2) c == a -> ++cur, a = b, b = c, cnt_b = 1
    (3) c!=a && c!=b -> cur = cnt_b + 1, a = b, b = c, cnt_b = 1

    time：O(n)，space：O(1)。
(2) sliding window，longest subarry with at most 2 distinct ingeger
    time：O(n)，space：O(n)。

///////////////////////////////////////////////////////////////
//
// lc905. Sort Array By Parity
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似quick select中partition用到的方法。

///////////////////////////////////////////////////////////////
//
// lc907. Sum of Subarray Minimums (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dp[i]，表示以i為結尾的最小總和，
    -   那如果A[i] >= A[i-1]，表示dp[i] = dp[i-1] + A[i]，因為當前比上一個大，
        以當前結尾就算去往前找，結果都是和以上一個結尾去找的總合一樣。
    -   反之，找到第一個A[i] >= A[idx]，dp[i] = dp[idx] + (i-idx) * A[i]。
    這可以用stack去做，因為每次都往前找，若給定降序input，每次都要找到頭，很浪費時間。
    所以用stack維持一個升序序列，若當前比top小就pop。
    類似lc977，lc1019，lc1130，lc654，1043。

///////////////////////////////////////////////////////////////
//
// lc908. Smallest Range I
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 只要看最大和最小值即可，若兩者差距<=k，表示這其中都可以移動到同一個點。
    反之，retunr maxv-minv-2*k。

///////////////////////////////////////////////////////////////
//
// lc909. Snakes and Ladders (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) 跑一遍紀錄index以及board關係。
(2) 跑一遍將2d array轉乘id array。
(3) real time轉，r = row-1-(now/row)，注意c判斷當前是順向還是逆向
    c = col-c-1 if r%2 != (row-1)%2。
    注意遇到不是-1的一定要跳，但是跳完的那個點不用記錄到visit，不然之後的如果
    有人走到就不能再跳一次(如果這個點也可以跳)，因為visit過。

///////////////////////////////////////////////////////////////
//
// lc912. Sort an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) merge sort
(2) quick sort
(3) selection sort
(4) insertion sort
(5) bubble sort

///////////////////////////////////////////////////////////////
//
// lc914. X of a Kind in a Deck of Cards
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find greatest divisor，如果最大公因數是1，表示只能分成group size是
    1的group。

///////////////////////////////////////////////////////////////
//
// lc915. Partition Array into Disjoint Intervals (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個local max表示到partition i的最大值，若localmax > A[i]，
    表示必須extend left 到包含index i，並更新local max到i的最大值，
    因此必須再額外維持一個global maxv。
(2) O(n) space，維持一個minv[i] 表示從n-1到i為止的最小值。
    if (maxv <= minv[i+1]) return i+1

///////////////////////////////////////////////////////////////
//
// lc917. Reverse Only Letters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用頭尾兩指針i, j，判斷若非字母則跳過，若兩者都是字母則交換，迴圈終止條件為
    i >= j。

///////////////////////////////////////////////////////////////
//
// lc919. Complete Binary Tree Inserter
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs維持一個queue，找到第一個沒孩子的head來做return以及插入孩子，
    注意：整個queue都是有一個或是沒有孩子的node，若頭為有兩個孩子，pop。
(2) 建heap，利用index找到沒有完整孩子的node。 (heap.size()/2)。

///////////////////////////////////////////////////////////////
//
// lc921. Minimum Add to Make Parentheses Valid
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 基本stack操作。
(2) 可不用stack，用left就可以。

///////////////////////////////////////////////////////////////
//
// lc922. Sort Array By Parity II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用double pointer，先找到第一個偶數位置是奇數和奇數位置是偶數的點，
    做swap。

///////////////////////////////////////////////////////////////
//
// lc924. Minimize Malware Spread (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find，注意若一個group裡只有一個感染，則找出最大的感然群的最小id，
    若沒有group只有一個原始感染，則找最小的id就好。

///////////////////////////////////////////////////////////////
//
// lc925. Long Pressed Name
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc809。
    利用double pointer去計算當前位置有沒有相同，若沒有，判斷typed當前
    和上一個有沒有相同，若沒有，return false。
    若name有走完表示true。

///////////////////////////////////////////////////////////////
//
// lc926. Flip String to Monotone Increasing (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當前方法數最小有兩種可能
    若當前n[idx] == 0
    (a) 前n-1位已經合法單調，那麼當前變1。 ->res+1
    (b) 到第n位有1的都變0。 -> res = min(res, ones)

///////////////////////////////////////////////////////////////
//
// lc930. Binary Subarrays With Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1248 method 2，one pass，O(n) time，O(1) space。

///////////////////////////////////////////////////////////////
//
// lc931. Minimum Falling Path Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前路徑往上一層找前後一個的最小值。
    O(n) space。

///////////////////////////////////////////////////////////////
//
// lc933. Number of Recent Calls
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) queue。
(2) arr loop。

///////////////////////////////////////////////////////////////
//
// lc934. Shortest Bridge (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs將島嶼標記，用bfs找到最短距離。

///////////////////////////////////////////////////////////////
//
// lc937. Reorder Data in Log Files
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對letter排序digit不用。

///////////////////////////////////////////////////////////////
//
// lc938. Range Sum of BST (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用preorder，
    對於往左孩子走，如果root->val > R，
    就可以往左走，root->val < L，代表可往右孩子走。
    若當前在區間內，sum += root->val，兩邊都可以走。

///////////////////////////////////////////////////////////////
//
// lc939. Minimum Area Rectangle (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 暴力解，對當前點(x1,y1)，找看過的點(x2,y2)，若(x1,y2)和(x2,y1)都看過
    update area。
    O(n^2)
(2) O(nx*ny*ny) < O(n^1.5)
    if (nx == ny) -> O(nx*ny*ny) = O(n^1.5)
    First, note that, in the 3-level loop, its complexity is o(nx * ny * ny). 
    We make the size of outmost loop, ie, nx, the largest, and in this way we 
    save much computation. However, when nx = ny, we do not save computation. 
    Thus, the worst case is nx = ny. The typical example is the N points form 
    a regular grid, where nx = ny = sqrt (N)
    (a) 對於每一個x，從小到大，若有一對y1, y2，且y1和y2上次被用過的是lastx
        -> res = min(res, (x - lastx) * (y1- y2))。

///////////////////////////////////////////////////////////////
//
// lc941. Valid Mountain Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 順著找就可以。

///////////////////////////////////////////////////////////////
//
// lc944. Delete Columns to Make Sorted
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) brute force去找就好。

///////////////////////////////////////////////////////////////
//
// lc946. Validate Stack Sequences (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space
    modify pushed array，two pointer。
    return j == popped.size()
(2) O(n) space，一般stack解法。

///////////////////////////////////////////////////////////////
//
// lc947. Most Stones Removed with Same Row or Column (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

這題是在講，對於連通的點可以移除的點數，可以用dfs或是union find，核心在於
同個島嶼移除的點數為這個島嶼的點數-1，所以總共的移除點數就是總共的點數-總共的島嶼數。
又或者每個島嶼在移除後都會剩下一個，所以若一個島嶼只有一個點，這個島嶼不能移除。
題目中的最大move數量，指的是，至個點旁邊有row或col相同的點，這個點可以move 
(也就是remove 這個點)。

(1) union find
(2) dfs

///////////////////////////////////////////////////////////////
//
// lc950. Reveal Cards In Increasing Order (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: nlogn
    利用deque，先將arr sort，再返著build return process。
    因為pusg當前的到res，會將next放到尾巴，所以對於reversed process，
    我們可以將尾巴放到當前的next。

    簡言之，push當前，next放到尾巴 -> 尾巴放到頭，push到頭。

///////////////////////////////////////////////////////////////
//
// lc951. Flip Equivalent Binary Trees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先判斷當前兩個node有沒有一樣，
    再return 左孩子左孩子 && 右孩子右孩子 || 左孩子右孩子 && 右孩子左孩子。

///////////////////////////////////////////////////////////////
//
// lc953. Verifying an Alien Dictionary
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 紀錄順序，兩兩比較，若a > b則return false。

///////////////////////////////////////////////////////////////
//
// lc957. Prison Cells After N Days (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個cycle，若當前res出現過， N = (N - 1) % (cycles-1);

///////////////////////////////////////////////////////////////
//
// lc958. Check Completeness of a Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，complete biniry tree特性為用bfs走訪一定全走非null node，遇到null
    node後，後面一定都是null，利用這特性可以跑第一遍while將node全push到queue直到遇到
    queue中第一個非null，再用另一個while繼續走queue直到遇到第一個非null node或走完queue。
    return index == que.size()。

///////////////////////////////////////////////////////////////
//
// lc959. Regions Cut By Slashes (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2。

(1) 利用union find，將每一個grid劃分成四小等份，上右下左依序為0,1,2,3。
    那麼其實就是對於這些小分塊做union find。
    要注意的是，相鄰的grid預設就要union，因為slash無法分割這些。
    若當前grid[i][j] != '/'，表示0 and 1要union，2 and 3要union。
    若當前grid[i][j] != '\'，表示0 and 3要union，1 and 2要union。
    count數量就是n*n*4。
(2) dfs，將grid分成3*3小塊，然後slash改成1其餘為0，這樣就是
    number of islands。

///////////////////////////////////////////////////////////////
//
// lc961. N-Repeated Element in Size 2N Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為一個陣列有一半都同樣，nums[i]必等於nums[i-1] or nums[i-2]。
    如果沒有只有一個情況
    1, 2, 3, 1。

///////////////////////////////////////////////////////////////
//
// lc965. Univalued Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，preorder。

///////////////////////////////////////////////////////////////
//
// lc969. Pancake Sorting
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到剩餘長度最大的(index: i)，翻到頭，再翻到剩餘長度的位置(index: n)。
    reverse(begin ~ i) then reverse(begin ~ n); --n;

///////////////////////////////////////////////////////////////
//
// lc971. Flip Binary Tree To Match Preorder Traversal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若當前node不等於voyage的對應點，return {-1}，若左孩子的val != voyage[now+1]，
    swap(root->left, root->right)。

///////////////////////////////////////////////////////////////
//
// lc973. K Closest Points to Origin (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) quick select，不好懂。 類似215。
(2) priority queue。

///////////////////////////////////////////////////////////////
//
// lc974. Subarray Sums Divisible by K (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc560類似。要注意餘數為負數的時候再加上K，prefix sum。
(2) 先算好所有的出現相同餘數的次數，再一次跑一個迴圈算好。
    ex: 若該餘數出現4次，則符合題目的次數為1+2+3。

///////////////////////////////////////////////////////////////
//
// lc976. Largest Perimeter Triangle (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大邊長，sort後從後面開始
    只檢查a[i-2] + a[i-1] 有沒有 > a[i]，因為若沒有，以a[i]為檢查點的
    後面i=0~i-3任兩點組合也不會>a[i]。

///////////////////////////////////////////////////////////////
//
// lc977. Squares of a Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 雙指針(頭尾)取絕對值大的填入res的尾端。
(2) stack，類似lc1019，維持一個降序陣列。

///////////////////////////////////////////////////////////////
//
// lc978. Longest Turbulent Subarray (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) > ： sign = 1， < ： sign = -1
    對於當前>或<，紀錄上次是相反結果(sign)的話cnt++，反之就重新初始化狀態(cnt = 2)。
    注意若當前=上一個，初始化sign = -1, cnt = 1。

///////////////////////////////////////////////////////////////
//
// lc979. Distribute Coins in Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，紀錄當前硬幣總數，此硬幣總數代表要往父節點移動的個數。

///////////////////////////////////////////////////////////////
//
// lc980. Unique Paths III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先計算要走的數量， 然後用一般的dfs即可。

///////////////////////////////////////////////////////////////
//
// lc981. Time Based Key-Value Store (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2，3。

類似lc1146。

(1) unordered_map<string, map<int, string>> map
    set: O(log(n))
    get: O(log(n))

(2) unordered_map<string, vector<pair<int, string>>> map;
    因為時間為遞增，可以使用vector pair，upper bound 也為log(n)
    set: O(1)
    get: O(log(n))

(3) 類似(2)，但implement upper_bound by binary search。

///////////////////////////////////////////////////////////////
//
// lc983. Minimum Cost For Tickets (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 跑365天循環，對當前天數，選擇最小付費方式。
    若不是搭車日期(初始化=INT_MAX)，照理說不花費，所以dp[i] = dp[i-1]。
    若是搭車日期(初始化=0)，找出最小付費方式。

///////////////////////////////////////////////////////////////
//
// lc985. Sum of Even Numbers After Queries (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持even sum，若query的index a[idx] is even，先扣掉
    even -= a[idx]
    update a[idx] = a[idx] + val
    再次檢查a[idx]是不是even，是的話，加回even。
    O(n):
    n here is the size of A. Based on the problem description, 
    it dominates the size of queries (0 <= queries[i][1] < A.length). 
    So, worst case scenario, we need 3 * n operations, which is O(n).

///////////////////////////////////////////////////////////////
//
// lc986. Interval List Intersections (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先判對兩個list有沒有交集，若沒有則換下一個，
    若有交集，頭取max(a.start, b.start)，
             尾取min(a.end, b.end)。
    類似lc56。

///////////////////////////////////////////////////////////////
//
// lc987. Vertical Order Traversal of a Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為相同的x y 需要排序，同一個x不同y，則y由小到大填入，因此map作為資料結構。
    map<int, map<int, set<int>>> info來記錄-> info[x][y].insert(node->val)。
    (a) dfs
    (b) bfs

///////////////////////////////////////////////////////////////
//
// lc988. Smallest String Starting From Leaf (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 錯誤想法：postorder去隨時找到最小字串。
    這題是對於所有string從leaf到root找最小字串，所以每次比較都必須是leaf到root
    的字串，這樣就必須用preorder(dfs)而非postorder。
    類似lc1026。

///////////////////////////////////////////////////////////////
//
// lc989. Add to Array-Form of Integer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後面往前走，一位一位的加。

///////////////////////////////////////////////////////////////
//
// lc991. Broken Calculator
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 如果 x >= y，res += x-y，
    但x < y，最快的方法就是讓y <= x，

    為什麼優先除： 假設(y+2n) / 2 = x
    若我們先+2n times then / 2， # of operations: 2n+1
    若我們先除：y/2 + n = x， # of operations: n+1
    所以永遠先除以2都是對的，會造成最小的結果。

    We do Y/2 all the way until it's smaller than X,
    time complexity is O(log(Y/X)).

///////////////////////////////////////////////////////////////
//
// lc992. Subarrays with K Different Integers (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 類似lc1004，lc1052，lc340。
    利用sliding window，紀錄所有子字串使用的integeres with different
    integers <= k。
    at most k - at most k-1。
    two pass
(2) one pass
    維持一個unique integer size = k 的window，且一變數prefix，表示
    在left之前有多少重複的number，res += prefix+1。且left為cnt[left] == 1，
    固定起始點的出現次數為1。所以left為unique interger subarray and 
    cnt[left] = 1。若 k < 0 => prefix = 0。要重新計算有多少prefix array。
    ex 1 1 1 2 2 2 3 3 3
       0 1 2 3 4 5 6 7 8
       k = 3
       left = 3, right = 9, prefix = 2，表示有除了當前subarry還有兩個prefix
       array，res += prefix+1 = 3。
       right = 6
       1 1 1 2 2 2 3
         1 1 2 2 2 3
           1 2 2 2 3

       right = 7
       1 1 1 2 2 2 3 3
         1 1 2 2 2 3 3
           1 2 2 2 3 3

       right = 8
       1 1 1 2 2 2 3 3 3
         1 1 2 2 2 3 3 3
           1 2 2 2 3 3 3

///////////////////////////////////////////////////////////////
//
// lc993. Cousins in Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs，隨時記錄當前node的parent和當前node高度，當遇到node->val等於x或是
    y，紀錄其高度，return true if parent不一樣且高度相同，否則false。
(2) bfs做法也是一樣。

///////////////////////////////////////////////////////////////
//
// lc994. Rotting Oranges (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，每清掉一層queue，++res，像洋蔥是剝皮。
    while (qsize) {
        for (int i = 0; i < qsize; ++i) {

        }
        days++;
    }

///////////////////////////////////////////////////////////////
//
// lc997. Find the Town Judge
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到一個點其in_degree - out_degree = N-1。

///////////////////////////////////////////////////////////////
//
// lc998. Maximum Binary Tree II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律。
    if (root->val < val)
        new TreeNode(val)->left = root;
    else
        root->right = func(root->right, val);

///////////////////////////////////////////////////////////////
//
// lc999. Available Captures for Rook
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到root，往四邊走。

///////////////////////////////////////////////////////////////
//
// lc1002. Find Common Characters (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用cnt(26)，每次和當前的比較，取最小值。

///////////////////////////////////////////////////////////////
//
// lc1003. Check If Word Is Valid After Substitutions (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用stack去解，遇到c時檢查當前最上面兩個是不是a和b，不是就return false。

///////////////////////////////////////////////////////////////
//
// lc1004. Max Consecutive Ones III (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 使用sliding window，右邊界一直往右，遇到0，k--，若k<0，移動左邊界，
    移動左邊界中遇到0，++k(每個iteration只移動一次，為的是right增長一次，left也要增長一次
    ，因為k<0，必需停止array大小增大)，直到k>=0，就不移動左邊界，
    此方法保持左右邊界維持合法吧0數量。

///////////////////////////////////////////////////////////////
//
// lc1005. Maximize Sum Of Array After K Negations (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用quick select將前k小的找出來，然後遍歷一次對於負數且在k次的取正號，
    若k有剩餘則代表都是正號，找到最小的，取負數。

///////////////////////////////////////////////////////////////
//
// lc1007. Minimum Domino Rotations For Equal Row (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於a[0]和b[0]，作為top和down，對top和down分別計算他們在a和b的
    出現次數，若有一個導致a[i]&b[i]都不等於top，top = 0，down也是，
    若top&down == 0，直接return -1。
    跑完loop去找top和down出現次數的最小值。

///////////////////////////////////////////////////////////////
//
// lc1008. Construct Binary Search Tree from Preorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

類似lc108。
(1) stack iteration：
    當前比stack的top小就丟入stack，且stack.top->left = 當前。
    當比stakc的top大，找到最後一個比top大的元素，將這元素->right = 當前。
(2) dfs recursion：
    跑n次迴圈，每次將一個node塞到tree中適當的位置(用遞迴)。

///////////////////////////////////////////////////////////////
//
// lc1010. Pairs of Songs With Total Durations Divisible by 60
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use map(60, 0) to store all possible time[i] % 60,
    res += map[now], with now = (60 - time[i]%60) % 60
    like prefix sum。

///////////////////////////////////////////////////////////////
//
// lc1011. Capacity To Ship Packages Within D Days
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc410，binary search找到最適合的大小。

///////////////////////////////////////////////////////////////
//
// lc1013. Partition Array Into Three Parts With Equal Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 算出sum/3，count 次數，必須>=3。比3大是因為有可能sum == 0。

///////////////////////////////////////////////////////////////
//
// lc1018. Binary Prefix Divisible By 5
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) mod 5 at every step

///////////////////////////////////////////////////////////////
//
// lc1019. Next Greater Node In Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將本來的stack array做成 pair<ListNode *, int>來表示 the relation 
    between list node and index in the res array。

(2) 類似lc503，但是因為只要找一輪，從尾巴往頭看，每次push當前val進入stack，
    找當前下一個大的，對stack找到第一個比當前大的就好(其他pop)，
    其他pop掉沒差，因為比當前小，代表往頭看當前絕對比其他val還要有可能是下一個大的。

///////////////////////////////////////////////////////////////
//
// lc1020. Number of Enclaves
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs把觸碰到boundary的1都改成0，接下來計算剩下的1的數量。

///////////////////////////////////////////////////////////////
//
// lc1021. Remove Outermost Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為最外邊的括號會和前後兩個primitive compotnent相連，用cnt計算括號，
    若不等於0則放入res。

///////////////////////////////////////////////////////////////
//
// lc1022. Sum of Root To Leaf Binary Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1025. Divisor Game
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs recursive
(2) 找規律

///////////////////////////////////////////////////////////////
//
// lc1026. Maximum Difference Between Node and Ancestor (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用preorder (dfs)，來對整條由上往下的路徑找最大最小，藉此找到max diff。
    錯誤想法：由下往上無法確定從單一leaf到root的分別最大最小，因為這樣找會變成整個tree的最大最小，
    這樣的最大最小不一定在同一路徑上，也就不存在祖孫後代的關係。

///////////////////////////////////////////////////////////////
//
// lc1028. Recover a Tree From Preorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用stack size來判斷，
    若當前size == 要插入深度，back->left = now，
    反之，pop_back直到size == 拆入深度，back->right = now。

///////////////////////////////////////////////////////////////
//
// lc1029. Two City Scheduling (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為有n人去a城市，有n人去b城市，對差值做排序，越大的越前面，表示前半部去b城市，
    後半部去a城市。

///////////////////////////////////////////////////////////////
//
// lc1030. Matrix Cells in Distance Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs。

///////////////////////////////////////////////////////////////
//
// lc1031. Maximum Sum of Two Non-Overlapping Subarrays (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window
    lmax: max value of window l before m window
    mmax: max value of window m before l window
    max(lmax + A[i]-A[i-M], mmax + A[i]-A[i-L])
    time: O(n)，space: O(1)
(2) 計算視窗大小，由尾巴往前，算idx以後最大的視窗和，再跑一個從頭開始另一個
    視窗 res = max(res, windwow + other_sum[i+1])
    做兩遍
    time and space: O(n)

///////////////////////////////////////////////////////////////
//
// lc1034. Coloring A Border (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將tagcolor全標-tagcolor，當前點跑完四個方向dfs後，若上下左右取abs後都是
    tagcolor，表示是component內部點，改為tarcolor。

///////////////////////////////////////////////////////////////
//
// lc1035. Uncrossed Lines (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp解，
    表示為dp[i][j]，
    若當前A[i] == B[j]，dp[i][j] = dp[i-1][j-1] + 1。
    否則，dp[i][j] = max(dp[i][j-1], dp[i-1][j])。
    *** 可優化為空間O(n)。

///////////////////////////////////////////////////////////////
//
// lc1037. Valid Boomerang (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算斜率，注意因為分母可能0，所以將兩個斜率的比較式變形。
    ya/xa == yb/xb is equal to ya*xb == yb*xa。

///////////////////////////////////////////////////////////////
//
// lc1038. Binary Search Tree to Greater Sum Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) inorder

///////////////////////////////////////////////////////////////
//
// lc1041. Robot Bounded In Circle (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 能在園內有兩個條件
    a. sequence回到原點
    b. 結束sequence 不是面向北方，這代表每次都會改方向，最後一定會回到原點。

///////////////////////////////////////////////////////////////
//
// lc1043. Partition Array for Maximum Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 區間內最多k個，用dp解。
    j = i ~ i-k+1
    dp[i] = max(dp[i], dp[j-1] + (i-j+1)*區間最大的A val)
    類似lc907。

///////////////////////////////////////////////////////////////
//
// lc1046. Last Stone Weight
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) nlogn sort。
(2) priority queue。 (較好)

///////////////////////////////////////////////////////////////
//
// lc1047. Remove All Adjacent Duplicates In String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc394，lc856，利用stack去做消掉括號的動作。
(2) 每次找到兩個一樣的用erase消除，且idx歸於0，但很慢。

///////////////////////////////////////////////////////////////
//
// lc1048. Longest String Chain (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp iteration。
    先將vector排序，
    對每一個word去做 last_str = word.substr(0,j) + word.substr(j+1)
    類似lc 301
    dp[cur_str] = max(dp[cur_str], dp[last_str]+1)

///////////////////////////////////////////////////////////////
//
// lc1049. Last Stone Weight II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc416，lc494。
    對於x!=y取diff，x==y抵銷，可以想像成數字分成兩堆，若一樣就是0，若不一樣取diff。
    這也就把題目轉換成0/1 Knapsacks problem。
    可用bitset，因為bitset是用來判斷那位有沒有。

///////////////////////////////////////////////////////////////
//
// lc1051. Height Checker
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1052. Grumpy Bookstore Owner
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window，往右遇到1加上，window size-1 是1扣掉。

///////////////////////////////////////////////////////////////
//
// lc1057. Campus Bikes (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，將所有配對可能通過bucket做排序，且worker從低idx到高idx，
    bikes也是從低idx到高idx，這樣的話，對同一個slot，先選低worker id，
    若worker id相同，一定低bike id先選。

///////////////////////////////////////////////////////////////
//
// lc1059. All Paths from Source Lead to Destination
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc802。
(1) dfs recursion，遇到dest檢查是終點(dst沒有指向其他點)，遇到visit[i]
    若visit[i] != -1表示之前走過，直接return。
    也可用visit表示當前路徑下走過的點，若遇到代表有環，return false。

///////////////////////////////////////////////////////////////
//
// lc1060. Missing Element in Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search
    func(idx)表示到idx為止missing number的個數。
    注意邊界問題，if k > func(arr.size()-1)，
    return arr[left] + k-func(left)
    otherwise
    return arr[left-1] + k-func(left-1)

///////////////////////////////////////////////////////////////
//
// lc1061. Lexicographically Smallest Equivalent String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

都是用union find
(1) 當ap != bp，因為要找同一group最小的，我們可以在接parent時，將大的往小的接，
    這樣保證root of union一定是最小。
(2) 用set來把同一個union的收集起來。

///////////////////////////////////////////////////////////////
//
// lc1063. Number of Valid Subarrays (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個升序stack，對於每一個element在stack里表示，到目前為止以這個
    element為起始點到當前num還是合法的subarray。
    res += sk.size() for each num in nums
    time: O(n), space: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1064. Fixed Point
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本binary search。

///////////////////////////////////////////////////////////////
//
// lc1065. Index Pairs of a String
//
///////////////////////////////////////////////////////////////

最佳解： method 2

k = # of words, m = len of text, n = avg len of a word
(1) brute force
    time: O(kmn)
(2) trie tree
    time: O(kn+m^2)

///////////////////////////////////////////////////////////////
//
// lc1071. Greatest Common Divisor of Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用輾轉相除去算即可，因為這裡整除代表str1的首str2.size()一定要是str2，
    若不是，即無法相除，return ""。

///////////////////////////////////////////////////////////////
//
// lc1072. Flip Columns For Maximum Number of Equal Rows (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找flip後最多一樣是0 or 1的個數，所以紀錄每個row出現的次數，次數越多
    表示對這些次數多得column flip，得到的結果一定是最大數量的 0 or 1 rows。

///////////////////////////////////////////////////////////////
//
// lc1079. Letter Tile Possibilities (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc047。
    dfs，檢查當前若和上一個一樣且上一個也是未visit，當前跳過。
        要未visit的才跳過是因為未visit表示屬於同層，visit表示上一層處理過。
        比較有沒有重複都是要同層的。
    若字符不是排序過後 如"ABA"，則用(1-2)

///////////////////////////////////////////////////////////////
//
// lc1080. Insufficient Nodes in Root to Leaf Paths
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) (a) Go to leaf to check if limit > 0.
    (b) for every internal node, if return child is both NULL, 
        it means that this node is insufficient node. So we return NULL.

///////////////////////////////////////////////////////////////
//
// lc1081. Smallest Subsequence of Distinct Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc316相同。

///////////////////////////////////////////////////////////////
//
// lc1085. Sum of Digits in the Minimum Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到最小值。

///////////////////////////////////////////////////////////////
//
// lc1086. High Five (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) counting sort
(2) partial sort

///////////////////////////////////////////////////////////////
//
// lc1087. Brace Expansion
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本permutaion的dfs

///////////////////////////////////////////////////////////////
//
// lc1089. Duplicate Zeros (看)* 第一種方法
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先計算額外空間 = 0的數量，再來用一指針j從尾巴開始，另一個指針從原arr尾巴
    開始，若--j < n才assign當前值 -> a[j] = a[i] (往後位移一個)，
    且若arr[i] = 0，且--j < n，assign a[j] = 0。
(2) 對於重複的插入0，並pop_back。

///////////////////////////////////////////////////////////////
//
// lc1090. Largest Values From Labels
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) priority queue

///////////////////////////////////////////////////////////////
//
// lc1091. Shortest Path in Binary Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1094. Car Pooling
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc731，lc253。
    利用一array紀錄人數，注意在結束的時候要扣掉人數。
    cnt[trip[i][1]] += trip[i][0];
    cnt[trip[i][2]] -= trip[i][0];
    traverse array累加capacity，若大於limit，return false。

///////////////////////////////////////////////////////////////
//
// lc1095. Find in Mountain Array (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用binary search先找到peak index，再來對兩邊的的arr分別做一次
    binary search。

///////////////////////////////////////////////////////////////
//
// lc1099. Two Sum Less Than K
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort then two pointers。

///////////////////////////////////////////////////////////////
//
// lc1100. Find K-Length Substrings With No Repeated Characters (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window，看clean code。

///////////////////////////////////////////////////////////////
//
// lc1101. The Earliest Moment When Everyone Become Friends (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find with path compression and union by size.
    先sort，一旦size == N，return time。
    union by size：只有union head的parent指向union size。
    這樣可以不用額外創一個空間儲存每一個union的size。

///////////////////////////////////////////////////////////////
//
// lc1102. Path With Maximum Minimum Value (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用Dijkstra找maximun path from source，且這個maximum表示路徑中的最小值
    是所有路徑最大的。算是Dijkstra的變形。

///////////////////////////////////////////////////////////////
//
// lc1103. Distribute Candies to People (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 每次分num個糖果，直到不能分為止。
    time:O(sqrt(n))

    we give out candies x times since the total number of candies is n, 
    then x*(x+1)/2 = n or O(x^2) = O(n) or O(x) = O(sqrt(n)).

    因為1+2+3+...+x = n
    跑x次，x(x+1)/2 = n -> time: x = O(sqrt(n))

///////////////////////////////////////////////////////////////
//
// lc1104. Path In Zigzag Labelled Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找出對稱性，除了第一個以外每個都是當前層級的對稱點。
    當前層級區間: res[i] = pow(2,i) - 1 + pow(2,i+1) - res[i+1]。

///////////////////////////////////////////////////////////////
//
// lc1105. Filling Bookcase Shelves (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp[i]表示到第i本書的最小高度
    dp[i] =  min(dp[i], dp[j-1] + h)
    j from i to 1
    h = max(h, books[j-1][1])
    且w要在max_width範圍內。

///////////////////////////////////////////////////////////////
//
// lc1108. Defanging an IP Address
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) inplace replacement，從後往頭走。
(2) 一般linear search。

///////////////////////////////////////////////////////////////
//
// lc1109. Corporate Flight Bookings (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將res[i] += res[i-1]
    若一個兼具為a~b，則在b+1 設置 -v
    這樣在b+1累加的可以扣掉。

///////////////////////////////////////////////////////////////
//
// lc1110. Delete Nodes And Return Forest
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用set來儲存delete node，後序由底層往上去扣除刪掉的點，postorder。

///////////////////////////////////////////////////////////////
//
// lc1111. Maximum Nesting Depth of Two Valid Parentheses Strings (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要找到max(depth(a), depth(b))是minimal，把重點放在nested ()
    ex: ((()))，若都給同一個，如a或b，一定會太大，最好的方式就是將這些平均分給
    a和b，所以輪流給。也就能將maxdepth of input分成兩半，max(a和b的depth)
    一定是最小的。

///////////////////////////////////////////////////////////////
//
// lc1114. Print in Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用counter和contition variable來控制順序。

///////////////////////////////////////////////////////////////
//
// lc1118. Number of Days in a Month
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation，閏年400潤一次，百年不潤，四年潤一次。

///////////////////////////////////////////////////////////////
//
// lc1119. Remove Vowels from a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one time pass push_back。

///////////////////////////////////////////////////////////////
//
// lc1120. Maximum Average Subtree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder。

///////////////////////////////////////////////////////////////
//
// lc1122. Relative Sort Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用counting sort，先計算各個數字的出現次數，再對於arr2的數字去填入res，
    再將不屬於arr2的數字從0~1000依序填入。

///////////////////////////////////////////////////////////////
//
// lc1123. Lowest Common Ancestor of Deepest Leaves (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 一次postorder，高度從最底層開始算(深度是由上往下算)，
    若左子樹高度 = 右子樹高度，return root。
    若左子樹高度 > 右子樹高度，return left 
                        (此left為遞迴return值，並不一定是root->left)。
    若左子樹高度 < 右子樹高度，return right 
                        (此right為遞迴return值，並不一定是root->right)。

(2) 兩次postorder，第一次找最大深度，第二次跑lc236找最小共同祖先。

///////////////////////////////////////////////////////////////
//
// lc1124. Longest Well-Performing Interval (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) > 8 ，cnt++, <= 8，cnt--
    要有最長的subarray，表示cnt == 1，因為正負都抵銷掉，然後再多一個1。
    想像cnt <= 0，為什麼要找cnt-1位置？因為中間和=1，若找cnt-2的位置，
    這一定在cnt-1之後，且忽略到一個1，所以cnt-1的位置必定是離當前位置最長的
    subarray起始點。

///////////////////////////////////////////////////////////////
//
// lc1128. Number of Equivalent Domino Pairs (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc049，lc1048。

(1) 利用bit operation去encode每個pair做出id。

///////////////////////////////////////////////////////////////
//
// lc1129. Shortest Path with Alternating Colors (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為有紅藍兩色，建立data structure {node, color}，表示這個點只能由
    color edge 連過來。從零開始用bfs。初始化個點最大path為2 * n，n為總數。

    其實最大是n*2-3：
    The maximum result happens when in a path from 0 to target, 
    all the intermediate nodes (excluding 0 and target) have 
    an additional self-edge. e.g.

    red_edges = [[0, 1], [1, 2], [2, 3]]
    blue_edges = [[1, 1], [2, 2]]
    n = 4
    The minimum step to reach 3 is 5 steps, because all intermediate 
    nodes 1 and 2 contain self-edges. In other words, 
    the maximum result can be 2 * (n - 2) + 1.

///////////////////////////////////////////////////////////////
//
// lc1130. Minimum Cost Tree From Leaf Values (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n^2)：greedy。
    每次遍歷一遍找到乘積最小的並刪掉較小的那一個數。
(2) O(n)：
    類似lc1019，使用stack。
    維持降序陣列在stack，當遇到第一個比陣列尾巴大的，要去除尾八，並且對
    尾巴左邊和當前比他大的中去取小的和(去除的值，也就是本來的尾巴)相乘，
    結束後再對陣列尾八繼續坐上述比較，直到沒有尾巴比當前小。
    最後將陣列兩兩相乘(這些為降序陣列)。
    原因：要找到兩倆乘積最小，若是降序則右乘回來，若任三個存在中間最小，則優先處理。

    如果題目要求non-leaf node是smallest node value of subtree，
    就要用升序陣列。

///////////////////////////////////////////////////////////////
//
// lc1133. Largest Unique Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bucket sort，從後面往前遍歷，看到第一個cnt == 1，return。

///////////////////////////////////////////////////////////////
//
// lc1135. Connecting Cities With Minimum Cost (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先將vector依照cost排序，若依一邊長兩個點的parent不同，連接他們，
    並res += cost，直到連接了n-1個node為止。
    union find
    類似lc721。

///////////////////////////////////////////////////////////////
//
// lc1136. Parallel Courses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc207，要修這門課，所有先修課必須在之前的學期修掉：洋蔥法bfs。

///////////////////////////////////////////////////////////////
//
// lc1137. N-th Tribonacci Number
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 一般for loop
(2) 利用一 array with fix size 3，這裏是3因為Tn_3 = Tn_2 + Tn_1 + Tn
    這樣的話，每次算新的就是val = sum(arr of element)，且dp[current_idx%3] = val

///////////////////////////////////////////////////////////////
//
// lc1140. Stone Game II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp recurtion
    dp[i][m]表示第從尾巴到第i個pile拿最多的數量，其實就是可以算出對方拿最小的，這樣我
    就是最大的。
    dp[i][m] = psum[i] - min(dp[i+x][max(x,m)]), for x = 1 ~ 2*m

///////////////////////////////////////////////////////////////
//
// lc1143. Longest Common Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1035，可用O(n) space，dp iteration。

///////////////////////////////////////////////////////////////
//
// lc1145. Binary Tree Coloring Game (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於x可以將樹分成三部分，x->left, x->right, 除了x->left, x->right, x的其他node
    數量，從這三部分中選取最大的數量，若 > n/2，return true。
    *** follow up
    Alex and Lee are going to play this turned based game.
    Alex draw the whole tree. root and n will be given.
    Now Lee says he want to color the first node.

    Return true if Lee can ensure his win, otherwise return false
    Could you find the set all the nodes, that Lee can ensure he wins the game?
    What is the complexity of your solution?

    對於每個點算出left child，right child，以及parent以外的個數，任一兩個>the rest的話，
    lee 就會贏。

///////////////////////////////////////////////////////////////
//
// lc1146. Snapshot Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) data structure: unordered_map<int, map<int, int>> record
    對每一格index，存他的版本和該版本的val。
    利用upper_bound去找到最大的版本 < snap_id。
    get: O(logn)
    set: O(logn)
    initial: O(nlogn)
    snap: O(1)
(2) 用binary search and unordered_map<int, vector<pair<int,int>>> record
    get: O(logn)
    set: O(1)
    initial: O(n)
    snap: O(1)

///////////////////////////////////////////////////////////////
//
// lc1150. Check If a Number Is Majority Element in a Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，找到第一個index，然後check nums[i + n/2] == nums[i]。

///////////////////////////////////////////////////////////////
//
// lc1152. Analyze User Website Visit Pattern (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc937。
    這題在於使用者取其visit pattern，因visit by the most users，單一user
    對同一個pattern只會visit一次，可用unordered_map<user_name, map<time_stamp, websit>>
    去紀錄，用三個for迴圈找出所有visit pattern by a user。

///////////////////////////////////////////////////////////////
//
// lc1155. Number of Dice Rolls With Target Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc70，lc518。
(1) iteration 解法類似lc494。
    因為可以有顛倒順序，amount要在外面，內圈則為dice。
(2) recursion，解法類似lc494。

///////////////////////////////////////////////////////////////
//
// lc1160. Find Words That Can Be Formed by Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) cnt(26)，若--cnt[words[i]][j] < 0，valid = false。

///////////////////////////////////////////////////////////////
//
// lc1161. Maximum Level Sum of a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs，用queue。

///////////////////////////////////////////////////////////////
//
// lc1162. As Far from Land as Possible
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs with queue。
    類似lc934。

///////////////////////////////////////////////////////////////
//
// lc1163. Last Substring in Lexicographical Order (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) l: max subarray start index
    r: current subarray start index
    去找到第一個 s[l+d] < s[r+d]，update l = max(l+d+1, r)
    為什麽不只要l = r，因為 'aaaaac'，l = l+d+1可以直接跳到c，節省時間，
    且r = l+1，從下一個位置開始重新搜尋。
    若s[l+d] > s[r+d]，update r += d+1，從這個位置開始重新搜尋，前面
    一定都比s[l+d]小。
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1165. Single-Row Keyboard
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) record index

///////////////////////////////////////////////////////////////
//
// lc1167. Minimum Cost to Connect Sticks (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy method，先將小的合併，之後總和會比較小 -> 我們要小的，代表層層迭代
    過程中，若小的越早合併，之後小的佔結果比例會較高，相反，若大的先合併，每次疊起來，
    最大的每次都會被加到。
    所以是用priority queue。

///////////////////////////////////////////////////////////////
//
// lc1169. Invalid Transactions
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用map記錄每個人的所有交易紀錄，對於每一個新的交易，檢查map中有沒有和
    當前交易為invalid的。

(2) 不用map，用四個vector紀錄訊息，跑一個n^2 for loop確認每個交易是不是invalid，
    最後跑一個n loop確認invalid的交易丟到res中。

///////////////////////////////////////////////////////////////
//
// lc1170. Compare Strings by Frequency of the Smallest Character
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，從尾巴往前累加cnt，對每一個query string，
    return cnt[f]。
    note: cnt[f]表示 所有words 其smallest ch 個數 > f的個數總和。

///////////////////////////////////////////////////////////////
//
// lc1171. Remove Zero Sum Consecutive Nodes from Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc437，lc560，lc974。
    利用prefix_sum，注意刪除的中間段必須把map中的sum也清除，用erase。

///////////////////////////////////////////////////////////////
//
// lc1176. Diet Plan Performance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window。

///////////////////////////////////////////////////////////////
//
// lc1180. Count Substrings with Only One Distinct Letter
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 判斷當前ch和last ch，若不一樣，更新。

///////////////////////////////////////////////////////////////
//
// lc1184. Distance Between Bus Stops
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) split to two array

///////////////////////////////////////////////////////////////
//
// lc1186. Maximum Subarray Sum with One Deletion (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc053.cpp。
    分成兩個case，主要是這兩個case都維持一個min，
    a. maxNoDelete就是lc053。
    b. maxWithDelete：考慮若當前要delete，就用上一輪的maxNoDelete，
       不delete就用maxWithDelete+arr[i]。

///////////////////////////////////////////////////////////////
//
// lc1188. Design Bounded Blocking Queue (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用unique_lock做write，shared_lock做read，condition_variable
    等待其他thread完成一定條件後解鎖，來做write。

///////////////////////////////////////////////////////////////
//
// lc1189. Maximum Number of Balloons
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，對所求的取min(l和o要除以2)。

///////////////////////////////////////////////////////////////
//
// lc1190. Reverse Substrings Between Each Pair of Parentheses (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) stack，initial sk = {""}，每次遇到新的'('，sk.push_back("")。
    O(n^2) time
(2) two pass，記錄每個pair，然後對於pair去走，只要碰到'('或')'，換方向。
    O(n) time

///////////////////////////////////////////////////////////////
//
// lc1192. Critical Connections in a Network (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用rank來判斷有沒有走過，若dfs return的rank > 當前rank，這edge要被加入，
    因為dfs往後的過程沒有cycle，有cycle的話return value一定 <= 當前 rank。
    另外遇到parent需要跳過。

///////////////////////////////////////////////////////////////
//
// lc1195. Fizz Buzz Multithreaded
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1188

///////////////////////////////////////////////////////////////
//
// lc1196. How Many Apples Can You Put into the Basket
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，O(1000 + N)，若Ｎ>>1000，bucket sort效果優於nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1197. Minimum Knight Moves (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use dfs + memorization

note that (1,1), (2,0), (0,2) would be special cases, these
three cost 2 step
The moment you reach 0,2 or 2,0 or 1,1 (visualize in the real chess board) 
the knight cannot move further to 0,0 or might go into negative axis, 
the smartest way is to if you are in (0,2) move the night to (2,1) 
then from there it could move to (0,0)..this takes 2 move. 
same applies for (1,1) and (2,0) too

why only (a) abs(x-1) abs(y-2) and (b) abs(x-2) abs(y-1)
This is because you are counting steps (and walking backwards) 
as you traverse from x,y to 0,0. 
The only way to reach 0.0 from x,y (x>0, y>0) is to either try (x-1,y-2) or (x-2,y-1)

time: O(m*n), m = x, n = y

(2) bfs
time: O(n^2), n = 300

///////////////////////////////////////////////////////////////
//
// lc1198. Find Smallest Common Element in All Rows
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) binary search
    因為每一個row都是有序，我們可以用last_start紀錄是一輪找到的位置來做這一輪
    開始的位置，再往前不用找的原因是一定比當前target還要小。
(2) 依照左到右上到下的方式搜尋，第一個滿足n個的一定是smallest common element。

///////////////////////////////////////////////////////////////
//
// lc1200. Minimum Absolute Difference
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，因為要找最小difference的所有組合，一定是相鄰兩個去做比較。

///////////////////////////////////////////////////////////////
//
// lc1202. Smallest String With Swaps (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find with path compression，compare with union size。
    將同一union的index放在一起，由小到大，然後sort後一一填入。

///////////////////////////////////////////////////////////////
//
// lc1207. Unique Number of Occurrences
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算每個數字出現次數。

///////////////////////////////////////////////////////////////
//
// lc1209. Remove All Adjacent Duplicates in String II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) stack iteration，類似lc723。
follow up: >= k
    (a) 先檢查若跟最後一個不一樣，判斷最後一個有沒有>=k，若有，pop
    (b) 再來判斷最後一個有沒有和自己一樣，若有cnt++，若沒有，push {1}。
    (c) 結束loop後檢查最後一個有沒有>=k，若有pop。
    注意只有在遇到和最後一個不同才去檢查有沒有>=k因為要一次移除所有相同的。

///////////////////////////////////////////////////////////////
//
// lc1213. Intersection of Three Sorted Arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當三個不一樣時，找出最大值，update其他兩個到至少比最大值大或相等。

///////////////////////////////////////////////////////////////
//
// lc1214. Two Sum BSTs (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 用stack做inorder traversal，類似lc1305。
(2) 用recursion，確認當前有沒有符合，若沒有，往左和往右去找。

///////////////////////////////////////////////////////////////
//
// lc1217. Play with Chips
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為移動一格為cost 1，移動兩格cost 2，所以若都是奇數位置或偶數位置，cost = 0，
    因此計算odd & even次數，reutrn min(odd, even)。

///////////////////////////////////////////////////////////////
//
// lc1219. Path with Maximum Gold
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 一般dfs。

///////////////////////////////////////////////////////////////
//
// lc1221. Split a String in Balanced Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算左右值，相消=0，res++。

///////////////////////////////////////////////////////////////
//
// lc1227. Airplane Seat Assignment Probability (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) f(n) = 1/n + 1/n * (n-2) * f(n-1)。
    (a) the 1st person gets his/her own seat. (with probability 1/n). 
        Then the n-th person is sure (with probability 1) to get the n-th seat.
    (b) the 1st person gets the n-th person's seat. (with probability 1/n). 
        Then the n-th person cannot (with probability 0) get the n-th seat.
    (c) the 1st person gets a seat between 2 and n-1 (with probability (n-2)/n). 
        Assume the 1st person gets a-th seat. Then in the next round, we have 3 choices again:
    3.1) if the a-th person gets 1st seat (with probability 1/(n-1)), 
         then this is just like 1st and a-th person swap their seats, 
         it never affect our result for the n-th person.
    3.2) if the a-th person gets n-th seat (with probability 1/(n-1)), 
         game over.
    3.3) if the a-th person gets a seat which is not 1st or n-th, 
         (with probability (n-1-2)/(n-1)), we jump into a loop.
(2) 利用數學歸納法得證 n > 1，f(n) = 0.5。

///////////////////////////////////////////////////////////////
//
// lc1228. Missing Number In Arithmetic Progression (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n) search
(2) binary search，利用a[0]+mid*d == a[mid]來判斷從0到mid為止有沒有都
    等差。
    d = (arr.back()-arr[0])/arr.size()。

///////////////////////////////////////////////////////////////
//
// lc1229. Meeting Scheduler
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找opverlap
    max(start1, start2) <= min(end1, end2)

///////////////////////////////////////////////////////////////
//
// lc1231. Divide Chocolate (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，類似lc410, lc1011。
    注意和上面兩題不同的是，我們要找minimum of subarray sum
    上面兩題找得是maximum of subarray sum
    We want each cut size >= mid. 
    We are binary searching minimum total sweetness.

///////////////////////////////////////////////////////////////
//
// lc1232. Check If It Is a Straight Line
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 斜率轉換，avoid divide by zero condition。
                (y2-y1) / (x2 - x1) == (y3-y2) / (x3 - x2) 
    is equal to 
                (y2-y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)

///////////////////////////////////////////////////////////////
//
// lc1234. Replace the Substring for Balanced String (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window
    若要變成balance array，想像一個window，若outside window的數量都比
    n/4小，表示裡面可以任意改動成balanced，所以要找最小的subarray，且
    這個subarray的外面四個字元都 <= n/4。
    time：O(n)
    space：O(1)

///////////////////////////////////////////////////////////////
//
// lc1235. Maximum Profit in Job Scheduling (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一map<int,int> dp表示map[time] = profit，到time為止最大profit
    對endtime, starttime, profit, 做sort
    對當前job，找到上一個time <= job.starttime, use prev(upper_bound)
    
    **  不用lower_bound是因為，若當前沒有job.starttime in dp，要用prev，若有，
        不能用prev，但用upper_bound，只要prev(upper_bound)就可以解決，
        類似lc1146。
    
    cur = dp[last_time] + job.profit
    若cur > dp.rbegin()->profit then dp[job.endtime] = cur;

///////////////////////////////////////////////////////////////
//
// lc1236. Web Crawler
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion

///////////////////////////////////////////////////////////////
//
// lc1243. Array Transformation (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，紀錄nums[i]為prev，作為下一輪使用。

///////////////////////////////////////////////////////////////
//
// lc1244. Design A Leaderboard
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用兩個map，一個set of pair，記錄每個分數和他的名字，
    另一個key:名字，value:分數。

///////////////////////////////////////////////////////////////
//
// lc1245. Tree Diameter
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 類似lc310，維持當前還沒用的剩餘node，while (n > 1)，若剩1表示2*res，
    對稱的。
    若n = 0，表示不對稱，2*res - 1。

(2) 計算以每個node為root的最大path，且不能走過parent node的點，不然會無窮
    迴圈。

///////////////////////////////////////////////////////////////
//
// lc1247. Minimum Swaps to Make Strings Equal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 收集xy和yx pattern，因為要最小的swap，先去看xy自己能不能組完，yx也是，
    也就是res += (xy/2 + yx/2)，再來 xy % 2 和 yx % 2 表示用剩下來的，
    這一定是0個或1個，若只有其中是一個，return -1，若兩個都是1，表示可以swap，
    方法數 = 2，兩個都是0，維持原狀。

///////////////////////////////////////////////////////////////
//
// lc1248. Count Number of Nice Subarrays (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

類似lc992。
(1) use atmost(k) - atmost(k-1)
    O(1) space，two pass
(2) 992 method 2。
    O(1) space，one pass
(3) 維持一個max size k的queue，表示當前odd num的index。
    若size == k，res += que.front()-last+1。
    若size > k，last = que.front()+1，que.pop()。
    O(k) space，one pass

///////////////////////////////////////////////////////////////
//
// lc1249. Minimum Remove to Make Valid Parentheses (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc301。

(1) stack iteration，將不合法得改成'*'。

///////////////////////////////////////////////////////////////
//
// lc1252. Cells with Odd Values in a Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(m*n + l)，l: length of indeces
    紀錄出現過的row和col次數，遍歷一次matrix，看當前的row和col的合是不是odd。

(2) O(m + n + l)，計算被點到odd次數的row數量和col數量
    return even_row * odd_col + even_col * odd_row。

///////////////////////////////////////////////////////////////
//
// lc1254. Number of Closed Islands
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 做dfs，碰到邊就return 1。
(2) 先將四邊做dfs，再對內部做dfs。

///////////////////////////////////////////////////////////////
//
// lc1257. Smallest Common Region (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立tree map，from bottom to top，然後建立visit map，把region1 走過的
    都插入，再來traverse region2 parent path，若任一點在visit有看過，r
    return這一點。
(2) 建立tree map，from top to bottom，再來用一般lowest common ancestor
    去做。

///////////////////////////////////////////////////////////////
//
// lc1260. Shift 2D Grid
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算出最終column位置 by i+shift，shift = k % col
    計算共同往下shift的變數times = k / col。
    shift也可代表額外往下shift 1 的個數，從col-1往前shift個column都要額外
    往下shift 1。

///////////////////////////////////////////////////////////////
//
// lc1261. Find Elements in a Contaminated Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use bit set，save memory。
(2) use hash set

///////////////////////////////////////////////////////////////
//
// lc1265. Print Immutable Linked List in Reverse (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

(1) 一般recursion解法
(2) 先計算一次list長度，再利用雙loop迴圈，每次印最後一個node的value。
(3) 將node存到size為sqrt(n)的stack。

///////////////////////////////////////////////////////////////
//
// lc1266. Minimum Time Visiting All Points
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，因為若兩者有差，會走完共同的，然後再多走差的數量，這就表示
    兩者之間走的距離就是max(diffx, diffy)。

///////////////////////////////////////////////////////////////
//
// lc1268. Search Suggestions System (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 先將string lexicographically排序，這樣會有一個性質：
    如果a[i] is prefix of a[j] -> a[i] is prefix of x, x from i+1~j-1。
    所以我們從上一次起始點 last_start 往後開始搜尋第一個word >= search word，
    也就是new_start，開始搜尋，然後更新start place from last_start to new start。
    time: O(log(N)) for each query
(2) 直接用set，lower_bound為 O(log(N))

///////////////////////////////////////////////////////////////
//
// lc1271. Hexspeak
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) turn string into long long int and transformed into hex type。

///////////////////////////////////////////////////////////////
//
// lc1272. Remove Interval
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc986。
    對於有交集的，找出沒有在remove interval中的，分三case
    a. 沒交集
    b. 交集且interval[0] < start
    c. 交集且interval[1] > end

///////////////////////////////////////////////////////////////
//
// lc1273. Delete Tree Nodes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從nodes-1跑到1，value[parent[i]] += vallue[i]。
    且res[i]，表示當前i為root的subtree中所有不能抵消的點。
    若value[i] != 0，要把這些點給parent[i]。
    即res[parent[i]] += res[i]。
(2) build tree，跑一遍postorder，若sum == 0，return nodes = 0。

///////////////////////////////////////////////////////////////
//
// lc1274. Number of Ships in a Rectangle
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: T(n) = 4*T(n/4)+c = O(n)
    注意邊界問題。

///////////////////////////////////////////////////////////////
//
// lc1275. Find Winner on a Tic Tac Toe Game
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc348。

///////////////////////////////////////////////////////////////
//
// lc1277. Count Square Submatrices with All Ones (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc221。
    dp[i][j] means the size of biggest square with A[i][j] as bottom-right corner.
    dp[i][j] also means the number of squares with A[i][j] as bottom-right corner.
    O(n^2)
(2) 用prefix sum，O(n^3)，類似lc1314。

///////////////////////////////////////////////////////////////
//
// lc1279. Traffic Light Controlled Intersection (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1188，但不用conditional variable。

///////////////////////////////////////////////////////////////
//
// lc1281. Subtract the Product and Sum of Digits of an Integer 
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) val %= n，sum += val，product *= val。

///////////////////////////////////////////////////////////////
//
// lc1282. Group the People Given the Group Size They Belong To (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持gp(n+1)，
    對於group size，如 = 3，將 = 3的idx收集，直到gp[3].size() == 3，然後push到
    res，並清空gp[3]，這樣就可以依序將所有同一個group size的人收集。
(2) sort idx by group size，一一填入。

///////////////////////////////////////////////////////////////
//
// lc1283. Find the Smallest Divisor Given a Threshold
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，left = 1, right = max(nums)
    time: O(nlog(right))
    注意round up，可以用(nums[i]+val-1) / val。

///////////////////////////////////////////////////////////////
//
// lc1287. Element Appearing More Than 25% In Sorted Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(logN)，binary search，找出candiate first location & last location。
    類似lc33。
(2) 因為是sorted且只有一個arr[i] cnt > 25%，對每個arr[i]去檢查
    若arr[i] == arr[i+n/4]，表示arr[i]數量>25%。

///////////////////////////////////////////////////////////////
//
// lc1290. Convert Binary Number in a Linked List to Integer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit manipulation

///////////////////////////////////////////////////////////////
//
// lc1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum
    O(m*n)
    若當前i~i-len且j~j-len的方形 <= threshold，len++。
(2) prefix sum + binary search to find max side length
    O(m*n*log(m+n))

///////////////////////////////////////////////////////////////
//
// lc1293. Shortest Path in a Grid with Obstacles Elimination (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dijkstra
    time: O(kmn log kmn)
(2) bfs
    time: O(kmn)

///////////////////////////////////////////////////////////////
//
// lc1295. Find Numbers with Even Number of Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 因為maxv為10^5，可以直接用區兼職判斷，O(n)
(2) digit by digit check，O(n*k)，k為number of digit for each nums[i]

///////////////////////////////////////////////////////////////
//
// lc1296. Divide Array in Sets of K Consecutive Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

類似lc659。

(1) unordered_map
    time: O(nlogn+kn)
(2) map
    time: O(kmlogm+nlogm)

///////////////////////////////////////////////////////////////
//
// lc1299. Replace Elements with Greatest Element on Right Side (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後面走回去，維持一個最大值。

///////////////////////////////////////////////////////////////
//
// lc1302. Deepest Leaves Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs
(2) queue iteration，bfs。

///////////////////////////////////////////////////////////////
//
// lc1304. Find N Unique Integers Sum up to Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 不要用1+2+...+n-1，因為如果n很大會overflow，
    find rule。
    2*i - (n-1)

///////////////////////////////////////////////////////////////
//
// lc1305. All Elements in Two Binary Search Trees (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1214，two stack inorder traversal。
(2) 將node value放入res然後sort

///////////////////////////////////////////////////////////////
//
// lc1306. Jump Game III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1311. Get Watched Videos by Your Friends
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs + sort。

///////////////////////////////////////////////////////////////
//
// lc1313. Decompress Run-Length Encoded List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本array operation。

///////////////////////////////////////////////////////////////
//
// lc1314. Matrix Block Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc1292。
(1) 先算出dp[i][j]，表示(0,0)到(i,j)的總和
    再來res[i][j] = res[i+k][j+k] - res[i+k][j-k-1] 
                                 - res[i-k-1][j+k] 
                                 + res[i-k-1][j-k-1]

///////////////////////////////////////////////////////////////
//
// lc1315. Sum of Nodes with Even-Valued Grandparent
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，類似lc337。

///////////////////////////////////////////////////////////////
//
// lc1317. The K Weakest Rows in a Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) binary search + priority queue。
    O(m*(logn + logm) + klogm)
(2) binary search + set。
    O(m*(logn + logm) + k)

///////////////////////////////////////////////////////////////
//
// lc1319. Number of Operations to Make Network Connected
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find

///////////////////////////////////////////////////////////////
//
// lc1325. Delete Leaves With a Given Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder。

///////////////////////////////////////////////////////////////
//
// lc1329. Sort the Matrix Diagonally (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 可以將dig分類成用i-j歸類
    time: O(m*nlogd), d = min(m,n)
    space: O(m*n)
(2)
    time: O(m*n + (m+n)*(dlogd)), d = min(m,n)
    space: O(d)

///////////////////////////////////////////////////////////////
//
// lc1331. Rank Transform of an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort index，add to result array。

///////////////////////////////////////////////////////////////
//
// lc1337. The K Weakest Rows in a Matrix
//
///////////////////////////////////////////////////////////////

(1) bucket sort
    O(m*n + max(k, 100))
(2) binary search + priority queue。
    O(m*(logn + logm) + klogm)
(3) binary search + set。
    O(m*(logn + logm) + k)

///////////////////////////////////////////////////////////////
//
// lc1338. Reduce Array Size to The Half
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bucket sort
(2) priority queue

///////////////////////////////////////////////////////////////
//
// lc1339. Maximum Product of Splitted Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 兩次postorder，第一次算總和，第二次算乘積最大值。

///////////////////////////////////////////////////////////////
//
// lc1340. Jump Game V (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dag + dfs
    time: O(n)
    利用降序stack建立dag
    因為 4 2 1 5 6，d = 2
    5->1, 5->2
    6->5，其實6->1但因為這條不會是最深的，(6->5->1)在做降序sk時自動過濾掉這條
    往右降序可以把所有i左邊的都加進去，往左降序可把所有u的右邊都加進去。

    在build dag最一般就是O(nd)，但這樣會加入一些冗邊，向上面的利子，這些邊
    都不會在最深路徑裡。

    最後做dfs找最深路徑。

///////////////////////////////////////////////////////////////
//
// lc1342. Number of Steps to Reduce a Number to Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation

///////////////////////////////////////////////////////////////
//
// lc1345. Jump Game IV (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，注意走過的點，該val一定走過，所以可以將其整個vector都清空，避免再走一次。

///////////////////////////////////////////////////////////////
//
// lc1346. Check If N and Its Double Exist
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find pair of nums[i]*2 or nums[i]/2。

///////////////////////////////////////////////////////////////
//
// lc1347. Minimum Number of Steps to Make Two Strings Anagram
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算s的出現次數，扣除t的出現次數，若有負的，表示需要轉換的，把負的加總
    即為答案。
(2) 維持兩個cnt，取min(cnt1[i], cnt2[i])，表示絕對不用換的字母，加總res
    return s.size() - res。

///////////////////////////////////////////////////////////////
//
// lc1348. Tweet Counts Per Frequency (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

* n: # of record for one tweet

(1) 利用multiset<int>，lower_bound找出第一個>=startime的position
    recordTweet time: O(logn)
    getTweetCountsPerFrequency: O(logn) + O(# of record between startTime and endTime)

(2) vector<int>，linear find。
    recordTweet time: O(1)
    getTweetCountsPerFrequency: O(n)

///////////////////////////////////////////////////////////////
//
// lc1358. Number of Substrings Containing All Three Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1248 method 2。

///////////////////////////////////////////////////////////////
//
// lc1351. Count Negative Numbers in a Sorted Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc74。
(1) O(m+n)，因為row & col sorted，從右上角開始往左下角走。

///////////////////////////////////////////////////////////////
//
// lc1352. Product of the Last K Numbers (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix product，類似prefix sum
    若遇到0，將arr = {1}。
    若k >= arr.size() ? 0 : arr.back()/arr[arr.size()-k-1];

///////////////////////////////////////////////////////////////
//
// lc1353. Maximum Number of Events That Can Be Attended (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort events。
    利用min priority queue，維持一d表示當前available time，
    將所有start == d 的end加入queue，並檢查queue中的end若 < d，都pop。

///////////////////////////////////////////////////////////////
//
// lc1356. Sort Integers by The Number of 1 Bits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count bits，計算有幾個一有兩種做法：
    (a) cnt += n&1, n >>= 1
    (b) cnt++, n = n&(n-1)

///////////////////////////////////////////////////////////////
//
// lc1359. Count All Valid Pickup and Delivery Options (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) for n-1 pairs, the first one can be inserted into 2*(n-1)+1
    positions, and the second one can be inserted into 2*n positions
    so # of methods are (2*n-1) * 2*n
    因為有順序，要/2，所以為 (2n-1)*n。

///////////////////////////////////////////////////////////////
//
// lc1365. How Many Numbers Are Smaller Than the Current Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bucket sort，bucket[i]表示所有比i小的數量總和。
    time: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1366. Rank Teams by Votes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每個ch計算得到的votes數量。
    m: # of votes, n: # of teams
    count votes: O(m*n)
    sort: O(n^2logn)

///////////////////////////////////////////////////////////////
//
// lc1367. Linked List in Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前點，直接對link list往下找，若都找到reutrn true，不然就遞迴。

///////////////////////////////////////////////////////////////
//
// lc1370. Increasing Decreasing String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) buckeet sort。

///////////////////////////////////////////////////////////////
//
// lc1372. Longest ZigZag Path in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，維持當前node是parent的left還是right direction。
    若是left，則取自己right child return的value，反之。

///////////////////////////////////////////////////////////////
//
// lc1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1380. Lucky Numbers in a Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space
    let A(i,j) be the min of row i, max of col j,
    if there exists another A(i',j') as lucky number,
    (1) A(i',j') > A(i,j') > A(i, j)
    (2) A(i',j) > A(i',j')
    so A(i',j) > A(i,j)
    based on lucky number definition, its a contradiction,
    so there exists only one lucky number in a matrix.

(2) O(m+n) space，維持rowv，colv表示該row的最小值和該col的最大值。

///////////////////////////////////////////////////////////////
//
// lc1381. Design a Stack With Increment Operation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用inc array，inc[i]，表示需要加到0~i，當前若pop，inc[i-1] += inc[i]
    並且將pop value += inc[pop index]。
    time: O(1)。
    space: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1382. Balance a Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) inorder + postorder
    time: O(n)，space: O(n)

follow up: O(1) space DSW algo
https://leetcode.com/problems/balance-a-binary-search-tree/discuss/541785/C%2B%2BJava-with-picture-DSW-O(n)orO(1)
** dont need to write code but briefly explain how it works
(a) Convert the initial tree into a vine. By doing right rotations, 
    we flatten a tree into a 'linked list', where the head is the former leftmost node, and tail - former rightmost node.
(b) As you convert the tree into a vine, count the total number of nodes in cnt.
(c) Calculate the height of the closest perfectly balanced tree: h = log2(cnt + 1).
(d) Calculate the number of nodes in the closest perfectly balanced tree: m = pow(2, h) - 1.
(e) Left-rotate cnt - m nodes to cover up the excess of nodes.
Note: you rotate the root node, then you rotate the right child of the new root node, 
and so on. In other words, left rotations are performed on every second node of the vine.

(f)Left-rotate m / 2 nodes.
(g) Divide m by two and repeat the step above while m / 2 is greater than zero.

///////////////////////////////////////////////////////////////
//
// lc1385. Find the Distance Value Between Two Arrays (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(m*n)，brute force
(2) O(nlogn)，先sort，
    i 表示當前index in arr1，j表示對於到目前為止的i，都0~j-1和0~i相差都>d。
    結束loop時，看i~n1-1都要放入res。

///////////////////////////////////////////////////////////////
//
// lc1387. Sort Integers by The Power Value
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) built-in sort function
(2) quick select

///////////////////////////////////////////////////////////////
//
// lc1389. Create Target Array in the Given Order (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(nlogn)，類似lc315。
    想像一下，題目要求，i < j，index[i] >= index[j]，則index[i]要往右移一位。
    可以用divide and conquer，依照最終index去做排序。
    if (index[i] + shift >= index[j]) {
        res.push_back(index[j])
        shift += 1 --> 這裡表示因為index[j]要插在index[i]前面，shift要加一。
    } else {
        res.push_back(index[i]+shift) --> update index[i]最終位置，並且
                                          放到res裡。
    }
(2) O(n^2)，一般insertion方法。將i開始全都往後移一位。

///////////////////////////////////////////////////////////////
//
// lc1391. Check if There is a Valid Path in a Grid (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前，先到下一點，再對下一點back回去，若可以回到當前點，表示下一點
    是合法圖形。
    用visit來判斷下一點有沒有走過，若有就跳過。加入queue就標記走過。

///////////////////////////////////////////////////////////////
//
// lc1394. Find Lucky Integer in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1395. Count Number of Teams (看)*
//
///////////////////////////////////////////////////////////////

(1) O(n^3)，暴力解。
(2) 對於每個candidate，跑一次回圈
    維持兩個變數vector<int> less, greater。
    less[0]表示在左邊比自己小，less[1]表示在右邊比自己小。
    greater[0]表示在左邊比自己大，greater[1]表示在右邊比自己大。
    res = less[0] * greater[1] + greater[0] * less[1]。

///////////////////////////////////////////////////////////////
//
// lc1396. Design Underground System (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 考慮edge case，利用map紀錄，key: start_end，value: {total_time, cnt}
    第二個map是個人資料，key: id，value: {start, start_time}

///////////////////////////////////////////////////////////////
//
// lc1399. Count Largest Group
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count digit。

///////////////////////////////////////////////////////////////
//
// lc1403. Minimum Subsequence in Non-Increasing Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。
(2) nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1408. String Matching in an Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

k average len of a word

(1) prefix trie tree
    time: O(nk^2)
    將每一個word從 word.substr(i)全部insert到trie tree中，
    並且經過的點end++，這樣代表之後我們搜尋這個word，若走到底後end > 1，
    表示至少有一個除了自己以外的word的substring是這個word。
(2) sort and find n^2
    time: O(nlogn+n^2*k)

///////////////////////////////////////////////////////////////
//
// lc1409. Queries on a Permutation With Key (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lru cache的方式去做，O(n^2)
(2) 利用bit，binary index tree。
(3) 利用segment tree。
    (2) 和 (3)都想像成range sum，arr[0,i]表示0~i的個數，也就是對於i+1位置
    中，前面有幾個number。
    因為題目要求當前number是在arr中第幾個位置，想像成每個位置都是1，那就是說
    given index i，他前面的數量就是rangesum(0,i-1)。
    另外用map紀錄number和其對應在arr的位置。

///////////////////////////////////////////////////////////////
//
// lc1413. Minimum Value to Get Positive Step by Step Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為在每個for loop step sum > 0，表示追蹤minimum sum of for loop，
    return -minv + 1。
(2) 對於每輪若sum < 1，補足到1，即 res += 1-sum。

///////////////////////////////////////////////////////////////
//
// lc1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

greedy method。
always find the largest one less than K。
(1) recursion
    Time O((logk)^2), since O(log k) Fibonacci numbers smaller than k.
    Space O(logK), can be saved by tail recursion.
(2) iteration
    Time O((logk))
    Space O(1)

///////////////////////////////////////////////////////////////
//
// lc1422. Maximum Score After Splitting a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) maxv = zeros_left + ones_right
         = zeros_left + ones_total - ones_left
         = zeros_left - ones_left + ones_total
    所以 maxv = max(maxv, zeros_left - ones_left)
    return maxv + ones_total

///////////////////////////////////////////////////////////////
//
// lc1423. Maximum Points You Can Obtain from Cards (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) sliding window，維持n-k大小的window，找最小。
    time: O(n)
(2) sliding window，先算出左邊開始大小為k總和: left
    然後跑一個k for loop，
    left -= arr[k-1-i];
    right += arr[n-1-i];
    res = max(res, left+right)
    這表示每次從left扣掉一個，right加上一個，維持大小為k的兩邊總和
    time: O(k)

///////////////////////////////////////////////////////////////
//
// lc1425. Constrained Subsequence Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc239。
(1) 用一降序deque。
    time: O(n), space: O(k)
(2) 用一priority queue，max heap。
    time: O(nlogK), space: O(K)

///////////////////////////////////////////////////////////////
//
// lc1427. Perform String Shifts
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string concatenation

///////////////////////////////////////////////////////////////
//
// lc1428. Leftmost Column with at Least a One
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(rlog(c))，binary search
(2) O(r+c)，類似lc240。

///////////////////////////////////////////////////////////////
//
// lc1429. First Unique Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc146 lru，用list和map紀錄list得iterator。
    find first unique: O(1)
(2) 用queue和map，map紀錄出現次數，若為1，push to que。
    find first unique: O(n)

///////////////////////////////////////////////////////////////
//
// lc1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1431. Kids With the Greatest Number of Candies
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find maxv then check if candies[i] + extra >= maxv。

///////////////////////////////////////////////////////////////
//
// lc1433. Check If a String Can Break Another String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，從0~25，計算兩者當前數量，若次數交錯，表示不能break。
(2) nlogn sort

///////////////////////////////////////////////////////////////
//
// lc1436. Destination City
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass，第一次把start place加進去，第二次對於end place看有沒有在
    set裡。

///////////////////////////////////////////////////////////////
//
// lc1437. Check If All 1's Are at Least Length K Places Away
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find last index with a[idx] == 1 and check if 
    i-idx-1 < k or not。

///////////////////////////////////////////////////////////////
//
// lc1441. Build an Array With Stack Operations
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) When we find target[i] is greater than current number, 
    just push and pop and update it until they are equal.

///////////////////////////////////////////////////////////////
//
// lc1443. Minimum Time to Collect All Apples in a Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) build graph first, start from 0, use dfs.
    We add 2 to res when we have collect all return value from
    our descendents that sum is bigger than 0 or current node is an apple.

///////////////////////////////////////////////////////////////
//
// lc1448. Count Good Nodes in Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。
(2) preorder。

///////////////////////////////////////////////////////////////
//
// lc1450. Number of Students Doing Homework at a Given Time
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本判斷interval。

///////////////////////////////////////////////////////////////
//
// lc1457. Pseudo-Palindromic Paths in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation，利用xor兩個  1
(2) set，利用set只有唯一性的特性來判斷set <=1，是的話就是回文。

///////////////////////////////////////////////////////////////
//
// lc1460. Make Two Arrays Equal by Reversing Sub-arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bucket sort
(2) a. use xor to check if bit counting is same between arr and target.
    b. check if target sum is equal to arr sum.

///////////////////////////////////////////////////////////////
//
// lc1464. Maximum Product of Two Elements in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use pointer to linear find

///////////////////////////////////////////////////////////////
//
// lc1466. Reorder Routes to Make All Paths Lead to the City Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用rel map來判斷當前邊的關係，比如 a->b，
    rel[a].push_back({b, 1})
    rel[b].push_back({a, 0})
    這樣在做bfs就可以知道若連過去的是1，++res。

///////////////////////////////////////////////////////////////
//
// lc1469. Find All The Lonely Nodes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用tag來判斷當前node是不是lonley，
    ex: preorder(root->left, !root->right)
    ex: preorder(root->right, !root->left)

///////////////////////////////////////////////////////////////
//
// lc1470. Shuffle the Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit manipulation，把後半端作為cache，儲存前半段的所有數字，
    nums[i] = nums[j] >> 10;
    nums[i+1] = nums[j] & 1023;

///////////////////////////////////////////////////////////////
//
// lc1472. Design Browser History
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2，3

(1) two stack，history & future，注意history size 必須大於1。
    visit時，future clear.
(2) list，維持now & end，注意visit，如果++now >= arr.size()，push_back()
    否則，arr[now] = url
(3) unordered_map
    visit: map[++now] = url, end = now

///////////////////////////////////////////////////////////////
//
// lc1474. Delete N Nodes After M Nodes of a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one pass，對於n，now->next = now->next->next。這樣now不用動但可以
    一直接下一個。

///////////////////////////////////////////////////////////////
//
// lc1475. Final Prices With a Special Discount in a Shop
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) stack iteration，維持一個升序stack。

///////////////////////////////////////////////////////////////
//
// lc1477. Find Two Non-overlapping Sub-arrays Each With Target Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum，往左找到第一個arry後，再往右去找第二個array。
    並且每次都更新左邊的array長度。
    類似lc560。
(2) sliding window
    dp[i] = 到目前為止最短的array，
    res = min(res, dp[i-1] + right-left+1)
    且 維持一個變數表示到目前為止最短的array: best_so_far
    dp[right] = best_so_far。

///////////////////////////////////////////////////////////////
//
// lc1480. Running Sum of 1d Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 單純累加上一位的值。

///////////////////////////////////////////////////////////////
//
// lc1481. Least Number of Unique Integers after K Removals
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

類似lc347

(1) sort
    O(n + nlogn), space: O(logn)
(2) priority queue
    time: O(n + ulogu + mlogu), space: O(logu)
(3) bucket
    time: O(n), space O(n)

///////////////////////////////////////////////////////////////
//
// lc1485. Clone Binary Tree With Random Pointer
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 類似lc138，O(1) space, three pass，必須NodeCopy class和Node class
    一致才行
(2) 利用map，O(n) space, one pass。

///////////////////////////////////////////////////////////////
//
// lc1486. XOR Operation in an Array (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，對於start = 0, 1, 2, 4, n = 1, 1, 2, 3, .... 8

start = 0, 1, n = 1~8
[N % 4 == 1] Green Row: Ans = Number[N]
[N % 4 == 2] Yellow Row: Ans = 2
[N % 4 == 3] Red Row: Ans = Number[N] ^ 2
[N % 4 == 0] Blue Row: Ans = 0

start = 2, 3, n = 1 ~ 8
N % 4 == 1] Green Row: Ans = Number[1]
[N % 4 == 2] Yellow Row: Ans = Number[N] ^ Number[1]
[N % 4 == 3] Red Row: Ans = Number[1] ^ 2
[N % 4 == 0] Blue Row: Ans = Number[N] ^ Number[1] ^ 2

https://leetcode.com/problems/xor-operation-in-an-array/discuss/699141/Visual-Solution-Python-or-O(1)-Time-or-O(1)-Space

///////////////////////////////////////////////////////////////
//
// lc1490. Clone N-ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc133
(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1491. Average Salary Excluding the Minimum and Maximum Salary
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find

///////////////////////////////////////////////////////////////
//
// lc1494. Parallel Courses II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 

///////////////////////////////////////////////////////////////
//
// lc1496. Path Crossing
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用set紀錄走過的。 

///////////////////////////////////////////////////////////////
//
// lc1502. Can Make Arithmetic Progression From Sequence (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) time, O(1) space
    類似lc041。
    因為要找diff，可以先找到maxv, minv算出diff
    跑一個回圈，對於是自己的點，跳過(++idx)，若不是自己的點，算位置，若沒辦法算，
    return false，最後得到自己得pos，若pos < idx，表示這個點和之前已找到的點一樣，表示重複
    ，但不可能重複，除非diff = 0，所以return false，不然arr[idx] == arr[pos]，這也表示i>pos，
    也要return false，因為如果一樣，diff會=0，一開始就跳過(++idx)，diff!=0但又有
    arr[idx] == arr[pos]表示idx != pos，會造成無窮迴圈，
    最後swap(arr[idx], arr[pos])。

(2) O(nlogn) time, O(logn) space
    sort then find difference

///////////////////////////////////////////////////////////////
//
// lc1504. Count Submatrices With All Ones
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc085
(1) 用lc085 method 1去解。
(2) 用lc085 method 2去解。
    因為要算當前高度的所有rectangle，
    sum[i] = sum[sk.back()]
    sum[i] += (i-sk.back())*dp[i]。

///////////////////////////////////////////////////////////////
//
// lc1506. Find Root of N-Ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n) space，找deg == 0的點，map紀錄。
(2) O(1) space，利用xor，只有root只會出現一次。

///////////////////////////////////////////////////////////////
//
// lc1507. Reformat Date
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 判斷長度來檢查是1 ~ 9還是 > 10來做substr。

///////////////////////////////////////////////////////////////
//
// lc1512. Number of Good Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum

///////////////////////////////////////////////////////////////
//
// lc1518. Water Bottles (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(log(n)) time，
    res += empty / exchange
    empty = empty / exchange + empty % exchange
(2) O(1) time

The "price" of buying a refill is handing over two empties. 
However, you must have your own empty bottle to receive the refill.
Therefore after drinking the initial numBottles, 
we "keep aside" one empty for receiving the refills (therefore we do 9 minus 1) 
and trade in the remaining 8 empties to get refills @ 2 bottles/refill. 

///////////////////////////////////////////////////////////////
//
// lc1522. Diameter of N-Ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc543。

///////////////////////////////////////////////////////////////
//
// lc1528. Shuffle String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc041。
    swap until i == indices[i]。

///////////////////////////////////////////////////////////////
//
// lc1530. Number of Good Leaf Nodes Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，track左子樹leaf和右子樹leaf的距離和 <= d。

///////////////////////////////////////////////////////////////
//
// lc1534. Count Good Triplets
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) brute force，O(n^3)，可以在跑第三個loop時先檢查abs(a[i]-a[j]) <= a

///////////////////////////////////////////////////////////////
//
// lc1539. Kth Missing Positive Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1060。
    唯一差別是要從1開始算。

///////////////////////////////////////////////////////////////
//
// lc1541. Minimum Insertions to Balance a Parentheses String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 
    (a) when s[i] == ')' && (s[i+1] == '(' or i == s.size()-1), we need to insert one ')'; 
        Otherwise, there are two consecutive ')', and we skip the next one: i++
    (b) when every time we face two ')', subtract one '(' and check if it is < 0. 
        If yes, we need to insert one '(' and reset left to 0.
    (c) after one time pass. res += left*2 to make sure if there are not enough ')'.

///////////////////////////////////////////////////////////////
//
// lc1544. Make The String Great
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) stack
(2) two pointer
    note: 'a'^'A' = 32

///////////////////////////////////////////////////////////////
//
// lc1550. Three Consecutive Odds
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find 連續三個奇數，若遇偶數，cnt = 0。

///////////////////////////////////////////////////////////////
//
// lc1557. Minimum Number of Vertices to Reach All Nodes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找沒有in-degree的node。
*** follow up: 先對沒有in-degree的node跑一遍dfs，最後再對那些環找任一點
               做dfs。

///////////////////////////////////////////////////////////////
//
// lc1570. Dot Product of Two Sparse Vectors
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) map operation，儲存非零位置。
(2) two pointer，類似lc349，lc350。
    用vector<pair<int, int>>儲存非零位置。

///////////////////////////////////////////////////////////////
//
// lc1572. Matrix Diagonal Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: O(n)，跑一遍找對角線，若n是奇數，扣掉重複算的。

///////////////////////////////////////////////////////////////
//
// lc1578. Minimum Deletion Cost to Avoid Repeating Letters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個sum和到目前為止最大maxv，若遇到s[i] != s[i-1]
    res += sum-maxv, sum = maxv = 0;

///////////////////////////////////////////////////////////////
//
// lc1582. Special Positions in a Binary Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc531。

(1) 對於每個row先找colsum == 1，若有，找到對應位置並搜尋row有沒有==1，
    若有，++res。
    因為每個row去搜尋row只會搜尋一次，所有點總共最多visit m*n次。
    time: O(m*n)
    space: O(1)
(2) lc531的method 2。
    time: O(m*n)
    space: O(m+n)

///////////////////////////////////////////////////////////////
//
// lc1583. Count Unhappy Friends (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n^2)，紀錄preference，這樣就可以從O(n^3)變成O(n^2)。

///////////////////////////////////////////////////////////////
//
// lc1586. Binary Search Tree Iterator II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc173。
    inorder stack traversal，將前後串連起來

///////////////////////////////////////////////////////////////
//
// lc1588. Sum of All Odd Length Subarrays (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 去計算A[i] 出現在subarry的次數
    O(n) time O(1) space
    從左邊subarray來看，有i, [i, i-1], ... [i, i-1, ..., 1, 0], i+1種選擇
    從右邊subarray來看，有i, [i, i+1], [i, i+1, ..., n-1], n-i種選擇
    所以A[i]出現在subarray共有 (i+1)*(n-i)，因為要找奇數，所以/2
    但有可能有小數點，且一定會有自己一次，所以 ((i+1)*(n-i)+1)/2;
    也可ceil((i+1)*(n-i)/2)。

    Example of array [1,2,3,4,5]
    1 2 3 4 5 subarray length 1
    1 2 X X X subarray length 2
    X 2 3 X X subarray length 2
    X X 3 4 X subarray length 2
    X X X 4 5 subarray length 2
    1 2 3 X X subarray length 3
    X 2 3 4 X subarray length 3
    X X 3 4 5 subarray length 3
    1 2 3 4 X subarray length 4
    X 2 3 4 5 subarray length 4
    1 2 3 4 5 subarray length 5

    5 8 9 8 5 total times each index was added.
    3 4 5 4 3 total times in odd length array with (x + 1) / 2
    2 4 4 4 2 total times in even length array with x / 2

///////////////////////////////////////////////////////////////
//
// lc1598. Crawler Log Folder
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，檢查 == "../" 和 != "./"即可。

///////////////////////////////////////////////////////////////
//
// lc1600. Throne Inheritance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1602. Find Nearest Right Node in Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bfs
(2) preorder morris traversal，注意計算深度問題。

///////////////////////////////////////////////////////////////
//
// lc1603. Design Parking System
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) thread safe solution，注意用mtx陣列，fix size，而不是用vector
https://stackoverflow.com/questions/16465633/how-can-i-use-something-like-stdvectorstdmutex/24170141

///////////////////////////////////////////////////////////////
//
// lc1608. Special Array With X Elements Greater Than or Equal X
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 從後往前找
(2) binary search

///////////////////////////////////////////////////////////////
//
// lc1609. Even Odd Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，和sign來判斷當前要是even level or odd level。

///////////////////////////////////////////////////////////////
//
// lc1612. Check If Two Expression Trees are Equivalent (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) preorder，利用cnt(26, 0)紀錄出現的次數
follow up: 如果root是'-'，left subtree不會被影響，right subtree sign*=-1。

///////////////////////////////////////////////////////////////
//
// lc1614. Maximum Nesting Depth of the Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) linear search。

///////////////////////////////////////////////////////////////
//
// lc1615. Maximal Network Rank (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用unordered_set記錄自己有連到幾個，跑一個O(n^2)，去算出最大的兩個邊。
    O(n^2)
    follow up: if average m is O(n), design a O(n) algo
follow up:
    1. 若最大數量的node只有一個，對於其他的node算出和最大數量的和，若這兩node有
    邊必須扣掉一。
    2. 若有兩個以上，想像若這些node 為m，若 m*(m-1)/2 > connect 這些彼此node
    的邊數量，代表一定有兩個node屬於最大數量邊，且沒有邊連這兩個，不用-1。
    note: fully connected of n nodes, its edge = n*(n-1)/2。

///////////////////////////////////////////////////////////////
//
// lc1619. Mean of Array After Removing Some Elements
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) sort entire array
(2) 用兩個priority queue。

///////////////////////////////////////////////////////////////
//
// lc1624. Largest Substring Between Two Equal Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find, use cnt to record position

///////////////////////////////////////////////////////////////
//
// lc1628. Design an Expression Tree With Evaluate Function (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) system design ood
    base node
    number node
    op node: addnode, subtract node, multiply node, divide node

///////////////////////////////////////////////////////////////
//
// lc1629. Slowest Key
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持最大diff和其label即可。

///////////////////////////////////////////////////////////////
//
// lc1631. Path With Minimum Effort
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1102，Dijkstra。
    time: O(mnlogmn)
    space: O(mn)

///////////////////////////////////////////////////////////////
//
// lc1636. Sort Array by Increasing Frequency
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1640. Check Array Formation Through Concatenation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map來儲存第一個pieces的type，然後對於arr的第一個數去找對應的type，
    並iterate 該pices。

///////////////////////////////////////////////////////////////
//
// lc1644. Lowest Common Ancestor of a Binary Tree II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 變形postordeder，遇到p或q，++cnt，cnt == 2才有lca。

///////////////////////////////////////////////////////////////
//
// lc1647. Minimum Deletions to Make Character Frequencies Unique
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) space
    記錄每個出現次數的字母數量，
    若cnt[i] > 1，cnt[i-1] += cnt[i-1], res += cnt[i]-1。
(2) O(1) space
    先記錄出現次數並sort。
    維持一個now_feq表示最近使用過的feq，
    若times[i] >= now_feq, --now_feq, res += times[i]-now_feq
    else now_feq = times[i]

///////////////////////////////////////////////////////////////
//
// lc1650. Lowest Common Ancestor of a Binary Tree III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc160
    O(log(n)) time O(1) space

///////////////////////////////////////////////////////////////
//
// lc1654. Minimum Jumps to Reach Home (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，建立queue with state，表示當前到position是foward or backward
    利用visit表示這個點有沒有到過，被foward到過或是backward到過。
    關於maxval，
    if (a >= b)，maxval = x+b
    if (a < b)，maxval = x+a+a+b
    https://leetcode.com/problems/minimum-jumps-to-reach-home/
    discuss/935419/Python-deque-BFS-O(max(x-max(forbidden))%2Ba%2Bb)

///////////////////////////////////////////////////////////////
//
// lc1656. Design an Ordered Stream
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個index，表示第一個空的位置，若非空，就push到res，並移到第一個空的
    位置。

///////////////////////////////////////////////////////////////
//
// lc1657. Determine if Two Strings Are Close (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) bucket sort
    if (n < 26log26) then O(26log26)。

///////////////////////////////////////////////////////////////
//
// lc1660. Correct a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs with map，利用parent map記錄自己的parent是誰，若當前自己right
    child被指過，表示自己的孩子和自己同一層，now->right = null，且自己
    的parent對自己設置null。

///////////////////////////////////////////////////////////////
//
// lc1662. Check If Two String Arrays are Equivalent
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer searching

///////////////////////////////////////////////////////////////
//
// lc1666. Change the Root of a Binary Tree (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用recursion，當前有new parent，
    規則是如果當前now->left = new parent，則now->left = null，反之。
    old parent = now->parent
    now->parent = new parent，建立新的parent。
    且若當前砍掉連接後還有左孩子，則讓他變成右孩子。因為left child 要去接
    自己的parent: now->left = recursion(old_parent, now)。

///////////////////////////////////////////////////////////////
//
// lc1668. Maximum Repeating Substring
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大的k，repeat word for max k times and find this word
    in input string。

///////////////////////////////////////////////////////////////
//
// lc1669. Merge In Between Linked Lists
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear pass。

///////////////////////////////////////////////////////////////
//
// lc1670. Design Front Middle Back Queue
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 利用list and iterator，維持mid
(2) 利用兩個deque：left & right，left.size()-right.size() <= 1。

///////////////////////////////////////////////////////////////
//
// lc1672. Richest Customer Wealth
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find max row sum。

///////////////////////////////////////////////////////////////
//
// lc1673. Find the Most Competitive Subsequence (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用升序stack，若當前可以pop，檢查未來還有沒有足夠的element可以放入stack。

///////////////////////////////////////////////////////////////
//
// lc1676. Lowest Common Ancestor of a Binary Tree IV
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder，利用unordered set來記錄node。

///////////////////////////////////////////////////////////////
//
// lc1684. Count the Number of Consistent Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) set

///////////////////////////////////////////////////////////////
//
// lc1695. Maximum Erasure Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer，維持一subarray裡面的次數都只出現一個，類似lc3。

///////////////////////////////////////////////////////////////
//
// lc1696. Jump Game VI (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc239，用一降序deque。
time : O(n), space: O(k)
    this problem is like leetcode 239, just use a decreasing deque size k.
    More specifically, the head of the deque is the max score we can get from current index i.
    The size of deque is k because for current index i, 
    the farthest idx before i is i-k, and when we push i in to que, 
    we need to pop out any index smaller than i-k.

///////////////////////////////////////////////////////////////
//
// lc1700. Number of Students Unable to Eat Lunch
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) two pointer，計算不符合的數量，若等同於當前學生數量，return。
    O(n^2) time
    the worst case is like student [0 0 0 1 1 1], sandwich [1 0 1 0 1 0]
    and for each sandwich, we go though student array n/2 times. 
    That is, total time: n/2*n = O(n^2).

(2) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1704. Determine if String Halves Are Alike
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find

///////////////////////////////////////////////////////////////
//
// lc1708. Largest Subarray Length K (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大，直接去比較頭，若都一樣，代表是最後一個subarry
    ex: [1 1 1 1 2]，k = 3，選 [1 1 2]
*** follow up: numbers are not distinct.
    類似lc1163。
    唯一差別是不能update l = max(l+d+1, r)，只能l = r，因為這是有固定的長度k
    而不是像lc1163一樣substring沒有固定長度。
    另外多一個條件，因為限定長度k，確認現在比的r+k-1 < n才值得比。
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1710. Maximum Units on a Truck
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort，and greedy。

///////////////////////////////////////////////////////////////
//
// lc1716. Calculate Money in Leetcode Bank
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) math，O(1) time。
(2) loop，O(n) time

///////////////////////////////////////////////////////////////
//
// lc1721. Swapping Nodes in a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one pass
** follow up: change structure, maintain p1, n1, p2, n2
注意若 n1 == p2 or n2 == p1，要做相鄰的處理
且n2 == p1，要swap node，因為我們assume p1在左邊，p2在右邊做處理。

///////////////////////////////////////////////////////////////
//
// lc1725. Number Of Rectangles That Can Form The Largest Square
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find max of minlen of each rect。

///////////////////////////////////////////////////////////////
//
// lc1730. Shortest Path to Get Food
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1732. Find the Highest Altitude
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear找累加最大值。

///////////////////////////////////////////////////////////////
//
// lc1736. Latest Time by Replacing Hidden Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從左到右，找最大的數字，注意time[0]要看time[1]，time[1]要看time[0]

///////////////////////////////////////////////////////////////
//
// lc1740. Find Distance in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder

///////////////////////////////////////////////////////////////
//
// lc1753. Maximum Score From Removing Stones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找最大和最小，各扣一然後++res。

///////////////////////////////////////////////////////////////
//
// lc1754. Largest Merge Of Two Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string compare
    since at most substr will be executed n times for s1 and m times for s2.
    so total is (n+n-1+n-2+...+1) + (m+m-1+m-2+...+1) = O(n^2+m^2)

///////////////////////////////////////////////////////////////
//
// lc1758. Minimum Changes To Make Alternating Binary String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find 010101... error positions and return min(ones, n-ones)
    n-ones means 101010.... error positions.

///////////////////////////////////////////////////////////////
//
// lc1762. Buildings With an Ocean View
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) decreasing stack from left to right
(2) array search from right to left

///////////////////////////////////////////////////////////////
//
// lc1768. Merge Strings Alternately
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer

///////////////////////////////////////////////////////////////
//
// lc1769. Minimum Number of Operations to Move All Balls to Each Box
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc238。
(1) left_step表示到目前為止這個點有幾個人花的總共步數。
    left_cnt表示到目前為止有幾個1。
    right亦同。

///////////////////////////////////////////////////////////////
//
// lc1772. Sort Features by Popularity
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use stable sort with map and set

///////////////////////////////////////////////////////////////
//
// lc1773. count items matching a rule
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count

///////////////////////////////////////////////////////////////
//
// lc1784. Check if Binary String Has at Most One Segment of Ones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為起始必為1，找到01就是代表第二個1。
(2) 從尾巴跑遇到1停，繼續跑，遇到不是0停，如果idx != -1表示有兩個以上1 block。
(2) 找邊界數量，找理說只有兩個。

///////////////////////////////////////////////////////////////
//
// lc1796. Second Largest Digit in a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用兩個變數維持最大和第二大

///////////////////////////////////////////////////////////////
//
// lc1800. Maximum Ascending Subarray Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到數字比當前小就將sum = 當前數字。

///////////////////////////////////////////////////////////////
//
// lc1816. Truncate Sentence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count words

///////////////////////////////////////////////////////////////
//
// lc1822. Sign of the Product of an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count # of negative sing 

///////////////////////////////////////////////////////////////
//
// lc1824. Minimum Sideway Jumps (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) dijkstra
(2) bfs
(3) dp
    dp[0] dp[1] dp[2] 表示第ith lane最小方法數
    所以 dp[i] = min(dp[i], min(dp[i+1],dp[i+2])+1)

///////////////////////////////////////////////////////////////
//
// lc1827. Minimum Operations to Make the Array Increasing
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find diff between neighbor

///////////////////////////////////////////////////////////////
//
// lc1832. Check if the Sentence Is Pangram
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) set
(2) bit

///////////////////////////////////////////////////////////////
//
// lc1836. Remove Duplicates From an Unsorted Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本linked list operation

///////////////////////////////////////////////////////////////
//
// lc1839. Longest Substring Of All Vowels in Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到字母差值規律，用two pointer。

///////////////////////////////////////////////////////////////
//
// lc1844. Replace All Digits with Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string operation

///////////////////////////////////////////////////////////////
//
// lc1859. Sorting the Sentence
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) use pair to store index
(2) linear filling with the index

///////////////////////////////////////////////////////////////
//
// lc1869. Longer Contiguous Segments of Ones than Zeros
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer維持最大連續一樣的邊界。

///////////////////////////////////////////////////////////////
//
// lc1874. Minimize Product Sum of Two Arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort
(2) sort

///////////////////////////////////////////////////////////////
//
// lc1871. Jump Game VII (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bfs，對於當前位置i，
    起始點是要left = max(i+minJump, max_start+1)
    結束點是要right = min(i+maxJump, n-1)
    而max_start = right，因為這樣可以不visit一些之前就visit過的點。
    time: O(n*(maxjump-minjump))

(2) 表示到目前為止可以到的步數
    pre += dp[i-minjump]
    pre -= dp[i-maxjump-1]
    dp[i] = dp > 0 && s[i] == '0'
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1877. Minimize Maximum Pair Sum in Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort then two pointer

///////////////////////////////////////////////////////////////
//
// lc1893. Check if All the Integers in a Range Are Covered
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc253。
(1) 找出區間起始點+1，結束點的後一個減一。
    time: O(n+m)
    space: O(m)
(2) sort and find if current value in the range
    if yes, update to range[1]+1
    time: O(nlogn)

///////////////////////////////////////////////////////////////
//
// lc1897. Redistribute Characters to Make All Strings Equal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count, bucket

///////////////////////////////////////////////////////////////
//
// lc1902. Depth of BST Given Insertion Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map去找左和右最近的高度
    nlogn

///////////////////////////////////////////////////////////////
//
// lc1903. Largest Odd Number in String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find last odd number

///////////////////////////////////////////////////////////////
//
// lc1905. Count Sub Islands
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion