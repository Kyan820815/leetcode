///////////////////////////////////////////////////////////////
//
// lc030. Substring with Concatenation of All Words (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 

///////////////////////////////////////////////////////////////
//
// lc214. Shortest Palindrome (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc459。

///////////////////////////////////////////////////////////////
//
// lc1163. Last Substring in Lexicographical Order (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) l: max subarray start index
    r: current subarray start index
    去找到第一個 s[l+d] < s[r+d]，update l = max(l+d+1, r)
    為什麽不只要l = r，因為 'aaaaac'，l = l+d+1可以直接跳到c，節省時間，
    且r = l+1，從下一個位置開始重新搜尋。
    若s[l+d] > s[r+d]，update r += d+1，從這個位置開始重新搜尋，前面
    一定都比s[l+d]小。
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1200. Minimum Absolute Difference
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，因為要找最小difference的所有組合，一定是相鄰兩個去做比較。

///////////////////////////////////////////////////////////////
//
// lc1202. Smallest String With Swaps (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find with path compression，compare with union size。
    將同一union的index放在一起，由小到大，然後sort後一一填入。

///////////////////////////////////////////////////////////////
//
// lc1207. Unique Number of Occurrences
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算每個數字出現次數。

///////////////////////////////////////////////////////////////
//
// lc1209. Remove All Adjacent Duplicates in String II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) stack iteration，類似lc723。
follow up: >= k
    (a) 先檢查若跟最後一個不一樣，判斷最後一個有沒有>=k，若有，pop
    (b) 再來判斷最後一個有沒有和自己一樣，若有cnt++，若沒有，push {1}。
    (c) 結束loop後檢查最後一個有沒有>=k，若有pop。
    注意只有在遇到和最後一個不同才去檢查有沒有>=k因為要一次移除所有相同的。

///////////////////////////////////////////////////////////////
//
// lc1213. Intersection of Three Sorted Arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當三個不一樣時，找出最大值，update其他兩個到至少比最大值大或相等。

///////////////////////////////////////////////////////////////
//
// lc1214. Two Sum BSTs (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 用stack做inorder traversal，類似lc1305。
(2) 用recursion，確認當前有沒有符合，若沒有，往左和往右去找。

///////////////////////////////////////////////////////////////
//
// lc1217. Play with Chips
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為移動一格為cost 1，移動兩格cost 2，所以若都是奇數位置或偶數位置，cost = 0，
    因此計算odd & even次數，reutrn min(odd, even)。

///////////////////////////////////////////////////////////////
//
// lc1219. Path with Maximum Gold
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 一般dfs。

///////////////////////////////////////////////////////////////
//
// lc1221. Split a String in Balanced Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算左右值，相消=0，res++。

///////////////////////////////////////////////////////////////
//
// lc1222. Queens That Can Attack the King
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 8 direction check

///////////////////////////////////////////////////////////////
//
// lc1227. Airplane Seat Assignment Probability (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) f(n) = 1/n + 1/n * (n-2) * f(n-1)。
    (a) the 1st person gets his/her own seat. (with probability 1/n). 
        Then the n-th person is sure (with probability 1) to get the n-th seat.
    (b) the 1st person gets the n-th person's seat. (with probability 1/n). 
        Then the n-th person cannot (with probability 0) get the n-th seat.
    (c) the 1st person gets a seat between 2 and n-1 (with probability (n-2)/n). 
        Assume the 1st person gets a-th seat. Then in the next round, we have 3 choices again:
    3.1) if the a-th person gets 1st seat (with probability 1/(n-1)), 
         then this is just like 1st and a-th person swap their seats, 
         it never affect our result for the n-th person.
    3.2) if the a-th person gets n-th seat (with probability 1/(n-1)), 
         game over.
    3.3) if the a-th person gets a seat which is not 1st or n-th, 
         (with probability (n-1-2)/(n-1)), we jump into a loop.
(2) 利用數學歸納法得證 n > 1，f(n) = 0.5。

///////////////////////////////////////////////////////////////
//
// lc1228. Missing Number In Arithmetic Progression (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n) search
(2) binary search，利用a[0]+mid*d == a[mid]來判斷從0到mid為止有沒有都
    等差。
    d = (arr.back()-arr[0])/arr.size()。

///////////////////////////////////////////////////////////////
//
// lc1229. Meeting Scheduler
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找opverlap
    max(start1, start2) <= min(end1, end2)

///////////////////////////////////////////////////////////////
//
// lc1230. Toss Strange Coins
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n^2) space
(1) O(n) space

///////////////////////////////////////////////////////////////
//
// lc1231. Divide Chocolate (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，類似lc410, lc1011。
    注意和上面兩題不同的是，我們要找minimum of subarray sum
    上面兩題找得是maximum of subarray sum
    We want each cut size >= mid. 
    We are binary searching minimum total sweetness.

///////////////////////////////////////////////////////////////
//
// lc1232. Check If It Is a Straight Line
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 斜率轉換，avoid divide by zero condition。
                (y2-y1) / (x2 - x1) == (y3-y2) / (x3 - x2) 
    is equal to 
                (y2-y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)

///////////////////////////////////////////////////////////////
//
// lc1234. Replace the Substring for Balanced String (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window
    若要變成balance array，想像一個window，若outside window的數量都比
    n/4小，表示裡面可以任意改動成balanced，所以要找最小的subarray，且
    這個subarray的外面四個字元都 <= n/4。
    time：O(n)
    space：O(1)

///////////////////////////////////////////////////////////////
//
// lc1235. Maximum Profit in Job Scheduling (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一map<int,int> dp表示map[time] = profit，到time為止最大profit
    對endtime, starttime, profit, 做sort
    對當前job，找到上一個time <= job.starttime, use prev(upper_bound)
    
    **  不用lower_bound是因為，若當前沒有job.starttime in dp，要用prev，若有，
        不能用prev，但用upper_bound，只要prev(upper_bound)就可以解決，
        類似lc1146。
    
    cur = dp[last_time] + job.profit
    若cur > dp.rbegin()->profit then dp[job.endtime] = cur;

///////////////////////////////////////////////////////////////
//
// lc1236. Web Crawler
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion

///////////////////////////////////////////////////////////////
//
// lc1243. Array Transformation (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，紀錄nums[i]為prev，作為下一輪使用。

///////////////////////////////////////////////////////////////
//
// lc1244. Design A Leaderboard
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用兩個map，一個set of pair，記錄每個分數和他的名字，
    另一個key:名字，value:分數。

///////////////////////////////////////////////////////////////
//
// lc1245. Tree Diameter
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 類似lc310，維持當前還沒用的剩餘node，while (n > 1)，若剩1表示2*res，
    對稱的。
    若n = 0，表示不對稱，2*res - 1。

(2) 計算以每個node為root的最大path，且不能走過parent node的點，不然會無窮
    迴圈。

///////////////////////////////////////////////////////////////
//
// lc1247. Minimum Swaps to Make Strings Equal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 收集xy和yx pattern，因為要最小的swap，先去看xy自己能不能組完，yx也是，
    也就是res += (xy/2 + yx/2)，再來 xy % 2 和 yx % 2 表示用剩下來的，
    這一定是0個或1個，若只有其中是一個，return -1，若兩個都是1，表示可以swap，
    方法數 = 2，兩個都是0，維持原狀。

///////////////////////////////////////////////////////////////
//
// lc1248. Count Number of Nice Subarrays (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

類似lc992。
(1) use atmost(k) - atmost(k-1)
    O(1) space，two pass
(2) 992 method 2。
    O(1) space，one pass
(3) 維持一個max size k的queue，表示當前odd num的index。
    若size == k，res += que.front()-last+1。
    若size > k，last = que.front()+1，que.pop()。
    O(k) space，one pass

///////////////////////////////////////////////////////////////
//
// lc1249. Minimum Remove to Make Valid Parentheses (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc301。

(1) stack iteration，將不合法得改成'*'。

///////////////////////////////////////////////////////////////
//
// lc1252. Cells with Odd Values in a Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(m*n + l)，l: length of indeces
    紀錄出現過的row和col次數，遍歷一次matrix，看當前的row和col的合是不是odd。

(2) O(m + n + l)，計算被點到odd次數的row數量和col數量
    return even_row * odd_col + even_col * odd_row。

///////////////////////////////////////////////////////////////
//
// lc1254. Number of Closed Islands
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 做dfs，碰到邊就return 1。
(2) 先將四邊做dfs，再對內部做dfs。

///////////////////////////////////////////////////////////////
//
// lc1257. Smallest Common Region (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立tree map，from bottom to top，然後建立visit map，把region1 走過的
    都插入，再來traverse region2 parent path，若任一點在visit有看過，r
    return這一點。
(2) 建立tree map，from top to bottom，再來用一般lowest common ancestor
    去做。

///////////////////////////////////////////////////////////////
//
// lc1260. Shift 2D Grid
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算出最終column位置 by i+shift，shift = k % col
    計算共同往下shift的變數times = k / col。
    shift也可代表額外往下shift 1 的個數，從col-1往前shift個column都要額外
    往下shift 1。

///////////////////////////////////////////////////////////////
//
// lc1261. Find Elements in a Contaminated Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use bit set，save memory。
(2) use hash set

///////////////////////////////////////////////////////////////
//
// lc1265. Print Immutable Linked List in Reverse (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

(1) 一般recursion解法
(2) 先計算一次list長度，再利用雙loop迴圈，每次印最後一個node的value。
(3) 將node存到size為sqrt(n)的stack。

///////////////////////////////////////////////////////////////
//
// lc1266. Minimum Time Visiting All Points
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，因為若兩者有差，會走完共同的，然後再多走差的數量，這就表示
    兩者之間走的距離就是max(diffx, diffy)。

///////////////////////////////////////////////////////////////
//
// lc1268. Search Suggestions System (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 先將string lexicographically排序，這樣會有一個性質：
    如果a[i] is prefix of a[j] -> a[i] is prefix of x, x from i+1~j-1。
    所以我們從上一次起始點 last_start 往後開始搜尋第一個word >= search word，
    也就是new_start，開始搜尋，然後更新start place from last_start to new start。
    time: O(log(N)) for each query
(2) 直接用set，lower_bound為 O(log(N))

///////////////////////////////////////////////////////////////
//
// lc1271. Hexspeak
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) turn string into long long int and transformed into hex type。

///////////////////////////////////////////////////////////////
//
// lc1272. Remove Interval
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc986。
    對於有交集的，找出沒有在remove interval中的，分三case
    a. 沒交集
    b. 交集且interval[0] < start
    c. 交集且interval[1] > end

///////////////////////////////////////////////////////////////
//
// lc1273. Delete Tree Nodes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從nodes-1跑到1，value[parent[i]] += vallue[i]。
    且res[i]，表示當前i為root的subtree中所有不能抵消的點。
    若value[i] != 0，要把這些點給parent[i]。
    即res[parent[i]] += res[i]。
(2) build tree，跑一遍postorder，若sum == 0，return nodes = 0。

///////////////////////////////////////////////////////////////
//
// lc1274. Number of Ships in a Rectangle
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: T(n) = 4*T(n/4)+c = O(n)
    注意邊界問題。

///////////////////////////////////////////////////////////////
//
// lc1275. Find Winner on a Tic Tac Toe Game
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc348。

///////////////////////////////////////////////////////////////
//
// lc1277. Count Square Submatrices with All Ones (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc221。
    dp[i][j] means the size of biggest square with A[i][j] as bottom-right corner.
    dp[i][j] also means the number of squares with A[i][j] as bottom-right corner.
    O(n^2)
(2) 用prefix sum，O(n^3)，類似lc1314。

///////////////////////////////////////////////////////////////
//
// lc1279. Traffic Light Controlled Intersection (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1188，但不用conditional variable。

///////////////////////////////////////////////////////////////
//
// lc1281. Subtract the Product and Sum of Digits of an Integer 
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) val %= n，sum += val，product *= val。

///////////////////////////////////////////////////////////////
//
// lc1282. Group the People Given the Group Size They Belong To (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持gp(n+1)，
    對於group size，如 = 3，將 = 3的idx收集，直到gp[3].size() == 3，然後push到
    res，並清空gp[3]，這樣就可以依序將所有同一個group size的人收集。
(2) sort idx by group size，一一填入。

///////////////////////////////////////////////////////////////
//
// lc1283. Find the Smallest Divisor Given a Threshold
//
///////////////////////////////////////////////////////////////

最佳解： method 1
類似875
(1) binary search，left = 1, right = max(nums)
    time: O(nlog(right))
    注意round up，可以用(nums[i]+val-1) / val。

///////////////////////////////////////////////////////////////
//
// lc1287. Element Appearing More Than 25% In Sorted Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(logN)，binary search，找出candiate first location & last location。
    類似lc33。
(2) 因為是sorted且只有一個arr[i] cnt > 25%，對每個arr[i]去檢查
    若arr[i] == arr[i+n/4]，表示arr[i]數量>25%。

///////////////////////////////////////////////////////////////
//
// lc1290. Convert Binary Number in a Linked List to Integer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit manipulation

///////////////////////////////////////////////////////////////
//
// lc1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum
    O(m*n)
    若當前i~i-len且j~j-len的方形 <= threshold，len++。
(2) prefix sum + binary search to find max side length
    O(m*n*log(m+n))

///////////////////////////////////////////////////////////////
//
// lc1293. Shortest Path in a Grid with Obstacles Elimination (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dijkstra
    time: O(kmn log kmn)
(2) bfs
    time: O(kmn)

///////////////////////////////////////////////////////////////
//
// lc1295. Find Numbers with Even Number of Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 因為maxv為10^5，可以直接用區兼職判斷，O(n)
(2) digit by digit check，O(n*k)，k為number of digit for each nums[i]

///////////////////////////////////////////////////////////////
//
// lc1296. Divide Array in Sets of K Consecutive Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

類似lc659。

(1) unordered_map
    time: O(nlogn+kn)
(2) map
    time: O(kmlogm+nlogm)

///////////////////////////////////////////////////////////////
//
// lc1299. Replace Elements with Greatest Element on Right Side (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後面走回去，維持一個最大值。

///////////////////////////////////////////////////////////////
//
// lc1302. Deepest Leaves Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs
(2) queue iteration，bfs。

///////////////////////////////////////////////////////////////
//
// lc1303. Find the Team Size
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) partition

///////////////////////////////////////////////////////////////
//
// lc1304. Find N Unique Integers Sum up to Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 不要用1+2+...+n-1，因為如果n很大會overflow，
    find rule。
    2*i - (n-1)

///////////////////////////////////////////////////////////////
//
// lc1305. All Elements in Two Binary Search Trees (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1214，two stack inorder traversal。
(2) 將node value放入res然後sort

///////////////////////////////////////////////////////////////
//
// lc1306. Jump Game III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1309. Decrypt String from Alphabet to Integer Mapping
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string processing

///////////////////////////////////////////////////////////////
//
// lc1311. Get Watched Videos by Your Friends
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs + sort。

///////////////////////////////////////////////////////////////
//
// lc1313. Decompress Run-Length Encoded List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本array operation。

///////////////////////////////////////////////////////////////
//
// lc1314. Matrix Block Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc1292。
(1) 先算出dp[i][j]，表示(0,0)到(i,j)的總和
    再來res[i][j] = res[i+k][j+k] - res[i+k][j-k-1] 
                                 - res[i-k-1][j+k] 
                                 + res[i-k-1][j-k-1]

///////////////////////////////////////////////////////////////
//
// lc1315. Sum of Nodes with Even-Valued Grandparent
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，類似lc337。

///////////////////////////////////////////////////////////////
//
// lc1317. The K Weakest Rows in a Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) binary search + priority queue。
    O(m*(logn + logm) + klogm)
(2) binary search + set。
    O(m*(logn + logm) + k)

///////////////////////////////////////////////////////////////
//
// lc1319. Number of Operations to Make Network Connected
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find

///////////////////////////////////////////////////////////////
//
// lc1325. Delete Leaves With a Given Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder。

///////////////////////////////////////////////////////////////
//
// lc1329. Sort the Matrix Diagonally (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 可以將dig分類成用i-j歸類
    time: O(m*nlogd), d = min(m,n)
    space: O(m*n)
(2)
    time: O(m*n + (m+n)*(dlogd)), d = min(m,n)
    space: O(d)

///////////////////////////////////////////////////////////////
//
// lc1331. Rank Transform of an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort index，add to result array。

///////////////////////////////////////////////////////////////
//
// lc1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs
(2) Floyd Warshall

///////////////////////////////////////////////////////////////
//
// lc1337. The K Weakest Rows in a Matrix
//
///////////////////////////////////////////////////////////////

(1) bucket sort
    O(m*n + max(k, 100))
(2) binary search + priority queue。
    O(m*(logn + logm) + klogm)
(3) binary search + set。
    O(m*(logn + logm) + k)

///////////////////////////////////////////////////////////////
//
// lc1338. Reduce Array Size to The Half
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bucket sort
(2) priority queue

///////////////////////////////////////////////////////////////
//
// lc1339. Maximum Product of Splitted Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 兩次postorder，第一次算總和，第二次算乘積最大值。

///////////////////////////////////////////////////////////////
//
// lc1340. Jump Game V (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dag + dfs
    time: O(n)
    利用降序stack建立dag
    因為 4 2 1 5 6，d = 2
    5->1, 5->2
    6->5，其實6->1但因為這條不會是最深的，(6->5->1)在做降序sk時自動過濾掉這條
    往右降序可以把所有i左邊的都加進去，往左降序可把所有u的右邊都加進去。

    在build dag最一般就是O(nd)，但這樣會加入一些冗邊，向上面的利子，這些邊
    都不會在最深路徑裡。

    最後做dfs找最深路徑。

///////////////////////////////////////////////////////////////
//
// lc1342. Number of Steps to Reduce a Number to Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation

///////////////////////////////////////////////////////////////
//
// lc1345. Jump Game IV (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，注意走過的點，該val一定走過，所以可以將其整個vector都清空，避免再走一次。

///////////////////////////////////////////////////////////////
//
// lc1346. Check If N and Its Double Exist
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find pair of nums[i]*2 or nums[i]/2。

///////////////////////////////////////////////////////////////
//
// lc1347. Minimum Number of Steps to Make Two Strings Anagram
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算s的出現次數，扣除t的出現次數，若有負的，表示需要轉換的，把負的加總
    即為答案。
(2) 維持兩個cnt，取min(cnt1[i], cnt2[i])，表示絕對不用換的字母，加總res
    return s.size() - res。

///////////////////////////////////////////////////////////////
//
// lc1348. Tweet Counts Per Frequency (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

* n: # of record for one tweet

(1) 利用multiset<int>，lower_bound找出第一個>=startime的position
    recordTweet time: O(logn)
    getTweetCountsPerFrequency: O(logn) + O(# of record between startTime and endTime)

(2) vector<int>，linear find。
    recordTweet time: O(1)
    getTweetCountsPerFrequency: O(n)

///////////////////////////////////////////////////////////////
//
// lc1350. Students With Invalid Departments
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) left join
(2) not in, not good when data size is large

///////////////////////////////////////////////////////////////
//
// lc1351. Count Negative Numbers in a Sorted Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc74。
(1) O(m+n)，因為row & col sorted，從右上角開始往左下角走。

///////////////////////////////////////////////////////////////
//
// lc1352. Product of the Last K Numbers (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix product，類似prefix sum
    若遇到0，將arr = {1}。
    若k >= arr.size() ? 0 : arr.back()/arr[arr.size()-k-1];

///////////////////////////////////////////////////////////////
//
// lc1353. Maximum Number of Events That Can Be Attended (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort events。
    利用min priority queue，維持一d表示當前available time，
    將所有start == d 的end加入queue，並檢查queue中的end若 < d，都pop。

///////////////////////////////////////////////////////////////
//
// lc1356. Sort Integers by The Number of 1 Bits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count bits，計算有幾個一有兩種做法：
    (a) cnt += n&1, n >>= 1
    (b) cnt++, n = n&(n-1)

///////////////////////////////////////////////////////////////
//
// lc1358. Number of Substrings Containing All Three Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1248 method 2。

///////////////////////////////////////////////////////////////
//
// lc1359. Count All Valid Pickup and Delivery Options (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) for n-1 pairs, the first one can be inserted into 2*(n-1)+1
    positions, and the second one can be inserted into 2*n positions
    so # of methods are (2*n-1) * 2*n
    因為有順序，要/2，所以為 (2n-1)*n。

///////////////////////////////////////////////////////////////
//
// lc1361. Validate Binary Tree Nodes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs
(2) dfs

///////////////////////////////////////////////////////////////
//
// lc1365. How Many Numbers Are Smaller Than the Current Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bucket sort，bucket[i]表示所有比i小的數量總和。
    time: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1366. Rank Teams by Votes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每個ch計算得到的votes數量。
    m: # of votes, n: # of teams
    count votes: O(m*n)
    sort: O(n^2logn)

///////////////////////////////////////////////////////////////
//
// lc1367. Linked List in Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前點，直接對link list往下找，若都找到reutrn true，不然就遞迴。

///////////////////////////////////////////////////////////////
//
// lc1368. Minimum Cost to Make at Least One Valid Path in a Grid
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two bfs queue
(2) dijkstra

///////////////////////////////////////////////////////////////
//
// lc1370. Increasing Decreasing String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) buckeet sort。

///////////////////////////////////////////////////////////////
//
// lc1372. Longest ZigZag Path in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，維持當前node是parent的left還是right direction。
    若是left，則取自己right child return的value，反之。

///////////////////////////////////////////////////////////////
//
// lc1376. Time Needed to Inform All Employees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs
(2) dfs
(3) direct traversal

///////////////////////////////////////////////////////////////
//
// lc1378. Replace Employee ID With The Unique Identifier
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) left join

///////////////////////////////////////////////////////////////
//
// lc1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1380. Lucky Numbers in a Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space
    let A(i,j) be the min of row i, max of col j,
    if there exists another A(i',j') as lucky number,
    (1) A(i',j') > A(i,j') > A(i, j)
    (2) A(i',j) > A(i',j')
    so A(i',j) > A(i,j)
    based on lucky number definition, its a contradiction,
    so there exists only one lucky number in a matrix.

(2) O(m+n) space，維持rowv，colv表示該row的最小值和該col的最大值。

///////////////////////////////////////////////////////////////
//
// lc1381. Design a Stack With Increment Operation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用inc array，inc[i]，表示需要加到0~i，當前若pop，inc[i-1] += inc[i]
    並且將pop value += inc[pop index]。
    time: O(1)。
    space: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1382. Balance a Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) inorder + postorder
    time: O(n)，space: O(n)

follow up: O(1) space DSW algo
https://leetcode.com/problems/balance-a-binary-search-tree/discuss/541785/C%2B%2BJava-with-picture-DSW-O(n)orO(1)
** dont need to write code but briefly explain how it works
(a) Convert the initial tree into a vine. By doing right rotations, 
    we flatten a tree into a 'linked list', where the head is the former leftmost node, and tail - former rightmost node.
(b) As you convert the tree into a vine, count the total number of nodes in cnt.
(c) Calculate the height of the closest perfectly balanced tree: h = log2(cnt + 1).
(d) Calculate the number of nodes in the closest perfectly balanced tree: m = pow(2, h) - 1.
(e) Left-rotate cnt - m nodes to cover up the excess of nodes.
Note: you rotate the root node, then you rotate the right child of the new root node, 
and so on. In other words, left rotations are performed on every second node of the vine.

(f)Left-rotate m / 2 nodes.
(g) Divide m by two and repeat the step above while m / 2 is greater than zero.

///////////////////////////////////////////////////////////////
//
// lc1385. Find the Distance Value Between Two Arrays (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(m*n)，brute force
(2) O(nlogn)，先sort，
    i 表示當前index in arr1，j表示對於到目前為止的i，都0~j-1和0~i相差都>d。
    結束loop時，看i~n1-1都要放入res。

///////////////////////////////////////////////////////////////
//
// lc1387. Sort Integers by The Power Value
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) built-in sort function
(2) quick select

///////////////////////////////////////////////////////////////
//
// lc1389. Create Target Array in the Given Order (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(nlogn)，類似lc315。
    想像一下，題目要求，i < j，index[i] >= index[j]，則index[i]要往右移一位。
    可以用divide and conquer，依照最終index去做排序。
    if (index[i] + shift >= index[j]) {
        res.push_back(index[j])
        shift += 1 --> 這裡表示因為index[j]要插在index[i]前面，shift要加一。
    } else {
        res.push_back(index[i]+shift) --> update index[i]最終位置，並且
                                          放到res裡。
    }
(2) O(n^2)，一般insertion方法。將i開始全都往後移一位。

///////////////////////////////////////////////////////////////
//
// lc1391. Check if There is a Valid Path in a Grid (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前，先到下一點，再對下一點back回去，若可以回到當前點，表示下一點
    是合法圖形。
    用visit來判斷下一點有沒有走過，若有就跳過。加入queue就標記走過。

///////////////////////////////////////////////////////////////
//
// lc1394. Find Lucky Integer in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1395. Count Number of Teams (看)*
//
///////////////////////////////////////////////////////////////

(1) O(n^3)，暴力解。
(2) 對於每個candidate，跑一次回圈
    維持兩個變數vector<int> less, greater。
    less[0]表示在左邊比自己小，less[1]表示在右邊比自己小。
    greater[0]表示在左邊比自己大，greater[1]表示在右邊比自己大。
    res = less[0] * greater[1] + greater[0] * less[1]。

///////////////////////////////////////////////////////////////
//
// lc1396. Design Underground System (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 考慮edge case，利用map紀錄，key: start_end，value: {total_time, cnt}
    第二個map是個人資料，key: id，value: {start, start_time}

///////////////////////////////////////////////////////////////
//
// lc1399. Count Largest Group
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count digit。

///////////////////////////////////////////////////////////////
//
// lc1403. Minimum Subsequence in Non-Increasing Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。
(2) nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1408. String Matching in an Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

k average len of a word

(1) prefix trie tree
    time: O(nk^2)
    將每一個word從 word.substr(i)全部insert到trie tree中，
    並且經過的點end++，這樣代表之後我們搜尋這個word，若走到底後end > 1，
    表示至少有一個除了自己以外的word的substring是這個word。
(2) sort and find n^2
    time: O(nlogn+n^2*k)

///////////////////////////////////////////////////////////////
//
// lc1409. Queries on a Permutation With Key (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lru cache的方式去做，O(n^2)
(2) 利用bit，binary index tree。
(3) 利用segment tree。
    (2) 和 (3)都想像成range sum，arr[0,i]表示0~i的個數，也就是對於i+1位置
    中，前面有幾個number。
    因為題目要求當前number是在arr中第幾個位置，想像成每個位置都是1，那就是說
    given index i，他前面的數量就是rangesum(0,i-1)。
    另外用map紀錄number和其對應在arr的位置。

///////////////////////////////////////////////////////////////
//
// lc1413. Minimum Value to Get Positive Step by Step Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為在每個for loop step sum > 0，表示追蹤minimum sum of for loop，
    return -minv + 1。
(2) 對於每輪若sum < 1，補足到1，即 res += 1-sum。

///////////////////////////////////////////////////////////////
//
// lc1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

greedy method。
always find the largest one less than K。
(1) recursion
    Time O((logk)^2), since O(log k) Fibonacci numbers smaller than k.
    Space O(logK), can be saved by tail recursion.
(2) iteration
    Time O((logk))
    Space O(1)

///////////////////////////////////////////////////////////////
//
// lc1422. Maximum Score After Splitting a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) maxv = zeros_left + ones_right
         = zeros_left + ones_total - ones_left
         = zeros_left - ones_left + ones_total
    所以 maxv = max(maxv, zeros_left - ones_left)
    return maxv + ones_total

///////////////////////////////////////////////////////////////
//
// lc1423. Maximum Points You Can Obtain from Cards (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) sliding window，維持n-k大小的window，找最小。
    time: O(n)
(2) sliding window，先算出左邊開始大小為k總和: left
    然後跑一個k for loop，
    left -= arr[k-1-i];
    right += arr[n-1-i];
    res = max(res, left+right)
    這表示每次從left扣掉一個，right加上一個，維持大小為k的兩邊總和
    time: O(k)

///////////////////////////////////////////////////////////////
//
// lc1425. Constrained Subsequence Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc239。
(1) 用一降序deque。
    time: O(n), space: O(k)
(2) 用一priority queue，max heap。
    time: O(nlogK), space: O(K)

///////////////////////////////////////////////////////////////
//
// lc1427. Perform String Shifts
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string concatenation

///////////////////////////////////////////////////////////////
//
// lc1428. Leftmost Column with at Least a One
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(rlog(c))，binary search
(2) O(r+c)，類似lc240。

///////////////////////////////////////////////////////////////
//
// lc1429. First Unique Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc146 lru，用list和map紀錄list得iterator。
    find first unique: O(1)
(2) 用queue和map，map紀錄出現次數，若為1，push to que。
    find first unique: O(n)

///////////////////////////////////////////////////////////////
//
// lc1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1431. Kids With the Greatest Number of Candies
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find maxv then check if candies[i] + extra >= maxv。

///////////////////////////////////////////////////////////////
//
// lc1433. Check If a String Can Break Another String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，從0~25，計算兩者當前數量，若次數交錯，表示不能break。
(2) nlogn sort

///////////////////////////////////////////////////////////////
//
// lc1436. Destination City
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass，第一次把start place加進去，第二次對於end place看有沒有在
    set裡。

///////////////////////////////////////////////////////////////
//
// lc1437. Check If All 1's Are at Least Length K Places Away
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find last index with a[idx] == 1 and check if 
    i-idx-1 < k or not。

///////////////////////////////////////////////////////////////
//
// lc1441. Build an Array With Stack Operations
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) When we find target[i] is greater than current number, 
    just push and pop and update it until they are equal.

///////////////////////////////////////////////////////////////
//
// lc1443. Minimum Time to Collect All Apples in a Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) build graph first, start from 0, use dfs.
    We add 2 to res when we have collect all return value from
    our descendents that sum is bigger than 0 or current node is an apple.

///////////////////////////////////////////////////////////////
//
// lc1446. Consecutive Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count length

///////////////////////////////////////////////////////////////
//
// lc1448. Count Good Nodes in Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。
(2) preorder。

///////////////////////////////////////////////////////////////
//
// lc1450. Number of Students Doing Homework at a Given Time
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本判斷interval。

///////////////////////////////////////////////////////////////
//
// lc1457. Pseudo-Palindromic Paths in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation，利用xor兩個  1
(2) set，利用set只有唯一性的特性來判斷set <=1，是的話就是回文。

///////////////////////////////////////////////////////////////
//
// lc1460. Make Two Arrays Equal by Reversing Sub-arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bucket sort
(2) a. use xor to check if bit counting is same between arr and target.
    b. check if target sum is equal to arr sum.

///////////////////////////////////////////////////////////////
//
// lc1462. Course Schedule IV
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion

///////////////////////////////////////////////////////////////
//
// lc1464. Maximum Product of Two Elements in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use pointer to linear find

///////////////////////////////////////////////////////////////
//
// lc1466. Reorder Routes to Make All Paths Lead to the City Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用rel map來判斷當前邊的關係，比如 a->b，
    rel[a].push_back({b, 1})
    rel[b].push_back({a, 0})
    這樣在做bfs就可以知道若連過去的是1，++res。

///////////////////////////////////////////////////////////////
//
// lc1469. Find All The Lonely Nodes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用tag來判斷當前node是不是lonley，
    ex: preorder(root->left, !root->right)
    ex: preorder(root->right, !root->left)

///////////////////////////////////////////////////////////////
//
// lc1470. Shuffle the Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit manipulation，把後半端作為cache，儲存前半段的所有數字，
    nums[i] = nums[j] >> 10;
    nums[i+1] = nums[j] & 1023;

///////////////////////////////////////////////////////////////
//
// lc1471. The k Strongest Values in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointers
(2) two pointers with erase

///////////////////////////////////////////////////////////////
//
// lc1472. Design Browser History
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2，3

(1) two stack，history & future，注意history size 必須大於1。
    visit時，future clear.
(2) list，維持now & end，注意visit，如果++now >= arr.size()，push_back()
    否則，arr[now] = url
(3) unordered_map
    visit: map[++now] = url, end = now

///////////////////////////////////////////////////////////////
//
// lc1474. Delete N Nodes After M Nodes of a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one pass，對於n，now->next = now->next->next。這樣now不用動但可以
    一直接下一個。

///////////////////////////////////////////////////////////////
//
// lc1475. Final Prices With a Special Discount in a Shop
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) stack iteration，維持一個升序stack。

///////////////////////////////////////////////////////////////
//
// lc1477. Find Two Non-overlapping Sub-arrays Each With Target Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum，往左找到第一個arry後，再往右去找第二個array。
    並且每次都更新左邊的array長度。
    類似lc560。
(2) sliding window
    dp[i] = 到目前為止最短的array，
    res = min(res, dp[i-1] + right-left+1)
    且 維持一個變數表示到目前為止最短的array: best_so_far
    dp[right] = best_so_far。

///////////////////////////////////////////////////////////////
//
// lc1480. Running Sum of 1d Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 單純累加上一位的值。

///////////////////////////////////////////////////////////////
//
// lc1481. Least Number of Unique Integers after K Removals
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

類似lc347

(1) sort
    O(n + nlogn), space: O(logn)
(2) priority queue
    time: O(n + ulogu + mlogu), space: O(logu)
(3) bucket
    time: O(n), space O(n)

///////////////////////////////////////////////////////////////
//
// lc1485. Clone Binary Tree With Random Pointer
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 類似lc138，O(1) space, three pass，必須NodeCopy class和Node class
    一致才行
(2) 利用map，O(n) space, one pass。

///////////////////////////////////////////////////////////////
//
// lc1486. XOR Operation in an Array (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，對於start = 0, 1, 2, 4, n = 1, 1, 2, 3, .... 8

start = 0, 1, n = 1~8
[N % 4 == 1] Green Row: Ans = Number[N]
[N % 4 == 2] Yellow Row: Ans = 2
[N % 4 == 3] Red Row: Ans = Number[N] ^ 2
[N % 4 == 0] Blue Row: Ans = 0

start = 2, 3, n = 1 ~ 8
N % 4 == 1] Green Row: Ans = Number[1]
[N % 4 == 2] Yellow Row: Ans = Number[N] ^ Number[1]
[N % 4 == 3] Red Row: Ans = Number[1] ^ 2
[N % 4 == 0] Blue Row: Ans = Number[N] ^ Number[1] ^ 2

https://leetcode.com/problems/xor-operation-in-an-array/discuss/699141/Visual-Solution-Python-or-O(1)-Time-or-O(1)-Space

///////////////////////////////////////////////////////////////
//
// lc1490. Clone N-ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc133
(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1491. Average Salary Excluding the Minimum and Maximum Salary
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find

///////////////////////////////////////////////////////////////
//
// lc1492. The kth Factor of n
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sqrt processing

///////////////////////////////////////////////////////////////
//
// lc1493. Longest Subarray of 1's After Deleting One Element
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) maintain a sliding window with at most 1 zero.

///////////////////////////////////////////////////////////////
//
// lc1494. Parallel Courses II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 

///////////////////////////////////////////////////////////////
//
// lc1496. Path Crossing
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用set紀錄走過的。 

///////////////////////////////////////////////////////////////
//
// lc1498. Number of Subsequences That Satisfy the Given Sum Condition
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window

///////////////////////////////////////////////////////////////
//
// lc1502. Can Make Arithmetic Progression From Sequence (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) time, O(1) space
    類似lc041。
    因為要找diff，可以先找到maxv, minv算出diff
    跑一個回圈，對於是自己的點，跳過(++idx)，若不是自己的點，算位置，若沒辦法算，
    return false，最後得到自己得pos，若pos < idx，表示這個點和之前已找到的點一樣，表示重複
    ，但不可能重複，除非diff = 0，所以return false，不然arr[idx] == arr[pos]，這也表示i>pos，
    也要return false，因為如果一樣，diff會=0，一開始就跳過(++idx)，diff!=0但又有
    arr[idx] == arr[pos]表示idx != pos，會造成無窮迴圈，
    最後swap(arr[idx], arr[pos])。

(2) O(nlogn) time, O(logn) space
    sort then find difference

///////////////////////////////////////////////////////////////
//
// lc1504. Count Submatrices With All Ones
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc085
(1) 用lc085 method 1去解。
(2) 用lc085 method 2去解。
    因為要算當前高度的所有rectangle，
    sum[i] = sum[sk.back()]
    sum[i] += (i-sk.back())*dp[i]。

///////////////////////////////////////////////////////////////
//
// lc1506. Find Root of N-Ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n) space，找deg == 0的點，map紀錄。
(2) O(1) space，利用xor，只有root只會出現一次。

///////////////////////////////////////////////////////////////
//
// lc1507. Reformat Date
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 判斷長度來檢查是1 ~ 9還是 > 10來做substr。

///////////////////////////////////////////////////////////////
//
// lc1509. Minimum Difference Between Largest and Smallest Value in Three Moves
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc486。

(1) dfs recursion
(2) iteration

///////////////////////////////////////////////////////////////
//
// lc1512. Number of Good Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum

///////////////////////////////////////////////////////////////
//
// lc1513. Number of Substrings With Only 1s
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count 1

///////////////////////////////////////////////////////////////
//
// lc1518. Water Bottles (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(log(n)) time，
    res += empty / exchange
    empty = empty / exchange + empty % exchange
(2) O(1) time

The "price" of buying a refill is handing over two empties. 
However, you must have your own empty bottle to receive the refill.
Therefore after drinking the initial numBottles, 
we "keep aside" one empty for receiving the refills (therefore we do 9 minus 1) 
and trade in the remaining 8 empties to get refills @ 2 bottles/refill. 

///////////////////////////////////////////////////////////////
//
// lc1522. Diameter of N-Ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc543。

///////////////////////////////////////////////////////////////
//
// lc1523. Count Odd Numbers in an Interval Range
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count low and high are both odd or not

///////////////////////////////////////////////////////////////
//
// lc1524. Number of Sub-arrays With Odd Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) odd and even
follow up: find total sum of odd sub arrays

///////////////////////////////////////////////////////////////
//
// lc1525. Number of Good Ways to Split a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass dp, maintain a dp[i] means # of unique characters 
    from 0 ... i.

///////////////////////////////////////////////////////////////
//
// lc1528. Shuffle String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc041。
    swap until i == indices[i]。

///////////////////////////////////////////////////////////////
//
// lc1530. Number of Good Leaf Nodes Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，track左子樹leaf和右子樹leaf的距離和 <= d。

///////////////////////////////////////////////////////////////
//
// lc1534. Count Good Triplets
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) brute force，O(n^3)，可以在跑第三個loop時先檢查abs(a[i]-a[j]) <= a

///////////////////////////////////////////////////////////////
//
// lc1539. Kth Missing Positive Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1060。
    唯一差別是要從1開始算。

///////////////////////////////////////////////////////////////
//
// lc1541. Minimum Insertions to Balance a Parentheses String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 
    (a) when s[i] == ')' && (s[i+1] == '(' or i == s.size()-1), we need to insert one ')'; 
        Otherwise, there are two consecutive ')', and we skip the next one: i++
    (b) when every time we face two ')', subtract one '(' and check if it is < 0. 
        If yes, we need to insert one '(' and reset left to 0.
    (c) after one time pass. res += left*2 to make sure if there are not enough ')'.

///////////////////////////////////////////////////////////////
//
// lc1544. Make The String Great
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) stack
(2) two pointer
    note: 'a'^'A' = 32

///////////////////////////////////////////////////////////////
//
// lc1550. Three Consecutive Odds
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find 連續三個奇數，若遇偶數，cnt = 0。

///////////////////////////////////////////////////////////////
//
// lc1557. Minimum Number of Vertices to Reach All Nodes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找沒有in-degree的node。
*** follow up: 先對沒有in-degree的node跑一遍dfs，最後再對那些環找任一點
               做dfs。

///////////////////////////////////////////////////////////////
//
// lc1558. Minimum Numbers of Function Calls to Make Target Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count odd of all numbers and max of even of all numbers

///////////////////////////////////////////////////////////////
//
// lc1567. Maximum Length of Subarray With Positive Product
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count first neg index, one pass

///////////////////////////////////////////////////////////////
//
// lc1570. Dot Product of Two Sparse Vectors
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) map operation，儲存非零位置。
(2) two pointer，類似lc349，lc350。
    用vector<pair<int, int>>儲存非零位置。

///////////////////////////////////////////////////////////////
//
// lc1571. Warehouse Manager
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) inner join

///////////////////////////////////////////////////////////////
//
// lc1572. Matrix Diagonal Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: O(n)，跑一遍找對角線，若n是奇數，扣掉重複算的。

///////////////////////////////////////////////////////////////
//
// lc1573. Number of Ways to Split a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass
(2) one pass

///////////////////////////////////////////////////////////////
//
// lc1578. Minimum Deletion Cost to Avoid Repeating Letters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個sum和到目前為止最大maxv，若遇到s[i] != s[i-1]
    res += sum-maxv, sum = maxv = 0;

///////////////////////////////////////////////////////////////
//
// lc1581. Customer Who Visited but Did Not Make Any Transactions
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) exclusive left join

///////////////////////////////////////////////////////////////
//
// lc1582. Special Positions in a Binary Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc531。

(1) 對於每個row先找colsum == 1，若有，找到對應位置並搜尋row有沒有==1，
    若有，++res。
    因為每個row去搜尋row只會搜尋一次，所有點總共最多visit m*n次。
    time: O(m*n)
    space: O(1)
(2) lc531的method 2。
    time: O(m*n)
    space: O(m+n)

///////////////////////////////////////////////////////////////
//
// lc1583. Count Unhappy Friends (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n^2)，紀錄preference，這樣就可以從O(n^3)變成O(n^2)。

///////////////////////////////////////////////////////////////
//
// lc1584. Min Cost to Connect All Points
//
///////////////////////////////////////////////////////////////

最佳解： method 3，4

https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/843940/C%2B%2B-MST%3A-Kruskal-%2B-Prim's-%2B-Complete-Graph

(1) Kruskal with sort
    Kruskal involves min heap to pick the smallest edge, 
    and union-find to check if the edge is redundant. We exit when all points are connected.
(2) Kruskal with heap
(3) Kruskal with priority queue
(4) Prim with priority queue
    In the Prim's algorithm, we are building a tree starting from some initial point. 
    We track all connected points in visited.
    For the current point, we add its edges to the min heap. 
    Then, we pick a smallest edge that connects to a point that is not visited. Repeat till all points are visited.

///////////////////////////////////////////////////////////////
//
// lc1586. Binary Search Tree Iterator II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc173。
    inorder stack traversal，將前後串連起來

///////////////////////////////////////////////////////////////
//
// lc1587. Bank Account Summary II
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) create a table then left join
(2) directly left join

///////////////////////////////////////////////////////////////
//
// lc1588. Sum of All Odd Length Subarrays (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 去計算A[i] 出現在subarry的次數
    O(n) time O(1) space
    從左邊subarray來看，有i, [i, i-1], ... [i, i-1, ..., 1, 0], i+1種選擇
    從右邊subarray來看，有i, [i, i+1], [i, i+1, ..., n-1], n-i種選擇
    所以A[i]出現在subarray共有 (i+1)*(n-i)，因為要找奇數，所以/2
    但有可能有小數點，且一定會有自己一次，所以 ((i+1)*(n-i)+1)/2;
    也可ceil((i+1)*(n-i)/2)。

    Example of array [1,2,3,4,5]
    1 2 3 4 5 subarray length 1
    1 2 X X X subarray length 2
    X 2 3 X X subarray length 2
    X X 3 4 X subarray length 2
    X X X 4 5 subarray length 2
    1 2 3 X X subarray length 3
    X 2 3 4 X subarray length 3
    X X 3 4 5 subarray length 3
    1 2 3 4 X subarray length 4
    X 2 3 4 5 subarray length 4
    1 2 3 4 5 subarray length 5

    5 8 9 8 5 total times each index was added.
    3 4 5 4 3 total times in odd length array with (x + 1) / 2
    2 4 4 4 2 total times in even length array with x / 2

///////////////////////////////////////////////////////////////
//
// lc1598. Crawler Log Folder
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，檢查 == "../" 和 != "./"即可。

///////////////////////////////////////////////////////////////
//
// lc1600. Throne Inheritance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1602. Find Nearest Right Node in Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bfs
(2) preorder morris traversal，注意計算深度問題。

///////////////////////////////////////////////////////////////
//
// lc1603. Design Parking System
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) thread safe solution，注意用mtx陣列，fix size，而不是用vector
https://stackoverflow.com/questions/16465633/how-can-i-use-something-like-stdvectorstdmutex/24170141

///////////////////////////////////////////////////////////////
//
// lc1605. Find Valid Matrix Given Row and Column Sums
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy

///////////////////////////////////////////////////////////////
//
// lc1608. Special Array With X Elements Greater Than or Equal X
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 從後往前找
(2) binary search

///////////////////////////////////////////////////////////////
//
// lc1609. Even Odd Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，和sign來判斷當前要是even level or odd level。

///////////////////////////////////////////////////////////////
//
// lc1612. Check If Two Expression Trees are Equivalent (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) preorder，利用cnt(26, 0)紀錄出現的次數
follow up: 如果root是'-'，left subtree不會被影響，right subtree sign*=-1。

///////////////////////////////////////////////////////////////
//
// lc1614. Maximum Nesting Depth of the Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) linear search。

///////////////////////////////////////////////////////////////
//
// lc1615. Maximal Network Rank (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用unordered_set記錄自己有連到幾個，跑一個O(n^2)，去算出最大的兩個邊。
    O(n^2)
    follow up: if average m is O(n), design a O(n) algo
follow up:
    1. 若最大數量的node只有一個，對於其他的node算出和最大數量的和，若這兩node有
    邊必須扣掉一。
    2. 若有兩個以上，想像若這些node 為m，若 m*(m-1)/2 > connect 這些彼此node
    的邊數量，代表一定有兩個node屬於最大數量邊，且沒有邊連這兩個，不用-1。
    note: fully connected of n nodes, its edge = n*(n-1)/2。

///////////////////////////////////////////////////////////////
//
// lc1616. Split Two Strings to Make Palindrome
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若找到不能找，換同string再去比較。

///////////////////////////////////////////////////////////////
//
// lc1619. Mean of Array After Removing Some Elements
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) sort entire array
(2) 用兩個priority queue。

///////////////////////////////////////////////////////////////
//
// lc1624. Largest Substring Between Two Equal Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find, use cnt to record position

///////////////////////////////////////////////////////////////
//
// lc1628. Design an Expression Tree With Evaluate Function (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) system design ood
    base node
    number node
    op node: addnode, subtract node, multiply node, divide node

///////////////////////////////////////////////////////////////
//
// lc1629. Slowest Key
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持最大diff和其label即可。

///////////////////////////////////////////////////////////////
//
// lc1630. Arithmetic Subarrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) no sort
(2) sort

///////////////////////////////////////////////////////////////
//
// lc1631. Path With Minimum Effort
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1102，Dijkstra。
    time: O(mnlogmn)
    space: O(mn)

///////////////////////////////////////////////////////////////
//
// lc1636. Sort Array by Increasing Frequency
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1640. Check Array Formation Through Concatenation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map來儲存第一個pieces的type，然後對於arr的第一個數去找對應的type，
    並iterate 該pices。

///////////////////////////////////////////////////////////////
//
// lc1641. Count Sorted Vowel Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(5) space
(2) O(n*5) space

///////////////////////////////////////////////////////////////
//
// lc1644. Lowest Common Ancestor of a Binary Tree II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 變形postordeder，遇到p或q，++cnt，cnt == 2才有lca。

///////////////////////////////////////////////////////////////
//
// lc1647. Minimum Deletions to Make Character Frequencies Unique
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) space
    記錄每個出現次數的字母數量，
    若cnt[i] > 1，cnt[i-1] += cnt[i-1], res += cnt[i]-1。
(2) O(1) space
    先記錄出現次數並sort。
    維持一個now_feq表示最近使用過的feq，
    若times[i] >= now_feq, --now_feq, res += times[i]-now_feq
    else now_feq = times[i]

///////////////////////////////////////////////////////////////
//
// lc1650. Lowest Common Ancestor of a Binary Tree III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc160
    O(log(n)) time O(1) space

///////////////////////////////////////////////////////////////
//
// lc1654. Minimum Jumps to Reach Home (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，建立queue with state，表示當前到position是foward or backward
    利用visit表示這個點有沒有到過，被foward到過或是backward到過。
    關於maxval，
    if (a >= b)，maxval = x+b
    if (a < b)，maxval = x+a+a+b
    https://leetcode.com/problems/minimum-jumps-to-reach-home/
    discuss/935419/Python-deque-BFS-O(max(x-max(forbidden))%2Ba%2Bb)

///////////////////////////////////////////////////////////////
//
// lc1656. Design an Ordered Stream
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個index，表示第一個空的位置，若非空，就push到res，並移到第一個空的
    位置。

///////////////////////////////////////////////////////////////
//
// lc1657. Determine if Two Strings Are Close (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) bucket sort
    if (n < 26log26) then O(26log26)。

///////////////////////////////////////////////////////////////
//
// lc1660. Correct a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs with map，利用parent map記錄自己的parent是誰，若當前自己right
    child被指過，表示自己的孩子和自己同一層，now->right = null，且自己
    的parent對自己設置null。

///////////////////////////////////////////////////////////////
//
// lc1664. Ways to Make a Fair Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc198。

(1) 維持 odd and even

///////////////////////////////////////////////////////////////
//
// lc1662. Check If Two String Arrays are Equivalent
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer searching

///////////////////////////////////////////////////////////////
//
// lc1663. Smallest String With A Given Numeric Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy forward
(1) greedy backward

///////////////////////////////////////////////////////////////
//
// lc1666. Change the Root of a Binary Tree (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用recursion，當前有new parent，
    規則是如果當前now->left = new parent，則now->left = null，反之。
    old parent = now->parent
    now->parent = new parent，建立新的parent。
    且若當前砍掉連接後還有左孩子，則讓他變成右孩子。因為left child 要去接
    自己的parent: now->left = recursion(old_parent, now)。

///////////////////////////////////////////////////////////////
//
// lc1668. Maximum Repeating Substring
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大的k，repeat word for max k times and find this word
    in input string。

///////////////////////////////////////////////////////////////
//
// lc1669. Merge In Between Linked Lists
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear pass。

///////////////////////////////////////////////////////////////
//
// lc1670. Design Front Middle Back Queue
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 利用list and iterator，維持mid
(2) 利用兩個deque：left & right，left.size()-right.size() <= 1。

///////////////////////////////////////////////////////////////
//
// lc1672. Richest Customer Wealth
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find max row sum。

///////////////////////////////////////////////////////////////
//
// lc1673. Find the Most Competitive Subsequence (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用升序stack，若當前可以pop，檢查未來還有沒有足夠的element可以放入stack。

///////////////////////////////////////////////////////////////
//
// lc1676. Lowest Common Ancestor of a Binary Tree IV
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder，利用unordered set來記錄node。

///////////////////////////////////////////////////////////////
//
// lc1678. Goal Parser Interpretation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string processing

///////////////////////////////////////////////////////////////
//
// lc1683. Invalid Tweets
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) char length

///////////////////////////////////////////////////////////////
//
// lc1684. Count the Number of Consistent Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) set

///////////////////////////////////////////////////////////////
//
// lc1693. Daily Leads and Partners
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count distinct and group by

///////////////////////////////////////////////////////////////
//
// lc1695. Maximum Erasure Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer，維持一subarray裡面的次數都只出現一個，類似lc3。

///////////////////////////////////////////////////////////////
//
// lc1696. Jump Game VI (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc239，用一降序deque。
time : O(n), space: O(k)
    this problem is like leetcode 239, just use a decreasing deque size k.
    More specifically, the head of the deque is the max score we can get from current index i.
    The size of deque is k because for current index i, 
    the farthest idx before i is i-k, and when we push i in to que, 
    we need to pop out any index smaller than i-k.

///////////////////////////////////////////////////////////////
//
// lc1700. Number of Students Unable to Eat Lunch
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) two pointer，計算不符合的數量，若等同於當前學生數量，return。
    O(n^2) time
    the worst case is like student [0 0 0 1 1 1], sandwich [1 0 1 0 1 0]
    and for each sandwich, we go though student array n/2 times. 
    That is, total time: n/2*n = O(n^2).

(2) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1704. Determine if String Halves Are Alike
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find

///////////////////////////////////////////////////////////////
//
// lc1708. Largest Subarray Length K (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大，直接去比較頭，若都一樣，代表是最後一個subarry
    ex: [1 1 1 1 2]，k = 3，選 [1 1 2]
*** follow up: numbers are not distinct.
    類似lc1163。
    唯一差別是不能update l = max(l+d+1, r)，只能l = r，因為這是有固定的長度k
    而不是像lc1163一樣substring沒有固定長度。
    另外多一個條件，因為限定長度k，確認現在比的r+k-1 < n才值得比。
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1710. Maximum Units on a Truck
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort，and greedy。

///////////////////////////////////////////////////////////////
//
// lc1711. Count Good Meals
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 2 sum with map

///////////////////////////////////////////////////////////////
//
// lc1716. Calculate Money in Leetcode Bank
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) math，O(1) time。
(2) loop，O(n) time

///////////////////////////////////////////////////////////////
//
// lc1721. Swapping Nodes in a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one pass
** follow up: change structure, maintain p1, n1, p2, n2
注意若 n1 == p2 or n2 == p1，要做相鄰的處理
且n2 == p1，要swap node，因為我們assume p1在左邊，p2在右邊做處理。

///////////////////////////////////////////////////////////////
//
// lc1725. Number Of Rectangles That Can Form The Largest Square
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find max of minlen of each rect。

///////////////////////////////////////////////////////////////
//
// lc1730. Shortest Path to Get Food
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1732. Find the Highest Altitude
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear找累加最大值。

///////////////////////////////////////////////////////////////
//
// lc1736. Latest Time by Replacing Hidden Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從左到右，找最大的數字，注意time[0]要看time[1]，time[1]要看time[0]

///////////////////////////////////////////////////////////////
//
// lc1740. Find Distance in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder

///////////////////////////////////////////////////////////////
//
// lc1741. Find Total Time Spent by Each Employee
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sum and group by

///////////////////////////////////////////////////////////////
//
// lc1746. Maximum Subarray Sum After One Operation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似1186，dp iteration

///////////////////////////////////////////////////////////////
//
// lc1748. Sum of Unique Elements
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) counting

///////////////////////////////////////////////////////////////
//
// lc1753. Maximum Score From Removing Stones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找最大和最小，各扣一然後++res。

///////////////////////////////////////////////////////////////
//
// lc1754. Largest Merge Of Two Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string compare
    since at most substr will be executed n times for s1 and m times for s2.
    so total is (n+n-1+n-2+...+1) + (m+m-1+m-2+...+1) = O(n^2+m^2)

///////////////////////////////////////////////////////////////
//
// lc1757. Recyclable and Low Fat Products
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) simple select

///////////////////////////////////////////////////////////////
//
// lc1758. Minimum Changes To Make Alternating Binary String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find 010101... error positions and return min(ones, n-ones)
    n-ones means 101010.... error positions.

///////////////////////////////////////////////////////////////
//
// lc1759. Count Number of Homogenous Substrings
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) math formula
(2) compare with last character

///////////////////////////////////////////////////////////////
//
// lc1762. Buildings With an Ocean View
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) decreasing stack from left to right
(2) array search from right to left

///////////////////////////////////////////////////////////////
//
// lc1765. Map of Highest Peak
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) simple bfs

///////////////////////////////////////////////////////////////
//
// lc1768. Merge Strings Alternately
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer

///////////////////////////////////////////////////////////////
//
// lc1769. Minimum Number of Operations to Move All Balls to Each Box
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc238。
(1) left_step表示到目前為止這個點有幾個人花的總共步數。
    left_cnt表示到目前為止有幾個1。
    right亦同。

///////////////////////////////////////////////////////////////
//
// lc1772. Sort Features by Popularity
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use stable sort with map and set

///////////////////////////////////////////////////////////////
//
// lc1773. count items matching a rule
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count

///////////////////////////////////////////////////////////////
//
// lc1777. Product's Price for Each Store
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) reproduce talble with group by

///////////////////////////////////////////////////////////////
//
// lc1778. Shortest Path in a Hidden Grid
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs+bfs

///////////////////////////////////////////////////////////////
//
// lc1779. Find Nearest Point That Has the Same X or Y Coordinate
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find

///////////////////////////////////////////////////////////////
//
// lc1780. Check if Number is a Sum of Powers of Three
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) greedy, always minus largest power of 3.
(2) 想像若 n = 3^0 + 3^2 + 3^4 = 3^0(1+3^2+3^4), 去掉一
        3^2+3^4 = 3^2(1+3^2)，去掉一
        3^2 = 3^2(1)，去掉一

        所以我們發現若n%3 == 1 可以n = (n-1)/3
                  若n%3 == 0 可以n /= 3
        若n%3 == 2，表示沒辦法約分，return false

///////////////////////////////////////////////////////////////
//
// lc1784. Check if Binary String Has at Most One Segment of Ones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為起始必為1，找到01就是代表第二個1。
(2) 從尾巴跑遇到1停，繼續跑，遇到不是0停，如果idx != -1表示有兩個以上1 block。
(2) 找邊界數量，找理說只有兩個。

///////////////////////////////////////////////////////////////
//
// lc1790. Check if One String Swap Can Make Strings Equal
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1)  O(1) space tracing
(2)  O(n) space tracing

///////////////////////////////////////////////////////////////
//
// lc1791. Find Center of Star Graph
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 中心點必和其他點相連。
(2) bfs

///////////////////////////////////////////////////////////////
//
// lc1795. Rearrange Products Table
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union
(2) unpivot, not supported by sql

///////////////////////////////////////////////////////////////
//
// lc1796. Second Largest Digit in a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用兩個變數維持最大和第二大

///////////////////////////////////////////////////////////////
//
// lc1797. Design Authentication Manager
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) map & set

///////////////////////////////////////////////////////////////
//
// lc1800. Maximum Ascending Subarray Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到數字比當前小就將sum = 當前數字。

///////////////////////////////////////////////////////////////
//
// lc1804. Implement Trie II (Prefix Tree)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) trie tree，用兩個cnt，一個代表結尾的，一個代表走過的。

///////////////////////////////////////////////////////////////
//
// lc1810. Minimum Path Cost in a Hidden Grid
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc1778
(1) dfs + dijkstra

///////////////////////////////////////////////////////////////
//
// lc1816. Truncate Sentence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count words

///////////////////////////////////////////////////////////////
//
// lc1821. Find Customers WITH Positive Revenue this Year
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) group by with having

///////////////////////////////////////////////////////////////
//
// lc1822. Sign of the Product of an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count # of negative sing 

///////////////////////////////////////////////////////////////
//
// lc1823. Find the Winner of the Circular Game
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) list simulation
(2) array simulation
(3) bottom up simulation
    i = prev_i+k

///////////////////////////////////////////////////////////////
//
// lc1824. Minimum Sideway Jumps (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) dijkstra
(2) bfs
(3) dp
    dp[0] dp[1] dp[2] 表示第ith lane最小方法數
    所以 dp[i] = min(dp[i], min(dp[i+1],dp[i+2])+1)

///////////////////////////////////////////////////////////////
//
// lc1826. Faulty Sensor
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointers

///////////////////////////////////////////////////////////////
//
// lc1827. Minimum Operations to Make the Array Increasing
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find diff between neighbor

///////////////////////////////////////////////////////////////
//
// lc1832. Check if the Sentence Is Pangram
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) set
(2) bit

///////////////////////////////////////////////////////////////
//
// lc1836. Remove Duplicates From an Unsorted Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本linked list operation

///////////////////////////////////////////////////////////////
//
// lc1839. Longest Substring Of All Vowels in Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到字母差值規律，用two pointer。

///////////////////////////////////////////////////////////////
//
// lc1844. Replace All Digits with Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string operation

///////////////////////////////////////////////////////////////
//
// lc1845. Seat Reservation Manager
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) min heap
(2) set

///////////////////////////////////////////////////////////////
//
// lc1848. Minimum Distance to the Target Element
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one way direction and stop when we cannot find a solution better then res
(2) two way direction from start

///////////////////////////////////////////////////////////////
//
// lc1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) next permutation k times then two pointers greedy swap

///////////////////////////////////////////////////////////////
//
// lc1855. Maximum Distance Between a Pair of Values
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search
(2) two pointers

///////////////////////////////////////////////////////////////
//
// lc1858. Longest Word With All Prefixes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc720
(1) trie tree
(2) set

///////////////////////////////////////////////////////////////
//
// lc1859. Sorting the Sentence
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) use pair to store index
(2) linear filling with the index

///////////////////////////////////////////////////////////////
//
// lc1861. Rotating the Box
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointers

///////////////////////////////////////////////////////////////
//
// lc1869. Longer Contiguous Segments of Ones than Zeros
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer維持最大連續一樣的邊界。

///////////////////////////////////////////////////////////////
//
// lc1871. Jump Game VII (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bfs，對於當前位置i，
    起始點是要left = max(i+minJump, max_start+1)
    結束點是要right = min(i+maxJump, n-1)
    而max_start = right，因為這樣可以不visit一些之前就visit過的點。
    time: O(n*(maxjump-minjump))

(2) 表示到目前為止可以到的步數
    pre += dp[i-minjump]
    pre -= dp[i-maxjump-1]
    dp[i] = pre > 0 && s[i] == '0'
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1873. Calculate Special Bonus
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) not like, if

///////////////////////////////////////////////////////////////
//
// lc1874. Minimize Product Sum of Two Arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort
(2) sort

///////////////////////////////////////////////////////////////
//
// lc1877. Minimize Maximum Pair Sum in Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort then two pointer

///////////////////////////////////////////////////////////////
//
// lc1880. Check if Word Equals Summation of Two Words
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) naive count
(2) lambda function

///////////////////////////////////////////////////////////////
//
// lc1886. Determine Whether Matrix Can Be Obtained By Rotation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) inplace swap
(2) rotate

///////////////////////////////////////////////////////////////
//
// lc1890. The Latest Login in 2020
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) group by and year function

///////////////////////////////////////////////////////////////
//
// lc1893. Check if All the Integers in a Range Are Covered
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc253。
(1) 找出區間起始點+1，結束點的後一個減一。
    time: O(n+m)
    space: O(m)
(2) sort and find if current value in the range
    if yes, update to range[1]+1
    time: O(nlogn)

///////////////////////////////////////////////////////////////
//
// lc1897. Redistribute Characters to Make All Strings Equal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count, bucket

///////////////////////////////////////////////////////////////
//
// lc1902. Depth of BST Given Insertion Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map去找左和右最近的高度
    nlogn

///////////////////////////////////////////////////////////////
//
// lc1903. Largest Odd Number in String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find last odd number

///////////////////////////////////////////////////////////////
//
// lc1905. Count Sub Islands
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion

///////////////////////////////////////////////////////////////
//
// lc1913. Maximum Product Difference Between Two Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear
(2) sort

///////////////////////////////////////////////////////////////
//
// lc1920. Build Array from Permutation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) cycle processing
(2) modulo

///////////////////////////////////////////////////////////////
//
// lc1926. Nearest Exit from Entrance in Maze
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) simple bfs

///////////////////////////////////////////////////////////////
//
// lc1929. Concatenation of Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space

///////////////////////////////////////////////////////////////
//
// lc1937. Maximum Number of Points with Cost
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(mn) space
(1) O(n) space

///////////////////////////////////////////////////////////////
//
// lc1941. Check if All Characters Have Equal Number of Occurrences
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort

///////////////////////////////////////////////////////////////
//
// lc1961. Check If String Is a Prefix of Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string operation

///////////////////////////////////////////////////////////////
//
// lc1963. Minimum Number of Swaps to Make the String Balanced
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointers and greedy

///////////////////////////////////////////////////////////////
//
// lc1971. Find if Path Exists in Graph
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dfs recursion
(2) union find

///////////////////////////////////////////////////////////////
//
// lc1973. Count Nodes Equal to Sum of Descendants
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder recursion

///////////////////////////////////////////////////////////////
//
// lc1985. Find the Kth Largest Integer in the Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc215。
(1) built in function
(2) map build int lamda function

///////////////////////////////////////////////////////////////
//
// lc1991. Find the Middle Index in Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum

///////////////////////////////////////////////////////////////
//
// lc1992. Find All Groups of Farmland
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find start of rectangle

///////////////////////////////////////////////////////////////
//
// lc2000. Reverse Prefix of Word
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) reverse string

///////////////////////////////////////////////////////////////
//
// lc2006. Count Number of Pairs With Absolute Difference K
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) prefix sum
(2) bucket sort

///////////////////////////////////////////////////////////////
//
// lc2008. Maximum Earnings From Taxi
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n+m) bucket
(2) O(mlogm + n) sort

///////////////////////////////////////////////////////////////
//
// lc2011. Final Value of Variable After Performing Operations
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，可以發現operation[1]一定是'+'或'-'。

///////////////////////////////////////////////////////////////
//
// lc2016. Maximum Difference Between Increasing Elements
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc121。
(1) 維持minv代表開始到現在的最小值。

///////////////////////////////////////////////////////////////
//
// lc2021. Brightest Position on Street
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc253，lc729。
(1) 用map做counter。

///////////////////////////////////////////////////////////////
//
// lc2022. Convert 1D Array Into 2D Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear processing

///////////////////////////////////////////////////////////////
//
// lc2027. Minimum Moves to Convert String
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 存'x'的index，然後算個數。
(2) 遇到'x'，i+=3，++res。 
    遇到'o'，i++。

///////////////////////////////////////////////////////////////
//
// lc2032. Two Out of Three
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count frequencies of unque value

///////////////////////////////////////////////////////////////
//
// lc2037. Minimum Number of Moves to Seat Everyone
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2。

(1) nlogn sort
(2) bucket sort

///////////////////////////////////////////////////////////////
//
// lc2039. The Time When the Network Becomes Idle
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找出第一個和最後一個message的overlap時間並且扣掉

///////////////////////////////////////////////////////////////
//
// lc2046. Sort Linked List Already Sorted Using Absolute Values
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若遇到cur->val < 0，把他connect到head，並且head = cur。

///////////////////////////////////////////////////////////////
//
// lc2049. Count Nodes With the Highest Score
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 把tree建立起來後利用postorder recursion去算每個node的score。

///////////////////////////////////////////////////////////////
//
// lc2053. Kth Distinct String in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) map

///////////////////////////////////////////////////////////////
//
// lc2057. Smallest Index With Equal Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用add取代mod。
    類似lc412。

///////////////////////////////////////////////////////////////
//
// lc2058. Find the Minimum and Maximum Number of Nodes Between Critical Points
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find local minimum or maximum point and compare with last one.

///////////////////////////////////////////////////////////////
//
// lc2062. Count Vowel Substrings of a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc930, lc992, lc1248, lc1358
(1) prefix sliding window

///////////////////////////////////////////////////////////////
//
// lc2068. Check Whether Two Strings are Almost Equivalent
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use cnt array and find the diff, should be <= 3

///////////////////////////////////////////////////////////////
//
// lc2073. Time Needed to Buy Tickets
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) a. 若i<k，res += min(tickets[i], tickets[k])
    b. 若i>k，val = min(tickets[i], tickets[k])
        若val == tickets[k]，必須 val--，因為當tickets[k]變成0後，我們
        不會處理在他後面的ticket。

///////////////////////////////////////////////////////////////
//
// lc2077. Paths in Maze That Lead to Same Room
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) set operation, 若有一個邊 n1 - n2，則
    若有一個cycle含這個邊，在set[n1]和set[n2]中必有重複的點。

///////////////////////////////////////////////////////////////
//
// lc2078. Two Furthest Houses With Different Colors
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy, 
    find the first house from right to left that has different color with colors[0]
    find the first house from left to right that has different color with colors[n-1]

(2) find min and max index for each color

///////////////////////////////////////////////////////////////
//
// lc2083. Substrings That Begin and End With the Same Letter
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到character就計算以這個character為結尾的substring
(2) (1+n)*n/2

///////////////////////////////////////////////////////////////
//
// lc2085. Count Common Words With One Occurrence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) map operation

///////////////////////////////////////////////////////////////
//
// lc2089. Find Target Indices After Sorting Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort 
(2) bucket sort

///////////////////////////////////////////////////////////////
//
// lc2093. Minimum Cost to Reach City With Discounts
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dijkstra, lc787

///////////////////////////////////////////////////////////////
//
// lc2095. Delete the Middle Node of a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 快慢指針。

///////////////////////////////////////////////////////////////
//
// lc2096. Step-By-Step Directions From a Binary Tree Node to Another
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) lca + tracking
(2) backtracking

///////////////////////////////////////////////////////////////
//
// lc2098. Subsequence of Size K With the Largest Even Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) nth_element
(2) quick select

///////////////////////////////////////////////////////////////
//
// lc2099. Find Subsequence of Length K With the Largest Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) quick select
(2) min heap
(3) map

///////////////////////////////////////////////////////////////
//
// lc2104. Sum of Subarray Ranges
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sum(max-min) = sum(max) - sum(min)
    sum(min) -> increasing stack
    sum(max) -> decreasing stack

///////////////////////////////////////////////////////////////
//
// lc2108. Find First Palindromic String in the Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string processing

///////////////////////////////////////////////////////////////
//
// lc2110. Number of Smooth Descent Periods of a Stock
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count length
(2) dp O(n) space
(3) dp O(1) space

///////////////////////////////////////////////////////////////
//
// lc2114. Maximum Number of Words Found in Sentences
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string processing

///////////////////////////////////////////////////////////////
//
// lc2121. Intervals Between Identical Elements
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix & suffix array

///////////////////////////////////////////////////////////////
//
// lc2130. Maximum Twin Sum of a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) stack
(2) reverse

///////////////////////////////////////////////////////////////
//
// lc2133. Check if Every Row and Column Contains All Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bitset
(2) index

///////////////////////////////////////////////////////////////
//
// lc2134. Minimum Swaps to Group All 1's Together II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum and sliding window

///////////////////////////////////////////////////////////////
//
// lc2144. Minimum Cost of Buying Candies With Discount
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort
(2) bucke sort

///////////////////////////////////////////////////////////////
//
// lc2148. Minimum Cost of Buying Candies With Discount
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) two pass
(2) one pass

///////////////////////////////////////////////////////////////
//
// lc2149. Rearrange Array Elements by Sign
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointers

///////////////////////////////////////////////////////////////
//
// lc2150. Find All Lonely Numbers in the Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bucket sort
(2) nlogn sort

///////////////////////////////////////////////////////////////
//
// lc2154. Keep Multiplying Found Values by Two
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) check existed

///////////////////////////////////////////////////////////////
//
// lc2155. All Divisions With the Highest Score of a Binary Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointers

///////////////////////////////////////////////////////////////
//
// lc2156. Find Substring With Given Hash Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) right to left

///////////////////////////////////////////////////////////////
//
// lc2157. Groups of Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs
(2) union find

///////////////////////////////////////////////////////////////
//
// lc2160. Minimum Sum of Four Digit Number After Splitting Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort and return a[0]*10+a[2] + a[1]*10+a[3]

///////////////////////////////////////////////////////////////
//
// lc2161. Partition Array According to Given Pivot
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) two array and combine
(2) one array and three pointers

///////////////////////////////////////////////////////////////
//
// lc2162. Minimum Cost to Set Cooking Time
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find pattern and string processing

///////////////////////////////////////////////////////////////
//
// lc2163. Minimum Difference in Sums After Removal of Elements
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two priority queue and sliding window

///////////////////////////////////////////////////////////////
//
// lc2164. Sort Even and Odd Indices Independently
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) split, sort then merge

///////////////////////////////////////////////////////////////
//
// lc2165. Smallest Value of the Rearranged Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort and swap

///////////////////////////////////////////////////////////////
//
// lc2166. Design Bitset
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string
(2) set

///////////////////////////////////////////////////////////////
//
// lc2167. Minimum Time to Remove All Cars Containing Illegal Goods
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy O(1) space
(2) dp O(1) space

///////////////////////////////////////////////////////////////
//
// lc2169. Count Operations to Obtain Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) subtraction simulatiom
(2) modulo


///////////////////////////////////////////////////////////////
//
// lc2170. Minimum Operations to Make the Array Alternating
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp
(2) greedy

///////////////////////////////////////////////////////////////
//
// lc2171. Removing Minimum Number of Magic Beans
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy, use each number as final bean

//////////////////////////////////////////////////////////////
//
// lc2172. Maximum AND Sum of Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 3-base mask
(2) 2-base mask

///////////////////////////////////////////////////////////////
//
// lc2176. Count Equal and Divisible Pairs in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) naive brute force
(2) if i*j%k == 0 -> gcd(i, k)*gcd(j, k) % k = 0

///////////////////////////////////////////////////////////////
//
// lc2177. Find Three Consecutive Integers That Sum to a Given Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) divisible by 3

///////////////////////////////////////////////////////////////
//
// lc2178. Maximum Split of Positive Even Integers
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy choose smaller even number

///////////////////////////////////////////////////////////////
//
// lc2179. Count Good Triplets in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) segment tree

///////////////////////////////////////////////////////////////
//
// lc2180. Count Integers With Even Digit Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) brute force
(2) find pattern

///////////////////////////////////////////////////////////////
//
// lc2181. Merge Nodes in Between Zeros
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) pre & now processing

///////////////////////////////////////////////////////////////
//
// lc2182. Construct String With Repeat Limit
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy bucket
(2) greedy max priority queue

///////////////////////////////////////////////////////////////
//
// lc2183. Count Array Pairs Divisible by K
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) if n1 * n2 % k == 0, then gcd(n1, k) * gcd(n2, k) % k == 0.
    GCD is an intersection between prime factorizations of two numbers.
    So, when we do gcd(n, k), we remove all prime factors from n
    that do not exist in k and therefore do not matter for divisibility.
(2) use factor of k to be gcd map insted of map

///////////////////////////////////////////////////////////////
//
// lc2185. Counting Words With a Given Prefix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) substring
(2) find

///////////////////////////////////////////////////////////////
//
// lc2186. Minimum Number of Steps to Make Two Strings Anagram II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket

///////////////////////////////////////////////////////////////
//
// lc2187. Minimum Time to Complete Trips
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search

///////////////////////////////////////////////////////////////
//
// lc2188. Minimum Time to Finish the Race
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) top down
(2) bottom up