///////////////////////////////////////////////////////////////
//
// lc030. Substring with Concatenation of All Words (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 

///////////////////////////////////////////////////////////////
//
// lc214. Shortest Palindrome (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc459。

///////////////////////////////////////////////////////////////
//
// lc698. Partition to K Equal Sum Subsets
//
///////////////////////////////////////////////////////////////

最佳解： method 1

///////////////////////////////////////////////////////////////
//
// lc951. Flip Equivalent Binary Trees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先判斷當前兩個node有沒有一樣，
    再return 左孩子左孩子 && 右孩子右孩子 || 左孩子右孩子 && 右孩子左孩子。

///////////////////////////////////////////////////////////////
//
// lc953. Verifying an Alien Dictionary
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 紀錄順序，兩兩比較，若a > b則return false。

///////////////////////////////////////////////////////////////
//
// lc957. Prison Cells After N Days (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個cycle，若當前res出現過， N = (N - 1) % (cycles-1);

///////////////////////////////////////////////////////////////
//
// lc958. Check Completeness of a Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，complete biniry tree特性為用bfs走訪一定全走非null node，遇到null
    node後，後面一定都是null，利用這特性可以跑第一遍while將node全push到queue直到遇到
    queue中第一個非null，再用另一個while繼續走queue直到遇到第一個非null node或走完queue。
    return index == que.size()。

///////////////////////////////////////////////////////////////
//
// lc959. Regions Cut By Slashes (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2。

(1) 利用union find，將每一個grid劃分成四小等份，上右下左依序為0,1,2,3。
    那麼其實就是對於這些小分塊做union find。
    要注意的是，相鄰的grid預設就要union，因為slash無法分割這些。
    若當前grid[i][j] != '/'，表示0 and 1要union，2 and 3要union。
    若當前grid[i][j] != '\'，表示0 and 3要union，1 and 2要union。
    count數量就是n*n*4。
(2) dfs，將grid分成3*3小塊，然後slash改成1其餘為0，這樣就是
    number of islands。

///////////////////////////////////////////////////////////////
//
// lc961. N-Repeated Element in Size 2N Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為一個陣列有一半都同樣，nums[i]必等於nums[i-1] or nums[i-2]。
    如果沒有只有一個情況
    1, 2, 3, 1。

///////////////////////////////////////////////////////////////
//
// lc965. Univalued Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，preorder。

///////////////////////////////////////////////////////////////
//
// lc969. Pancake Sorting
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到剩餘長度最大的(index: i)，翻到頭，再翻到剩餘長度的位置(index: n)。
    reverse(begin ~ i) then reverse(begin ~ n); --n;

///////////////////////////////////////////////////////////////
//
// lc971. Flip Binary Tree To Match Preorder Traversal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若當前node不等於voyage的對應點，return {-1}，若左孩子的val != voyage[now+1]，
    swap(root->left, root->right)。

///////////////////////////////////////////////////////////////
//
// lc973. K Closest Points to Origin (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) quick select，不好懂。 類似215。
(2) priority queue。

///////////////////////////////////////////////////////////////
//
// lc974. Subarray Sums Divisible by K (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc560類似。要注意餘數為負數的時候再加上K，prefix sum。
(2) 先算好所有的出現相同餘數的次數，再一次跑一個迴圈算好。
    ex: 若該餘數出現4次，則符合題目的次數為1+2+3。

///////////////////////////////////////////////////////////////
//
// lc976. Largest Perimeter Triangle (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大邊長，sort後從後面開始
    只檢查a[i-2] + a[i-1] 有沒有 > a[i]，因為若沒有，以a[i]為檢查點的
    後面i=0~i-3任兩點組合也不會>a[i]。

///////////////////////////////////////////////////////////////
//
// lc977. Squares of a Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 雙指針(頭尾)取絕對值大的填入res的尾端。
(2) stack，類似lc1019，維持一個降序陣列。

///////////////////////////////////////////////////////////////
//
// lc978. Longest Turbulent Subarray (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) > ： sign = 1， < ： sign = -1
    對於當前>或<，紀錄上次是相反結果(sign)的話cnt++，反之就重新初始化狀態(cnt = 2)。
    注意若當前=上一個，初始化sign = -1, cnt = 1。

///////////////////////////////////////////////////////////////
//
// lc979. Distribute Coins in Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，紀錄當前硬幣總數，此硬幣總數代表要往父節點移動的個數。

///////////////////////////////////////////////////////////////
//
// lc980. Unique Paths III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先計算要走的數量， 然後用一般的dfs即可。

///////////////////////////////////////////////////////////////
//
// lc981. Time Based Key-Value Store (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2，3。

類似lc1146。

(1) unordered_map<string, map<int, string>> map
    set: O(log(n))
    get: O(log(n))

(2) unordered_map<string, vector<pair<int, string>>> map;
    因為時間為遞增，可以使用vector pair，upper bound 也為log(n)
    set: O(1)
    get: O(log(n))

(3) 類似(2)，但implement upper_bound by binary search。

///////////////////////////////////////////////////////////////
//
// lc983. Minimum Cost For Tickets (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 跑365天循環，對當前天數，選擇最小付費方式。
    若不是搭車日期(初始化=INT_MAX)，照理說不花費，所以dp[i] = dp[i-1]。
    若是搭車日期(初始化=0)，找出最小付費方式。

///////////////////////////////////////////////////////////////
//
// lc985. Sum of Even Numbers After Queries (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持even sum，若query的index a[idx] is even，先扣掉
    even -= a[idx]
    update a[idx] = a[idx] + val
    再次檢查a[idx]是不是even，是的話，加回even。
    O(n):
    n here is the size of A. Based on the problem description, 
    it dominates the size of queries (0 <= queries[i][1] < A.length). 
    So, worst case scenario, we need 3 * n operations, which is O(n).

///////////////////////////////////////////////////////////////
//
// lc986. Interval List Intersections (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先判對兩個list有沒有交集，若沒有則換下一個，
    若有交集，頭取max(a.start, b.start)，
             尾取min(a.end, b.end)。
    類似lc56。

///////////////////////////////////////////////////////////////
//
// lc987. Vertical Order Traversal of a Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為相同的x y 需要排序，同一個x不同y，則y由小到大填入，因此map作為資料結構。
    map<int, map<int, set<int>>> info來記錄-> info[x][y].insert(node->val)。
    (a) dfs
    (b) bfs

///////////////////////////////////////////////////////////////
//
// lc988. Smallest String Starting From Leaf (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 錯誤想法：postorder去隨時找到最小字串。
    這題是對於所有string從leaf到root找最小字串，所以每次比較都必須是leaf到root
    的字串，這樣就必須用preorder(dfs)而非postorder。
    類似lc1026。

///////////////////////////////////////////////////////////////
//
// lc989. Add to Array-Form of Integer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後面往前走，一位一位的加。

///////////////////////////////////////////////////////////////
//
// lc991. Broken Calculator
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 如果 x >= y，res += x-y，
    但x < y，最快的方法就是讓y <= x，

    為什麼優先除： 假設(y+2n) / 2 = x
    若我們先+2n times then / 2， # of operations: 2n+1
    若我們先除：y/2 + n = x， # of operations: n+1
    所以永遠先除以2都是對的，會造成最小的結果。

    We do Y/2 all the way until it's smaller than X,
    time complexity is O(log(Y/X)).

///////////////////////////////////////////////////////////////
//
// lc992. Subarrays with K Different Integers (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 類似lc1004，lc1052，lc340。
    利用sliding window，紀錄所有子字串使用的integeres with different
    integers <= k。
    at most k - at most k-1。
    two pass
(2) one pass lc930, lc992, lc1248, lc1358
    維持一個unique integer size = k 的window，且一變數prefix，表示
    在left之前有多少重複的number，res += prefix+1。且left為cnt[left] == 1，
    固定起始點的出現次數為1。所以left為unique interger subarray and 
    cnt[left] = 1。若 k < 0 => prefix = 0。要重新計算有多少prefix array。
    ex 1 1 1 2 2 2 3 3 3
       0 1 2 3 4 5 6 7 8
       k = 3
       left = 3, right = 9, prefix = 2，表示有除了當前subarry還有兩個prefix
       array，res += prefix+1 = 3。
       right = 6
       1 1 1 2 2 2 3
         1 1 2 2 2 3
           1 2 2 2 3

       right = 7
       1 1 1 2 2 2 3 3
         1 1 2 2 2 3 3
           1 2 2 2 3 3

       right = 8
       1 1 1 2 2 2 3 3 3
         1 1 2 2 2 3 3 3
           1 2 2 2 3 3 3

///////////////////////////////////////////////////////////////
//
// lc993. Cousins in Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs，隨時記錄當前node的parent和當前node高度，當遇到node->val等於x或是
    y，紀錄其高度，return true if parent不一樣且高度相同，否則false。
(2) bfs做法也是一樣。

///////////////////////////////////////////////////////////////
//
// lc994. Rotting Oranges (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，每清掉一層queue，++res，像洋蔥是剝皮。
    while (qsize) {
        for (int i = 0; i < qsize; ++i) {

        }
        days++;
    }

///////////////////////////////////////////////////////////////
//
// lc997. Find the Town Judge
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到一個點其in_degree - out_degree = N-1。

///////////////////////////////////////////////////////////////
//
// lc998. Maximum Binary Tree II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律。
    if (root->val < val)
        new TreeNode(val)->left = root;
    else
        root->right = func(root->right, val);

///////////////////////////////////////////////////////////////
//
// lc999. Available Captures for Rook
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到root，往四邊走。

///////////////////////////////////////////////////////////////
//
// lc1002. Find Common Characters (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用cnt(26)，每次和當前的比較，取最小值。

///////////////////////////////////////////////////////////////
//
// lc1003. Check If Word Is Valid After Substitutions (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用stack去解，遇到c時檢查當前最上面兩個是不是a和b，不是就return false。

///////////////////////////////////////////////////////////////
//
// lc1004. Max Consecutive Ones III (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 使用sliding window，右邊界一直往右，遇到0，k--，若k<0，移動左邊界，
    移動左邊界中遇到0，++k(每個iteration只移動一次，為的是right增長一次，left也要增長一次
    ，因為k<0，必需停止array大小增大)，直到k>=0，就不移動左邊界，
    此方法保持左右邊界維持合法吧0數量。

///////////////////////////////////////////////////////////////
//
// lc1005. Maximize Sum Of Array After K Negations (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用quick select將前k小的找出來，然後遍歷一次對於負數且在k次的取正號，
    若k有剩餘則代表都是正號，找到最小的，取負數。

///////////////////////////////////////////////////////////////
//
// lc1007. Minimum Domino Rotations For Equal Row (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於a[0]和b[0]，作為top和down，對top和down分別計算他們在a和b的
    出現次數，若有一個導致a[i]&b[i]都不等於top，top = 0，down也是，
    若top&down == 0，直接return -1。
    跑完loop去找top和down出現次數的最小值。

///////////////////////////////////////////////////////////////
//
// lc1008. Construct Binary Search Tree from Preorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

類似lc108。
(1) stack iteration：
    當前比stack的top小就丟入stack，且stack.top->left = 當前。
    當比stakc的top大，找到最後一個比top大的元素，將這元素->right = 當前。
(2) dfs recursion：
    跑n次迴圈，每次將一個node塞到tree中適當的位置(用遞迴)。

///////////////////////////////////////////////////////////////
//
// lc1010. Pairs of Songs With Total Durations Divisible by 60
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use map(60, 0) to store all possible time[i] % 60,
    res += map[now], with now = (60 - time[i]%60) % 60
    like prefix sum。

///////////////////////////////////////////////////////////////
//
// lc1011. Capacity To Ship Packages Within D Days
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc410，binary search找到最適合的大小。

///////////////////////////////////////////////////////////////
//
// lc1013. Partition Array Into Three Parts With Equal Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 算出sum/3，count 次數，必須>=3。比3大是因為有可能sum == 0。

///////////////////////////////////////////////////////////////
//
// lc1018. Binary Prefix Divisible By 5
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) mod 5 at every step

///////////////////////////////////////////////////////////////
//
// lc1019. Next Greater Node In Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將本來的stack array做成 pair<ListNode *, int>來表示 the relation 
    between list node and index in the res array。

(2) 類似lc503，但是因為只要找一輪，從尾巴往頭看，每次push當前val進入stack，
    找當前下一個大的，對stack找到第一個比當前大的就好(其他pop)，
    其他pop掉沒差，因為比當前小，代表往頭看當前絕對比其他val還要有可能是下一個大的。

///////////////////////////////////////////////////////////////
//
// lc1020. Number of Enclaves
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs把觸碰到boundary的1都改成0，接下來計算剩下的1的數量。

///////////////////////////////////////////////////////////////
//
// lc1021. Remove Outermost Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為最外邊的括號會和前後兩個primitive compotnent相連，用cnt計算括號，
    若不等於0則放入res。

///////////////////////////////////////////////////////////////
//
// lc1022. Sum of Root To Leaf Binary Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1025. Divisor Game
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs recursive
(2) 找規律

///////////////////////////////////////////////////////////////
//
// lc1026. Maximum Difference Between Node and Ancestor (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用preorder (dfs)，來對整條由上往下的路徑找最大最小，藉此找到max diff。
    錯誤想法：由下往上無法確定從單一leaf到root的分別最大最小，因為這樣找會變成整個tree的最大最小，
    這樣的最大最小不一定在同一路徑上，也就不存在祖孫後代的關係。

///////////////////////////////////////////////////////////////
//
// lc1028. Recover a Tree From Preorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用stack size來判斷，
    若當前size == 要插入深度，back->left = now，
    反之，pop_back直到size == 拆入深度，back->right = now。

///////////////////////////////////////////////////////////////
//
// lc1029. Two City Scheduling (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為有n人去a城市，有n人去b城市，對差值做排序，越大的越前面，表示前半部去b城市，
    後半部去a城市。

///////////////////////////////////////////////////////////////
//
// lc1030. Matrix Cells in Distance Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs。

///////////////////////////////////////////////////////////////
//
// lc1031. Maximum Sum of Two Non-Overlapping Subarrays (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window
    lmax: max value of window l before m window
    mmax: max value of window m before l window
    max(lmax + A[i]-A[i-M], mmax + A[i]-A[i-L])
    time: O(n)，space: O(1)
(2) 計算視窗大小，由尾巴往前，算idx以後最大的視窗和，再跑一個從頭開始另一個
    視窗 res = max(res, windwow + other_sum[i+1])
    做兩遍
    time and space: O(n)

///////////////////////////////////////////////////////////////
//
// lc1034. Coloring A Border (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將tagcolor全標-tagcolor，當前點跑完四個方向dfs後，若上下左右取abs後都是
    tagcolor，表示是component內部點，改為tarcolor。

///////////////////////////////////////////////////////////////
//
// lc1035. Uncrossed Lines (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp解，
    表示為dp[i][j]，
    若當前A[i] == B[j]，dp[i][j] = dp[i-1][j-1] + 1。
    否則，dp[i][j] = max(dp[i][j-1], dp[i-1][j])。
    *** 可優化為空間O(n)。

///////////////////////////////////////////////////////////////
//
// lc1037. Valid Boomerang (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算斜率，注意因為分母可能0，所以將兩個斜率的比較式變形。
    ya/xa == yb/xb is equal to ya*xb == yb*xa。

///////////////////////////////////////////////////////////////
//
// lc1038. Binary Search Tree to Greater Sum Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) inorder

///////////////////////////////////////////////////////////////
//
// lc1041. Robot Bounded In Circle (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 能在園內有兩個條件
    a. sequence回到原點
    b. 結束sequence 不是面向北方，這代表每次都會改方向，最後一定會回到原點。

///////////////////////////////////////////////////////////////
//
// lc1043. Partition Array for Maximum Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 區間內最多k個，用dp解。
    j = i ~ i-k+1
    dp[i] = max(dp[i], dp[j-1] + (i-j+1)*區間最大的A val)
    類似lc907。

///////////////////////////////////////////////////////////////
//
// lc1046. Last Stone Weight
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) nlogn sort。
(2) priority queue。 (較好)

///////////////////////////////////////////////////////////////
//
// lc1047. Remove All Adjacent Duplicates In String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc394，lc856，利用stack去做消掉括號的動作。
(2) 每次找到兩個一樣的用erase消除，且idx歸於0，但很慢。

///////////////////////////////////////////////////////////////
//
// lc1048. Longest String Chain (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp iteration。
    先將vector排序，
    對每一個word去做 last_str = word.substr(0,j) + word.substr(j+1)
    類似lc 301
    dp[cur_str] = max(dp[cur_str], dp[last_str]+1)

///////////////////////////////////////////////////////////////
//
// lc1049. Last Stone Weight II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc416，lc494。
    對於x!=y取diff，x==y抵銷，可以想像成數字分成兩堆，若一樣就是0，若不一樣取diff。
    這也就把題目轉換成0/1 Knapsacks problem。
    可用bitset，因為bitset是用來判斷那位有沒有。

///////////////////////////////////////////////////////////////
//
// lc1051. Height Checker
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1052. Grumpy Bookstore Owner
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window，往右遇到1加上，window size-1 是1扣掉。

///////////////////////////////////////////////////////////////
//
// lc1057. Campus Bikes (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，將所有配對可能通過bucket做排序，且worker從低idx到高idx，
    bikes也是從低idx到高idx，這樣的話，對同一個slot，先選低worker id，
    若worker id相同，一定低bike id先選。

///////////////////////////////////////////////////////////////
//
// lc1059. All Paths from Source Lead to Destination
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc802。
(1) dfs recursion，遇到dest檢查是終點(dst沒有指向其他點)，遇到visit[i]
    若visit[i] != -1表示之前走過，直接return。
    也可用visit表示當前路徑下走過的點，若遇到代表有環，return false。

///////////////////////////////////////////////////////////////
//
// lc1060. Missing Element in Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search
    func(idx)表示到idx為止missing number的個數。
    注意邊界問題，if k > func(arr.size()-1)，
    return arr[left] + k-func(left)
    otherwise
    return arr[left-1] + k-func(left-1)

///////////////////////////////////////////////////////////////
//
// lc1061. Lexicographically Smallest Equivalent String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

都是用union find
(1) 當ap != bp，因為要找同一group最小的，我們可以在接parent時，將大的往小的接，
    這樣保證root of union一定是最小。
(2) 用set來把同一個union的收集起來。

///////////////////////////////////////////////////////////////
//
// lc1063. Number of Valid Subarrays (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個升序stack，對於每一個element在stack里表示，到目前為止以這個
    element為起始點到當前num還是合法的subarray。
    res += sk.size() for each num in nums
    time: O(n), space: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1064. Fixed Point
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本binary search。

///////////////////////////////////////////////////////////////
//
// lc1065. Index Pairs of a String
//
///////////////////////////////////////////////////////////////

最佳解： method 2

k = # of words, m = len of text, n = avg len of a word
(1) brute force
    time: O(kmn)
(2) trie tree
    time: O(kn+m^2)

///////////////////////////////////////////////////////////////
//
// lc1071. Greatest Common Divisor of Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用輾轉相除去算即可，因為這裡整除代表str1的首str2.size()一定要是str2，
    若不是，即無法相除，return ""。

///////////////////////////////////////////////////////////////
//
// lc1072. Flip Columns For Maximum Number of Equal Rows (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找flip後最多一樣是0 or 1的個數，所以紀錄每個row出現的次數，次數越多
    表示對這些次數多得column flip，得到的結果一定是最大數量的 0 or 1 rows。

///////////////////////////////////////////////////////////////
//
// lc1079. Letter Tile Possibilities (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc047。
    dfs，檢查當前若和上一個一樣且上一個也是未visit，當前跳過。
        要未visit的才跳過是因為未visit表示屬於同層，visit表示上一層處理過。
        比較有沒有重複都是要同層的。
    若字符不是排序過後 如"ABA"，則用(1-2)

///////////////////////////////////////////////////////////////
//
// lc1080. Insufficient Nodes in Root to Leaf Paths
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) (a) Go to leaf to check if limit > 0.
    (b) for every internal node, if return child is both NULL, 
        it means that this node is insufficient node. So we return NULL.

///////////////////////////////////////////////////////////////
//
// lc1081. Smallest Subsequence of Distinct Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc316相同。

///////////////////////////////////////////////////////////////
//
// lc1085. Sum of Digits in the Minimum Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到最小值。

///////////////////////////////////////////////////////////////
//
// lc1086. High Five (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) counting sort
(2) partial sort

///////////////////////////////////////////////////////////////
//
// lc1087. Brace Expansion
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本permutaion的dfs

///////////////////////////////////////////////////////////////
//
// lc1089. Duplicate Zeros (看)* 第一種方法
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先計算額外空間 = 0的數量，再來用一指針j從尾巴開始，另一個指針從原arr尾巴
    開始，若--j < n才assign當前值 -> a[j] = a[i] (往後位移一個)，
    且若arr[i] = 0，且--j < n，assign a[j] = 0。
(2) 對於重複的插入0，並pop_back。

///////////////////////////////////////////////////////////////
//
// lc1090. Largest Values From Labels
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) priority queue

///////////////////////////////////////////////////////////////
//
// lc1091. Shortest Path in Binary Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1094. Car Pooling
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc731，lc253。
    利用一array紀錄人數，注意在結束的時候要扣掉人數。
    cnt[trip[i][1]] += trip[i][0];
    cnt[trip[i][2]] -= trip[i][0];
    traverse array累加capacity，若大於limit，return false。

///////////////////////////////////////////////////////////////
//
// lc1095. Find in Mountain Array (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用binary search先找到peak index，再來對兩邊的的arr分別做一次
    binary search。

///////////////////////////////////////////////////////////////
//
// lc1099. Two Sum Less Than K
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort then two pointers。

///////////////////////////////////////////////////////////////
//
// lc1100. Find K-Length Substrings With No Repeated Characters (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window，看clean code。

///////////////////////////////////////////////////////////////
//
// lc1101. The Earliest Moment When Everyone Become Friends (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find with path compression and union by size.
    先sort，一旦size == N，return time。
    union by size：只有union head的parent指向union size。
    這樣可以不用額外創一個空間儲存每一個union的size。

///////////////////////////////////////////////////////////////
//
// lc1102. Path With Maximum Minimum Value (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用Dijkstra找maximun path from source，且這個maximum表示路徑中的最小值
    是所有路徑最大的。算是Dijkstra的變形。

///////////////////////////////////////////////////////////////
//
// lc1103. Distribute Candies to People (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 每次分num個糖果，直到不能分為止。
    time:O(sqrt(n))

    we give out candies x times since the total number of candies is n, 
    then x*(x+1)/2 = n or O(x^2) = O(n) or O(x) = O(sqrt(n)).

    因為1+2+3+...+x = n
    跑x次，x(x+1)/2 = n -> time: x = O(sqrt(n))

///////////////////////////////////////////////////////////////
//
// lc1104. Path In Zigzag Labelled Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找出對稱性，除了第一個以外每個都是當前層級的對稱點。
    當前層級區間: res[i] = pow(2,i) - 1 + pow(2,i+1) - res[i+1]。

///////////////////////////////////////////////////////////////
//
// lc1105. Filling Bookcase Shelves (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp[i]表示到第i本書的最小高度
    dp[i] =  min(dp[i], dp[j-1] + h)
    j from i to 1
    h = max(h, books[j-1][1])
    且w要在max_width範圍內。

///////////////////////////////////////////////////////////////
//
// lc1108. Defanging an IP Address
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) inplace replacement，從後往頭走。
(2) 一般linear search。

///////////////////////////////////////////////////////////////
//
// lc1109. Corporate Flight Bookings (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將res[i] += res[i-1]
    若一個兼具為a~b，則在b+1 設置 -v
    這樣在b+1累加的可以扣掉。

///////////////////////////////////////////////////////////////
//
// lc1110. Delete Nodes And Return Forest
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用set來儲存delete node，後序由底層往上去扣除刪掉的點，postorder。

///////////////////////////////////////////////////////////////
//
// lc1111. Maximum Nesting Depth of Two Valid Parentheses Strings (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要找到max(depth(a), depth(b))是minimal，把重點放在nested ()
    ex: ((()))，若都給同一個，如a或b，一定會太大，最好的方式就是將這些平均分給
    a和b，所以輪流給。也就能將maxdepth of input分成兩半，max(a和b的depth)
    一定是最小的。

///////////////////////////////////////////////////////////////
//
// lc1114. Print in Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用counter和contition variable來控制順序。

///////////////////////////////////////////////////////////////
//
// lc1118. Number of Days in a Month
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation，閏年400潤一次，百年不潤，四年潤一次。

///////////////////////////////////////////////////////////////
//
// lc1119. Remove Vowels from a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one time pass push_back。

///////////////////////////////////////////////////////////////
//
// lc1120. Maximum Average Subtree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder。

///////////////////////////////////////////////////////////////
//
// lc1122. Relative Sort Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用counting sort，先計算各個數字的出現次數，再對於arr2的數字去填入res，
    再將不屬於arr2的數字從0~1000依序填入。

///////////////////////////////////////////////////////////////
//
// lc1123. Lowest Common Ancestor of Deepest Leaves (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 一次postorder，高度從最底層開始算(深度是由上往下算)，
    若左子樹高度 = 右子樹高度，return root。
    若左子樹高度 > 右子樹高度，return left 
                        (此left為遞迴return值，並不一定是root->left)。
    若左子樹高度 < 右子樹高度，return right 
                        (此right為遞迴return值，並不一定是root->right)。

(2) 兩次postorder，第一次找最大深度，第二次跑lc236找最小共同祖先。

///////////////////////////////////////////////////////////////
//
// lc1124. Longest Well-Performing Interval (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) > 8 ，cnt++, <= 8，cnt--
    要有最長的subarray，表示cnt == 1，因為正負都抵銷掉，然後再多一個1。
    想像cnt <= 0，為什麼要找cnt-1位置？因為中間和=1，若找cnt-2的位置，
    這一定在cnt-1之後，且忽略到一個1，所以cnt-1的位置必定是離當前位置最長的
    subarray起始點。

///////////////////////////////////////////////////////////////
//
// lc1128. Number of Equivalent Domino Pairs (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc049，lc1048。

(1) 利用bit operation去encode每個pair做出id。

///////////////////////////////////////////////////////////////
//
// lc1129. Shortest Path with Alternating Colors (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為有紅藍兩色，建立data structure {node, color}，表示這個點只能由
    color edge 連過來。從零開始用bfs。初始化個點最大path為2 * n，n為總數。

    其實最大是n*2-3：
    The maximum result happens when in a path from 0 to target, 
    all the intermediate nodes (excluding 0 and target) have 
    an additional self-edge. e.g.

    red_edges = [[0, 1], [1, 2], [2, 3]]
    blue_edges = [[1, 1], [2, 2]]
    n = 4
    The minimum step to reach 3 is 5 steps, because all intermediate 
    nodes 1 and 2 contain self-edges. In other words, 
    the maximum result can be 2 * (n - 2) + 1.

///////////////////////////////////////////////////////////////
//
// lc1130. Minimum Cost Tree From Leaf Values (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n^2)：greedy。
    每次遍歷一遍找到乘積最小的並刪掉較小的那一個數。
(2) O(n)：
    類似lc1019，使用stack。
    維持降序陣列在stack，當遇到第一個比陣列尾巴大的，要去除尾八，並且對
    尾巴左邊和當前比他大的中去取小的和(去除的值，也就是本來的尾巴)相乘，
    結束後再對陣列尾八繼續坐上述比較，直到沒有尾巴比當前小。
    最後將陣列兩兩相乘(這些為降序陣列)。
    原因：要找到兩倆乘積最小，若是降序則右乘回來，若任三個存在中間最小，則優先處理。

    如果題目要求non-leaf node是smallest node value of subtree，
    就要用升序陣列。

///////////////////////////////////////////////////////////////
//
// lc1133. Largest Unique Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bucket sort，從後面往前遍歷，看到第一個cnt == 1，return。

///////////////////////////////////////////////////////////////
//
// lc1135. Connecting Cities With Minimum Cost (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先將vector依照cost排序，若依一邊長兩個點的parent不同，連接他們，
    並res += cost，直到連接了n-1個node為止。
    union find
    類似lc721。

///////////////////////////////////////////////////////////////
//
// lc1136. Parallel Courses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc207，要修這門課，所有先修課必須在之前的學期修掉：洋蔥法bfs。

///////////////////////////////////////////////////////////////
//
// lc1137. N-th Tribonacci Number
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 一般for loop
(2) 利用一 array with fix size 3，這裏是3因為Tn_3 = Tn_2 + Tn_1 + Tn
    這樣的話，每次算新的就是val = sum(arr of element)，且dp[current_idx%3] = val

///////////////////////////////////////////////////////////////
//
// lc1140. Stone Game II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp recurtion
    dp[i][m]表示第從尾巴到第i個pile拿最多的數量，其實就是可以算出對方拿最小的，這樣我
    就是最大的。
    dp[i][m] = psum[i] - min(dp[i+x][max(x,m)]), for x = 1 ~ 2*m

///////////////////////////////////////////////////////////////
//
// lc1143. Longest Common Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1035，可用O(n) space，dp iteration。

///////////////////////////////////////////////////////////////
//
// lc1145. Binary Tree Coloring Game (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於x可以將樹分成三部分，x->left, x->right, 除了x->left, x->right, x的其他node
    數量，從這三部分中選取最大的數量，若 > n/2，return true。
    *** follow up
    Alex and Lee are going to play this turned based game.
    Alex draw the whole tree. root and n will be given.
    Now Lee says he want to color the first node.

    Return true if Lee can ensure his win, otherwise return false
    Could you find the set all the nodes, that Lee can ensure he wins the game?
    What is the complexity of your solution?

    對於每個點算出left child，right child，以及parent以外的個數，任一兩個>the rest的話，
    lee 就會贏。

///////////////////////////////////////////////////////////////
//
// lc1146. Snapshot Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) data structure: unordered_map<int, map<int, int>> record
    對每一格index，存他的版本和該版本的val。
    利用upper_bound去找到最大的版本 < snap_id。
    get: O(logn)
    set: O(logn)
    initial: O(nlogn)
    snap: O(1)
(2) 用binary search and unordered_map<int, vector<pair<int,int>>> record
    get: O(logn)
    set: O(1)
    initial: O(n)
    snap: O(1)

///////////////////////////////////////////////////////////////
//
// lc1150. Check If a Number Is Majority Element in a Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，找到第一個index，然後check nums[i + n/2] == nums[i]。

///////////////////////////////////////////////////////////////
//
// lc1152. Analyze User Website Visit Pattern (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc937。
    這題在於使用者取其visit pattern，因visit by the most users，單一user
    對同一個pattern只會visit一次，可用unordered_map<user_name, map<time_stamp, websit>>
    去紀錄，用三個for迴圈找出所有visit pattern by a user。

///////////////////////////////////////////////////////////////
//
// lc1155. Number of Dice Rolls With Target Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc70，lc518。
(1) iteration 解法類似lc494。
    因為可以有顛倒順序，amount要在外面，內圈則為dice。
(2) recursion，解法類似lc494。

///////////////////////////////////////////////////////////////
//
// lc1160. Find Words That Can Be Formed by Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) cnt(26)，若--cnt[words[i]][j] < 0，valid = false。

///////////////////////////////////////////////////////////////
//
// lc1161. Maximum Level Sum of a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs，用queue。

///////////////////////////////////////////////////////////////
//
// lc1162. As Far from Land as Possible
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs with queue。
    類似lc934。

///////////////////////////////////////////////////////////////
//
// lc1163. Last Substring in Lexicographical Order (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) l: max subarray start index
    r: current subarray start index
    去找到第一個 s[l+d] < s[r+d]，update l = max(l+d+1, r)
    為什麽不只要l = r，因為 'aaaaac'，l = l+d+1可以直接跳到c，節省時間，
    且r = l+1，從下一個位置開始重新搜尋。
    若s[l+d] > s[r+d]，update r += d+1，從這個位置開始重新搜尋，前面
    一定都比s[l+d]小。
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1165. Single-Row Keyboard
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) record index

///////////////////////////////////////////////////////////////
//
// lc1167. Minimum Cost to Connect Sticks (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy method，先將小的合併，之後總和會比較小 -> 我們要小的，代表層層迭代
    過程中，若小的越早合併，之後小的佔結果比例會較高，相反，若大的先合併，每次疊起來，
    最大的每次都會被加到。
    所以是用priority queue。

///////////////////////////////////////////////////////////////
//
// lc1169. Invalid Transactions
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 不用map，用四個vector紀錄訊息，跑一個n^2 for loop確認每個交易是不是invalid，
    最後跑一個n loop確認invalid的交易丟到res中。

///////////////////////////////////////////////////////////////
//
// lc1170. Compare Strings by Frequency of the Smallest Character
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，從尾巴往前累加cnt，對每一個query string，
    return cnt[f]。
    note: cnt[f]表示 所有words 其smallest ch 個數 > f的個數總和。

///////////////////////////////////////////////////////////////
//
// lc1171. Remove Zero Sum Consecutive Nodes from Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc437，lc560，lc974。
    利用prefix_sum，注意刪除的中間段必須把map中的sum也清除，用erase。

///////////////////////////////////////////////////////////////
//
// lc1176. Diet Plan Performance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window。

///////////////////////////////////////////////////////////////
//
// lc1180. Count Substrings with Only One Distinct Letter
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 判斷當前ch和last ch，若不一樣，更新。

///////////////////////////////////////////////////////////////
//
// lc1184. Distance Between Bus Stops
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) split to two array

///////////////////////////////////////////////////////////////
//
// lc1186. Maximum Subarray Sum with One Deletion (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc053.cpp。
    分成兩個case，主要是這兩個case都維持一個min，
    a. maxNoDelete就是lc053。
    b. maxWithDelete：考慮若當前要delete，就用上一輪的maxNoDelete，
       不delete就用maxWithDelete+arr[i]。

///////////////////////////////////////////////////////////////
//
// lc1188. Design Bounded Blocking Queue (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用unique_lock做write，shared_lock做read，condition_variable
    等待其他thread完成一定條件後解鎖，來做write。

///////////////////////////////////////////////////////////////
//
// lc1189. Maximum Number of Balloons
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，對所求的取min(l和o要除以2)。

///////////////////////////////////////////////////////////////
//
// lc1190. Reverse Substrings Between Each Pair of Parentheses (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) stack，initial sk = {""}，每次遇到新的'('，sk.push_back("")。
    O(n^2) time
(2) two pass，記錄每個pair，然後對於pair去走，只要碰到'('或')'，換方向。
    O(n) time

///////////////////////////////////////////////////////////////
//
// lc1192. Critical Connections in a Network (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用rank來判斷有沒有走過，若dfs return的rank > 當前rank，這edge要被加入，
    因為dfs往後的過程沒有cycle，有cycle的話return value一定 <= 當前 rank。
    另外遇到parent需要跳過。

///////////////////////////////////////////////////////////////
//
// lc1195. Fizz Buzz Multithreaded
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1188

///////////////////////////////////////////////////////////////
//
// lc1196. How Many Apples Can You Put into the Basket
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，O(1000 + N)，若Ｎ>>1000，bucket sort效果優於nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1197. Minimum Knight Moves (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use dfs + memorization

note that (1,1), (2,0), (0,2) would be special cases, these
three cost 2 step
The moment you reach 0,2 or 2,0 or 1,1 (visualize in the real chess board) 
the knight cannot move further to 0,0 or might go into negative axis, 
the smartest way is to if you are in (0,2) move the night to (2,1) 
then from there it could move to (0,0)..this takes 2 move. 
same applies for (1,1) and (2,0) too

why only (a) abs(x-1) abs(y-2) and (b) abs(x-2) abs(y-1)
This is because you are counting steps (and walking backwards) 
as you traverse from x,y to 0,0. 
The only way to reach 0.0 from x,y (x>0, y>0) is to either try (x-1,y-2) or (x-2,y-1)

time: O(m*n), m = x, n = y

(2) bfs
time: O(n^2), n = 300

///////////////////////////////////////////////////////////////
//
// lc1198. Find Smallest Common Element in All Rows
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) binary search
    因為每一個row都是有序，我們可以用last_start紀錄是一輪找到的位置來做這一輪
    開始的位置，再往前不用找的原因是一定比當前target還要小。
(2) 依照左到右上到下的方式搜尋，第一個滿足n個的一定是smallest common element。

///////////////////////////////////////////////////////////////
//
// lc1200. Minimum Absolute Difference
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，因為要找最小difference的所有組合，一定是相鄰兩個去做比較。

///////////////////////////////////////////////////////////////
//
// lc1202. Smallest String With Swaps (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find with path compression，compare with union size。
    將同一union的index放在一起，由小到大，然後sort後一一填入。

///////////////////////////////////////////////////////////////
//
// lc1207. Unique Number of Occurrences
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算每個數字出現次數。

///////////////////////////////////////////////////////////////
//
// lc1209. Remove All Adjacent Duplicates in String II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) stack iteration，類似lc723。
follow up: >= k
    (a) 先檢查若跟最後一個不一樣，判斷最後一個有沒有>=k，若有，pop
    (b) 再來判斷最後一個有沒有和自己一樣，若有cnt++，若沒有，push {1}。
    (c) 結束loop後檢查最後一個有沒有>=k，若有pop。
    注意只有在遇到和最後一個不同才去檢查有沒有>=k因為要一次移除所有相同的。

///////////////////////////////////////////////////////////////
//
// lc1213. Intersection of Three Sorted Arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當三個不一樣時，找出最大值，update其他兩個到至少比最大值大或相等。

///////////////////////////////////////////////////////////////
//
// lc1214. Two Sum BSTs (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 用stack做inorder traversal，類似lc1305。
(2) 用recursion，確認當前有沒有符合，若沒有，往左和往右去找。

///////////////////////////////////////////////////////////////
//
// lc1217. Play with Chips
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為移動一格為cost 1，移動兩格cost 2，所以若都是奇數位置或偶數位置，cost = 0，
    因此計算odd & even次數，reutrn min(odd, even)。

///////////////////////////////////////////////////////////////
//
// lc1219. Path with Maximum Gold
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 一般dfs。

///////////////////////////////////////////////////////////////
//
// lc1221. Split a String in Balanced Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算左右值，相消=0，res++。

///////////////////////////////////////////////////////////////
//
// lc1227. Airplane Seat Assignment Probability (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) f(n) = 1/n + 1/n * (n-2) * f(n-1)。
    (a) the 1st person gets his/her own seat. (with probability 1/n). 
        Then the n-th person is sure (with probability 1) to get the n-th seat.
    (b) the 1st person gets the n-th person's seat. (with probability 1/n). 
        Then the n-th person cannot (with probability 0) get the n-th seat.
    (c) the 1st person gets a seat between 2 and n-1 (with probability (n-2)/n). 
        Assume the 1st person gets a-th seat. Then in the next round, we have 3 choices again:
    3.1) if the a-th person gets 1st seat (with probability 1/(n-1)), 
         then this is just like 1st and a-th person swap their seats, 
         it never affect our result for the n-th person.
    3.2) if the a-th person gets n-th seat (with probability 1/(n-1)), 
         game over.
    3.3) if the a-th person gets a seat which is not 1st or n-th, 
         (with probability (n-1-2)/(n-1)), we jump into a loop.
(2) 利用數學歸納法得證 n > 1，f(n) = 0.5。

///////////////////////////////////////////////////////////////
//
// lc1228. Missing Number In Arithmetic Progression (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n) search
(2) binary search，利用a[0]+mid*d == a[mid]來判斷從0到mid為止有沒有都
    等差。
    d = (arr.back()-arr[0])/arr.size()。

///////////////////////////////////////////////////////////////
//
// lc1229. Meeting Scheduler
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找opverlap
    max(start1, start2) <= min(end1, end2)

///////////////////////////////////////////////////////////////
//
// lc1231. Divide Chocolate (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，類似lc410, lc1011。
    注意和上面兩題不同的是，我們要找minimum of subarray sum
    上面兩題找得是maximum of subarray sum
    We want each cut size >= mid. 
    We are binary searching minimum total sweetness.

///////////////////////////////////////////////////////////////
//
// lc1232. Check If It Is a Straight Line
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 斜率轉換，avoid divide by zero condition。
                (y2-y1) / (x2 - x1) == (y3-y2) / (x3 - x2) 
    is equal to 
                (y2-y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)

///////////////////////////////////////////////////////////////
//
// lc1234. Replace the Substring for Balanced String (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window
    若要變成balance array，想像一個window，若outside window的數量都比
    n/4小，表示裡面可以任意改動成balanced，所以要找最小的subarray，且
    這個subarray的外面四個字元都 <= n/4。
    time：O(n)
    space：O(1)

///////////////////////////////////////////////////////////////
//
// lc1235. Maximum Profit in Job Scheduling (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一map<int,int> dp表示map[time] = profit，到time為止最大profit
    對endtime, starttime, profit, 做sort
    對當前job，找到上一個time <= job.starttime, use prev(upper_bound)
    
    **  不用lower_bound是因為，若當前沒有job.starttime in dp，要用prev，若有，
        不能用prev，但用upper_bound，只要prev(upper_bound)就可以解決，
        類似lc1146。
    
    cur = dp[last_time] + job.profit
    若cur > dp.rbegin()->profit then dp[job.endtime] = cur;

///////////////////////////////////////////////////////////////
//
// lc1236. Web Crawler
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion

///////////////////////////////////////////////////////////////
//
// lc1243. Array Transformation (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，紀錄nums[i]為prev，作為下一輪使用。

///////////////////////////////////////////////////////////////
//
// lc1244. Design A Leaderboard
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用兩個map，一個set of pair，記錄每個分數和他的名字，
    另一個key:名字，value:分數。

///////////////////////////////////////////////////////////////
//
// lc1245. Tree Diameter
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 類似lc310，維持當前還沒用的剩餘node，while (n > 1)，若剩1表示2*res，
    對稱的。
    若n = 0，表示不對稱，2*res - 1。

(2) 計算以每個node為root的最大path，且不能走過parent node的點，不然會無窮
    迴圈。

///////////////////////////////////////////////////////////////
//
// lc1247. Minimum Swaps to Make Strings Equal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 收集xy和yx pattern，因為要最小的swap，先去看xy自己能不能組完，yx也是，
    也就是res += (xy/2 + yx/2)，再來 xy % 2 和 yx % 2 表示用剩下來的，
    這一定是0個或1個，若只有其中是一個，return -1，若兩個都是1，表示可以swap，
    方法數 = 2，兩個都是0，維持原狀。

///////////////////////////////////////////////////////////////
//
// lc1248. Count Number of Nice Subarrays (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

類似lc992。
(1) use atmost(k) - atmost(k-1)
    O(1) space，two pass
(2) 992 method 2。
    O(1) space，one pass
(3) 維持一個max size k的queue，表示當前odd num的index。
    若size == k，res += que.front()-last+1。
    若size > k，last = que.front()+1，que.pop()。
    O(k) space，one pass

///////////////////////////////////////////////////////////////
//
// lc1249. Minimum Remove to Make Valid Parentheses (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc301。

(1) stack iteration，將不合法得改成'*'。

///////////////////////////////////////////////////////////////
//
// lc1252. Cells with Odd Values in a Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(m*n + l)，l: length of indeces
    紀錄出現過的row和col次數，遍歷一次matrix，看當前的row和col的合是不是odd。

(2) O(m + n + l)，計算被點到odd次數的row數量和col數量
    return even_row * odd_col + even_col * odd_row。

///////////////////////////////////////////////////////////////
//
// lc1254. Number of Closed Islands
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 做dfs，碰到邊就return 1。
(2) 先將四邊做dfs，再對內部做dfs。

///////////////////////////////////////////////////////////////
//
// lc1257. Smallest Common Region (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立tree map，from bottom to top，然後建立visit map，把region1 走過的
    都插入，再來traverse region2 parent path，若任一點在visit有看過，r
    return這一點。
(2) 建立tree map，from top to bottom，再來用一般lowest common ancestor
    去做。

///////////////////////////////////////////////////////////////
//
// lc1260. Shift 2D Grid
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算出最終column位置 by i+shift，shift = k % col
    計算共同往下shift的變數times = k / col。
    shift也可代表額外往下shift 1 的個數，從col-1往前shift個column都要額外
    往下shift 1。

///////////////////////////////////////////////////////////////
//
// lc1261. Find Elements in a Contaminated Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use bit set，save memory。
(2) use hash set

///////////////////////////////////////////////////////////////
//
// lc1265. Print Immutable Linked List in Reverse (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

(1) 一般recursion解法
(2) 先計算一次list長度，再利用雙loop迴圈，每次印最後一個node的value。
(3) 將node存到size為sqrt(n)的stack。

///////////////////////////////////////////////////////////////
//
// lc1266. Minimum Time Visiting All Points
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，因為若兩者有差，會走完共同的，然後再多走差的數量，這就表示
    兩者之間走的距離就是max(diffx, diffy)。

///////////////////////////////////////////////////////////////
//
// lc1268. Search Suggestions System (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 先將string lexicographically排序，這樣會有一個性質：
    如果a[i] is prefix of a[j] -> a[i] is prefix of x, x from i+1~j-1。
    所以我們從上一次起始點 last_start 往後開始搜尋第一個word >= search word，
    也就是new_start，開始搜尋，然後更新start place from last_start to new start。
    time: O(log(N)) for each query
(2) 直接用set，lower_bound為 O(log(N))

///////////////////////////////////////////////////////////////
//
// lc1271. Hexspeak
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) turn string into long long int and transformed into hex type。

///////////////////////////////////////////////////////////////
//
// lc1272. Remove Interval
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc986。
    對於有交集的，找出沒有在remove interval中的，分三case
    a. 沒交集
    b. 交集且interval[0] < start
    c. 交集且interval[1] > end

///////////////////////////////////////////////////////////////
//
// lc1273. Delete Tree Nodes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從nodes-1跑到1，value[parent[i]] += vallue[i]。
    且res[i]，表示當前i為root的subtree中所有不能抵消的點。
    若value[i] != 0，要把這些點給parent[i]。
    即res[parent[i]] += res[i]。
(2) build tree，跑一遍postorder，若sum == 0，return nodes = 0。

///////////////////////////////////////////////////////////////
//
// lc1274. Number of Ships in a Rectangle
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: T(n) = 4*T(n/4)+c = O(n)
    注意邊界問題。

///////////////////////////////////////////////////////////////
//
// lc1275. Find Winner on a Tic Tac Toe Game
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc348。

///////////////////////////////////////////////////////////////
//
// lc1277. Count Square Submatrices with All Ones (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc221。
    dp[i][j] means the size of biggest square with A[i][j] as bottom-right corner.
    dp[i][j] also means the number of squares with A[i][j] as bottom-right corner.
    O(n^2)
(2) 用prefix sum，O(n^3)，類似lc1314。

///////////////////////////////////////////////////////////////
//
// lc1279. Traffic Light Controlled Intersection (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1188，但不用conditional variable。

///////////////////////////////////////////////////////////////
//
// lc1281. Subtract the Product and Sum of Digits of an Integer 
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) val %= n，sum += val，product *= val。

///////////////////////////////////////////////////////////////
//
// lc1282. Group the People Given the Group Size They Belong To (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持gp(n+1)，
    對於group size，如 = 3，將 = 3的idx收集，直到gp[3].size() == 3，然後push到
    res，並清空gp[3]，這樣就可以依序將所有同一個group size的人收集。
(2) sort idx by group size，一一填入。

///////////////////////////////////////////////////////////////
//
// lc1283. Find the Smallest Divisor Given a Threshold
//
///////////////////////////////////////////////////////////////

最佳解： method 1
類似875
(1) binary search，left = 1, right = max(nums)
    time: O(nlog(right))
    注意round up，可以用(nums[i]+val-1) / val。

///////////////////////////////////////////////////////////////
//
// lc1287. Element Appearing More Than 25% In Sorted Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(logN)，binary search，找出candiate first location & last location。
    類似lc33。
(2) 因為是sorted且只有一個arr[i] cnt > 25%，對每個arr[i]去檢查
    若arr[i] == arr[i+n/4]，表示arr[i]數量>25%。

///////////////////////////////////////////////////////////////
//
// lc1290. Convert Binary Number in a Linked List to Integer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit manipulation

///////////////////////////////////////////////////////////////
//
// lc1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum
    O(m*n)
    若當前i~i-len且j~j-len的方形 <= threshold，len++。
(2) prefix sum + binary search to find max side length
    O(m*n*log(m+n))

///////////////////////////////////////////////////////////////
//
// lc1293. Shortest Path in a Grid with Obstacles Elimination (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dijkstra
    time: O(kmn log kmn)
(2) bfs
    time: O(kmn)

///////////////////////////////////////////////////////////////
//
// lc1295. Find Numbers with Even Number of Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 因為maxv為10^5，可以直接用區兼職判斷，O(n)
(2) digit by digit check，O(n*k)，k為number of digit for each nums[i]

///////////////////////////////////////////////////////////////
//
// lc1296. Divide Array in Sets of K Consecutive Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

類似lc659。

(1) unordered_map
    time: O(nlogn+kn)
(2) map
    time: O(kmlogm+nlogm)

///////////////////////////////////////////////////////////////
//
// lc1299. Replace Elements with Greatest Element on Right Side (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後面走回去，維持一個最大值。

///////////////////////////////////////////////////////////////
//
// lc1302. Deepest Leaves Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs
(2) queue iteration，bfs。

///////////////////////////////////////////////////////////////
//
// lc1304. Find N Unique Integers Sum up to Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 不要用1+2+...+n-1，因為如果n很大會overflow，
    find rule。
    2*i - (n-1)

///////////////////////////////////////////////////////////////
//
// lc1305. All Elements in Two Binary Search Trees (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1214，two stack inorder traversal。
(2) 將node value放入res然後sort

///////////////////////////////////////////////////////////////
//
// lc1306. Jump Game III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1311. Get Watched Videos by Your Friends
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs + sort。

///////////////////////////////////////////////////////////////
//
// lc1313. Decompress Run-Length Encoded List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本array operation。

///////////////////////////////////////////////////////////////
//
// lc1314. Matrix Block Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc1292。
(1) 先算出dp[i][j]，表示(0,0)到(i,j)的總和
    再來res[i][j] = res[i+k][j+k] - res[i+k][j-k-1] 
                                 - res[i-k-1][j+k] 
                                 + res[i-k-1][j-k-1]

///////////////////////////////////////////////////////////////
//
// lc1315. Sum of Nodes with Even-Valued Grandparent
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，類似lc337。

///////////////////////////////////////////////////////////////
//
// lc1317. The K Weakest Rows in a Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) binary search + priority queue。
    O(m*(logn + logm) + klogm)
(2) binary search + set。
    O(m*(logn + logm) + k)

///////////////////////////////////////////////////////////////
//
// lc1319. Number of Operations to Make Network Connected
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find

///////////////////////////////////////////////////////////////
//
// lc1325. Delete Leaves With a Given Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder。

///////////////////////////////////////////////////////////////
//
// lc1329. Sort the Matrix Diagonally (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 可以將dig分類成用i-j歸類
    time: O(m*nlogd), d = min(m,n)
    space: O(m*n)
(2)
    time: O(m*n + (m+n)*(dlogd)), d = min(m,n)
    space: O(d)

///////////////////////////////////////////////////////////////
//
// lc1331. Rank Transform of an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort index，add to result array。

///////////////////////////////////////////////////////////////
//
// lc1337. The K Weakest Rows in a Matrix
//
///////////////////////////////////////////////////////////////

(1) bucket sort
    O(m*n + max(k, 100))
(2) binary search + priority queue。
    O(m*(logn + logm) + klogm)
(3) binary search + set。
    O(m*(logn + logm) + k)

///////////////////////////////////////////////////////////////
//
// lc1338. Reduce Array Size to The Half
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bucket sort
(2) priority queue

///////////////////////////////////////////////////////////////
//
// lc1339. Maximum Product of Splitted Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 兩次postorder，第一次算總和，第二次算乘積最大值。

///////////////////////////////////////////////////////////////
//
// lc1340. Jump Game V (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dag + dfs
    time: O(n)
    利用降序stack建立dag
    因為 4 2 1 5 6，d = 2
    5->1, 5->2
    6->5，其實6->1但因為這條不會是最深的，(6->5->1)在做降序sk時自動過濾掉這條
    往右降序可以把所有i左邊的都加進去，往左降序可把所有u的右邊都加進去。

    在build dag最一般就是O(nd)，但這樣會加入一些冗邊，向上面的利子，這些邊
    都不會在最深路徑裡。

    最後做dfs找最深路徑。

///////////////////////////////////////////////////////////////
//
// lc1342. Number of Steps to Reduce a Number to Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation

///////////////////////////////////////////////////////////////
//
// lc1345. Jump Game IV (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，注意走過的點，該val一定走過，所以可以將其整個vector都清空，避免再走一次。

///////////////////////////////////////////////////////////////
//
// lc1346. Check If N and Its Double Exist
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find pair of nums[i]*2 or nums[i]/2。

///////////////////////////////////////////////////////////////
//
// lc1347. Minimum Number of Steps to Make Two Strings Anagram
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算s的出現次數，扣除t的出現次數，若有負的，表示需要轉換的，把負的加總
    即為答案。
(2) 維持兩個cnt，取min(cnt1[i], cnt2[i])，表示絕對不用換的字母，加總res
    return s.size() - res。

///////////////////////////////////////////////////////////////
//
// lc1348. Tweet Counts Per Frequency (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

* n: # of record for one tweet

(1) 利用multiset<int>，lower_bound找出第一個>=startime的position
    recordTweet time: O(logn)
    getTweetCountsPerFrequency: O(logn) + O(# of record between startTime and endTime)

(2) vector<int>，linear find。
    recordTweet time: O(1)
    getTweetCountsPerFrequency: O(n)

///////////////////////////////////////////////////////////////
//
// lc1358. Number of Substrings Containing All Three Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1248 method 2。

///////////////////////////////////////////////////////////////
//
// lc1351. Count Negative Numbers in a Sorted Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc74。
(1) O(m+n)，因為row & col sorted，從右上角開始往左下角走。

///////////////////////////////////////////////////////////////
//
// lc1352. Product of the Last K Numbers (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix product，類似prefix sum
    若遇到0，將arr = {1}。
    若k >= arr.size() ? 0 : arr.back()/arr[arr.size()-k-1];

///////////////////////////////////////////////////////////////
//
// lc1353. Maximum Number of Events That Can Be Attended (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort events。
    利用min priority queue，維持一d表示當前available time，
    將所有start == d 的end加入queue，並檢查queue中的end若 < d，都pop。

///////////////////////////////////////////////////////////////
//
// lc1356. Sort Integers by The Number of 1 Bits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count bits，計算有幾個一有兩種做法：
    (a) cnt += n&1, n >>= 1
    (b) cnt++, n = n&(n-1)

///////////////////////////////////////////////////////////////
//
// lc1359. Count All Valid Pickup and Delivery Options (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) for n-1 pairs, the first one can be inserted into 2*(n-1)+1
    positions, and the second one can be inserted into 2*n positions
    so # of methods are (2*n-1) * 2*n
    因為有順序，要/2，所以為 (2n-1)*n。

///////////////////////////////////////////////////////////////
//
// lc1361. Validate Binary Tree Nodes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs
(2) dfs

///////////////////////////////////////////////////////////////
//
// lc1365. How Many Numbers Are Smaller Than the Current Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bucket sort，bucket[i]表示所有比i小的數量總和。
    time: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1366. Rank Teams by Votes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每個ch計算得到的votes數量。
    m: # of votes, n: # of teams
    count votes: O(m*n)
    sort: O(n^2logn)

///////////////////////////////////////////////////////////////
//
// lc1367. Linked List in Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前點，直接對link list往下找，若都找到reutrn true，不然就遞迴。

///////////////////////////////////////////////////////////////
//
// lc1370. Increasing Decreasing String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) buckeet sort。

///////////////////////////////////////////////////////////////
//
// lc1372. Longest ZigZag Path in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，維持當前node是parent的left還是right direction。
    若是left，則取自己right child return的value，反之。

///////////////////////////////////////////////////////////////
//
// lc1376. Time Needed to Inform All Employees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs
(2) dfs

///////////////////////////////////////////////////////////////
//
// lc1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1380. Lucky Numbers in a Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space
    let A(i,j) be the min of row i, max of col j,
    if there exists another A(i',j') as lucky number,
    (1) A(i',j') > A(i,j') > A(i, j)
    (2) A(i',j) > A(i',j')
    so A(i',j) > A(i,j)
    based on lucky number definition, its a contradiction,
    so there exists only one lucky number in a matrix.

(2) O(m+n) space，維持rowv，colv表示該row的最小值和該col的最大值。

///////////////////////////////////////////////////////////////
//
// lc1381. Design a Stack With Increment Operation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用inc array，inc[i]，表示需要加到0~i，當前若pop，inc[i-1] += inc[i]
    並且將pop value += inc[pop index]。
    time: O(1)。
    space: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1382. Balance a Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) inorder + postorder
    time: O(n)，space: O(n)

follow up: O(1) space DSW algo
https://leetcode.com/problems/balance-a-binary-search-tree/discuss/541785/C%2B%2BJava-with-picture-DSW-O(n)orO(1)
** dont need to write code but briefly explain how it works
(a) Convert the initial tree into a vine. By doing right rotations, 
    we flatten a tree into a 'linked list', where the head is the former leftmost node, and tail - former rightmost node.
(b) As you convert the tree into a vine, count the total number of nodes in cnt.
(c) Calculate the height of the closest perfectly balanced tree: h = log2(cnt + 1).
(d) Calculate the number of nodes in the closest perfectly balanced tree: m = pow(2, h) - 1.
(e) Left-rotate cnt - m nodes to cover up the excess of nodes.
Note: you rotate the root node, then you rotate the right child of the new root node, 
and so on. In other words, left rotations are performed on every second node of the vine.

(f)Left-rotate m / 2 nodes.
(g) Divide m by two and repeat the step above while m / 2 is greater than zero.

///////////////////////////////////////////////////////////////
//
// lc1385. Find the Distance Value Between Two Arrays (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(m*n)，brute force
(2) O(nlogn)，先sort，
    i 表示當前index in arr1，j表示對於到目前為止的i，都0~j-1和0~i相差都>d。
    結束loop時，看i~n1-1都要放入res。

///////////////////////////////////////////////////////////////
//
// lc1387. Sort Integers by The Power Value
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) built-in sort function
(2) quick select

///////////////////////////////////////////////////////////////
//
// lc1389. Create Target Array in the Given Order (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(nlogn)，類似lc315。
    想像一下，題目要求，i < j，index[i] >= index[j]，則index[i]要往右移一位。
    可以用divide and conquer，依照最終index去做排序。
    if (index[i] + shift >= index[j]) {
        res.push_back(index[j])
        shift += 1 --> 這裡表示因為index[j]要插在index[i]前面，shift要加一。
    } else {
        res.push_back(index[i]+shift) --> update index[i]最終位置，並且
                                          放到res裡。
    }
(2) O(n^2)，一般insertion方法。將i開始全都往後移一位。

///////////////////////////////////////////////////////////////
//
// lc1391. Check if There is a Valid Path in a Grid (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前，先到下一點，再對下一點back回去，若可以回到當前點，表示下一點
    是合法圖形。
    用visit來判斷下一點有沒有走過，若有就跳過。加入queue就標記走過。

///////////////////////////////////////////////////////////////
//
// lc1394. Find Lucky Integer in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1395. Count Number of Teams (看)*
//
///////////////////////////////////////////////////////////////

(1) O(n^3)，暴力解。
(2) 對於每個candidate，跑一次回圈
    維持兩個變數vector<int> less, greater。
    less[0]表示在左邊比自己小，less[1]表示在右邊比自己小。
    greater[0]表示在左邊比自己大，greater[1]表示在右邊比自己大。
    res = less[0] * greater[1] + greater[0] * less[1]。

///////////////////////////////////////////////////////////////
//
// lc1396. Design Underground System (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 考慮edge case，利用map紀錄，key: start_end，value: {total_time, cnt}
    第二個map是個人資料，key: id，value: {start, start_time}

///////////////////////////////////////////////////////////////
//
// lc1399. Count Largest Group
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count digit。

///////////////////////////////////////////////////////////////
//
// lc1403. Minimum Subsequence in Non-Increasing Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。
(2) nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1408. String Matching in an Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

k average len of a word

(1) prefix trie tree
    time: O(nk^2)
    將每一個word從 word.substr(i)全部insert到trie tree中，
    並且經過的點end++，這樣代表之後我們搜尋這個word，若走到底後end > 1，
    表示至少有一個除了自己以外的word的substring是這個word。
(2) sort and find n^2
    time: O(nlogn+n^2*k)

///////////////////////////////////////////////////////////////
//
// lc1409. Queries on a Permutation With Key (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lru cache的方式去做，O(n^2)
(2) 利用bit，binary index tree。
(3) 利用segment tree。
    (2) 和 (3)都想像成range sum，arr[0,i]表示0~i的個數，也就是對於i+1位置
    中，前面有幾個number。
    因為題目要求當前number是在arr中第幾個位置，想像成每個位置都是1，那就是說
    given index i，他前面的數量就是rangesum(0,i-1)。
    另外用map紀錄number和其對應在arr的位置。

///////////////////////////////////////////////////////////////
//
// lc1413. Minimum Value to Get Positive Step by Step Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為在每個for loop step sum > 0，表示追蹤minimum sum of for loop，
    return -minv + 1。
(2) 對於每輪若sum < 1，補足到1，即 res += 1-sum。

///////////////////////////////////////////////////////////////
//
// lc1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

greedy method。
always find the largest one less than K。
(1) recursion
    Time O((logk)^2), since O(log k) Fibonacci numbers smaller than k.
    Space O(logK), can be saved by tail recursion.
(2) iteration
    Time O((logk))
    Space O(1)

///////////////////////////////////////////////////////////////
//
// lc1422. Maximum Score After Splitting a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) maxv = zeros_left + ones_right
         = zeros_left + ones_total - ones_left
         = zeros_left - ones_left + ones_total
    所以 maxv = max(maxv, zeros_left - ones_left)
    return maxv + ones_total

///////////////////////////////////////////////////////////////
//
// lc1423. Maximum Points You Can Obtain from Cards (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) sliding window，維持n-k大小的window，找最小。
    time: O(n)
(2) sliding window，先算出左邊開始大小為k總和: left
    然後跑一個k for loop，
    left -= arr[k-1-i];
    right += arr[n-1-i];
    res = max(res, left+right)
    這表示每次從left扣掉一個，right加上一個，維持大小為k的兩邊總和
    time: O(k)

///////////////////////////////////////////////////////////////
//
// lc1425. Constrained Subsequence Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc239。
(1) 用一降序deque。
    time: O(n), space: O(k)
(2) 用一priority queue，max heap。
    time: O(nlogK), space: O(K)

///////////////////////////////////////////////////////////////
//
// lc1427. Perform String Shifts
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string concatenation

///////////////////////////////////////////////////////////////
//
// lc1428. Leftmost Column with at Least a One
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(rlog(c))，binary search
(2) O(r+c)，類似lc240。

///////////////////////////////////////////////////////////////
//
// lc1429. First Unique Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc146 lru，用list和map紀錄list得iterator。
    find first unique: O(1)
(2) 用queue和map，map紀錄出現次數，若為1，push to que。
    find first unique: O(n)

///////////////////////////////////////////////////////////////
//
// lc1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1431. Kids With the Greatest Number of Candies
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find maxv then check if candies[i] + extra >= maxv。

///////////////////////////////////////////////////////////////
//
// lc1433. Check If a String Can Break Another String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，從0~25，計算兩者當前數量，若次數交錯，表示不能break。
(2) nlogn sort

///////////////////////////////////////////////////////////////
//
// lc1436. Destination City
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass，第一次把start place加進去，第二次對於end place看有沒有在
    set裡。

///////////////////////////////////////////////////////////////
//
// lc1437. Check If All 1's Are at Least Length K Places Away
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find last index with a[idx] == 1 and check if 
    i-idx-1 < k or not。

///////////////////////////////////////////////////////////////
//
// lc1441. Build an Array With Stack Operations
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) When we find target[i] is greater than current number, 
    just push and pop and update it until they are equal.

///////////////////////////////////////////////////////////////
//
// lc1443. Minimum Time to Collect All Apples in a Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) build graph first, start from 0, use dfs.
    We add 2 to res when we have collect all return value from
    our descendents that sum is bigger than 0 or current node is an apple.

///////////////////////////////////////////////////////////////
//
// lc1448. Count Good Nodes in Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。
(2) preorder。

///////////////////////////////////////////////////////////////
//
// lc1450. Number of Students Doing Homework at a Given Time
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本判斷interval。

///////////////////////////////////////////////////////////////
//
// lc1457. Pseudo-Palindromic Paths in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation，利用xor兩個  1
(2) set，利用set只有唯一性的特性來判斷set <=1，是的話就是回文。

///////////////////////////////////////////////////////////////
//
// lc1460. Make Two Arrays Equal by Reversing Sub-arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bucket sort
(2) a. use xor to check if bit counting is same between arr and target.
    b. check if target sum is equal to arr sum.

///////////////////////////////////////////////////////////////
//
// lc1462. Course Schedule IV
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion

///////////////////////////////////////////////////////////////
//
// lc1464. Maximum Product of Two Elements in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use pointer to linear find

///////////////////////////////////////////////////////////////
//
// lc1466. Reorder Routes to Make All Paths Lead to the City Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用rel map來判斷當前邊的關係，比如 a->b，
    rel[a].push_back({b, 1})
    rel[b].push_back({a, 0})
    這樣在做bfs就可以知道若連過去的是1，++res。

///////////////////////////////////////////////////////////////
//
// lc1469. Find All The Lonely Nodes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用tag來判斷當前node是不是lonley，
    ex: preorder(root->left, !root->right)
    ex: preorder(root->right, !root->left)

///////////////////////////////////////////////////////////////
//
// lc1470. Shuffle the Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit manipulation，把後半端作為cache，儲存前半段的所有數字，
    nums[i] = nums[j] >> 10;
    nums[i+1] = nums[j] & 1023;

///////////////////////////////////////////////////////////////
//
// lc1472. Design Browser History
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2，3

(1) two stack，history & future，注意history size 必須大於1。
    visit時，future clear.
(2) list，維持now & end，注意visit，如果++now >= arr.size()，push_back()
    否則，arr[now] = url
(3) unordered_map
    visit: map[++now] = url, end = now

///////////////////////////////////////////////////////////////
//
// lc1474. Delete N Nodes After M Nodes of a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one pass，對於n，now->next = now->next->next。這樣now不用動但可以
    一直接下一個。

///////////////////////////////////////////////////////////////
//
// lc1475. Final Prices With a Special Discount in a Shop
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) stack iteration，維持一個升序stack。

///////////////////////////////////////////////////////////////
//
// lc1477. Find Two Non-overlapping Sub-arrays Each With Target Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum，往左找到第一個arry後，再往右去找第二個array。
    並且每次都更新左邊的array長度。
    類似lc560。
(2) sliding window
    dp[i] = 到目前為止最短的array，
    res = min(res, dp[i-1] + right-left+1)
    且 維持一個變數表示到目前為止最短的array: best_so_far
    dp[right] = best_so_far。

///////////////////////////////////////////////////////////////
//
// lc1480. Running Sum of 1d Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 單純累加上一位的值。

///////////////////////////////////////////////////////////////
//
// lc1481. Least Number of Unique Integers after K Removals
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

類似lc347

(1) sort
    O(n + nlogn), space: O(logn)
(2) priority queue
    time: O(n + ulogu + mlogu), space: O(logu)
(3) bucket
    time: O(n), space O(n)

///////////////////////////////////////////////////////////////
//
// lc1485. Clone Binary Tree With Random Pointer
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 類似lc138，O(1) space, three pass，必須NodeCopy class和Node class
    一致才行
(2) 利用map，O(n) space, one pass。

///////////////////////////////////////////////////////////////
//
// lc1486. XOR Operation in an Array (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，對於start = 0, 1, 2, 4, n = 1, 1, 2, 3, .... 8

start = 0, 1, n = 1~8
[N % 4 == 1] Green Row: Ans = Number[N]
[N % 4 == 2] Yellow Row: Ans = 2
[N % 4 == 3] Red Row: Ans = Number[N] ^ 2
[N % 4 == 0] Blue Row: Ans = 0

start = 2, 3, n = 1 ~ 8
N % 4 == 1] Green Row: Ans = Number[1]
[N % 4 == 2] Yellow Row: Ans = Number[N] ^ Number[1]
[N % 4 == 3] Red Row: Ans = Number[1] ^ 2
[N % 4 == 0] Blue Row: Ans = Number[N] ^ Number[1] ^ 2

https://leetcode.com/problems/xor-operation-in-an-array/discuss/699141/Visual-Solution-Python-or-O(1)-Time-or-O(1)-Space

///////////////////////////////////////////////////////////////
//
// lc1490. Clone N-ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc133
(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1491. Average Salary Excluding the Minimum and Maximum Salary
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find

///////////////////////////////////////////////////////////////
//
// lc1493. Longest Subarray of 1's After Deleting One Element
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) maintain a sliding window with at most 1 zero.

///////////////////////////////////////////////////////////////
//
// lc1494. Parallel Courses II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 

///////////////////////////////////////////////////////////////
//
// lc1496. Path Crossing
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用set紀錄走過的。 

///////////////////////////////////////////////////////////////
//
// lc1502. Can Make Arithmetic Progression From Sequence (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) time, O(1) space
    類似lc041。
    因為要找diff，可以先找到maxv, minv算出diff
    跑一個回圈，對於是自己的點，跳過(++idx)，若不是自己的點，算位置，若沒辦法算，
    return false，最後得到自己得pos，若pos < idx，表示這個點和之前已找到的點一樣，表示重複
    ，但不可能重複，除非diff = 0，所以return false，不然arr[idx] == arr[pos]，這也表示i>pos，
    也要return false，因為如果一樣，diff會=0，一開始就跳過(++idx)，diff!=0但又有
    arr[idx] == arr[pos]表示idx != pos，會造成無窮迴圈，
    最後swap(arr[idx], arr[pos])。

(2) O(nlogn) time, O(logn) space
    sort then find difference

///////////////////////////////////////////////////////////////
//
// lc1504. Count Submatrices With All Ones
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc085
(1) 用lc085 method 1去解。
(2) 用lc085 method 2去解。
    因為要算當前高度的所有rectangle，
    sum[i] = sum[sk.back()]
    sum[i] += (i-sk.back())*dp[i]。

///////////////////////////////////////////////////////////////
//
// lc1506. Find Root of N-Ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n) space，找deg == 0的點，map紀錄。
(2) O(1) space，利用xor，只有root只會出現一次。

///////////////////////////////////////////////////////////////
//
// lc1507. Reformat Date
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 判斷長度來檢查是1 ~ 9還是 > 10來做substr。

///////////////////////////////////////////////////////////////
//
// lc1509. Minimum Difference Between Largest and Smallest Value in Three Moves
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc486。

(1) dfs recursion
(2) iteration

///////////////////////////////////////////////////////////////
//
// lc1512. Number of Good Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum

///////////////////////////////////////////////////////////////
//
// lc1518. Water Bottles (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(log(n)) time，
    res += empty / exchange
    empty = empty / exchange + empty % exchange
(2) O(1) time

The "price" of buying a refill is handing over two empties. 
However, you must have your own empty bottle to receive the refill.
Therefore after drinking the initial numBottles, 
we "keep aside" one empty for receiving the refills (therefore we do 9 minus 1) 
and trade in the remaining 8 empties to get refills @ 2 bottles/refill. 

///////////////////////////////////////////////////////////////
//
// lc1522. Diameter of N-Ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc543。

///////////////////////////////////////////////////////////////
//
// lc1525. Number of Good Ways to Split a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass dp, maintain a dp[i] means # of unique characters 
    from 0 ... i.

///////////////////////////////////////////////////////////////
//
// lc1528. Shuffle String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc041。
    swap until i == indices[i]。

///////////////////////////////////////////////////////////////
//
// lc1530. Number of Good Leaf Nodes Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，track左子樹leaf和右子樹leaf的距離和 <= d。

///////////////////////////////////////////////////////////////
//
// lc1534. Count Good Triplets
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) brute force，O(n^3)，可以在跑第三個loop時先檢查abs(a[i]-a[j]) <= a

///////////////////////////////////////////////////////////////
//
// lc1539. Kth Missing Positive Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1060。
    唯一差別是要從1開始算。

///////////////////////////////////////////////////////////////
//
// lc1541. Minimum Insertions to Balance a Parentheses String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 
    (a) when s[i] == ')' && (s[i+1] == '(' or i == s.size()-1), we need to insert one ')'; 
        Otherwise, there are two consecutive ')', and we skip the next one: i++
    (b) when every time we face two ')', subtract one '(' and check if it is < 0. 
        If yes, we need to insert one '(' and reset left to 0.
    (c) after one time pass. res += left*2 to make sure if there are not enough ')'.

///////////////////////////////////////////////////////////////
//
// lc1544. Make The String Great
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) stack
(2) two pointer
    note: 'a'^'A' = 32

///////////////////////////////////////////////////////////////
//
// lc1550. Three Consecutive Odds
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find 連續三個奇數，若遇偶數，cnt = 0。

///////////////////////////////////////////////////////////////
//
// lc1557. Minimum Number of Vertices to Reach All Nodes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找沒有in-degree的node。
*** follow up: 先對沒有in-degree的node跑一遍dfs，最後再對那些環找任一點
               做dfs。

///////////////////////////////////////////////////////////////
//
// lc1570. Dot Product of Two Sparse Vectors
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) map operation，儲存非零位置。
(2) two pointer，類似lc349，lc350。
    用vector<pair<int, int>>儲存非零位置。

///////////////////////////////////////////////////////////////
//
// lc1572. Matrix Diagonal Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: O(n)，跑一遍找對角線，若n是奇數，扣掉重複算的。

///////////////////////////////////////////////////////////////
//
// lc1573. Number of Ways to Split a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass
(2) one pass

///////////////////////////////////////////////////////////////
//
// lc1578. Minimum Deletion Cost to Avoid Repeating Letters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個sum和到目前為止最大maxv，若遇到s[i] != s[i-1]
    res += sum-maxv, sum = maxv = 0;

///////////////////////////////////////////////////////////////
//
// lc1582. Special Positions in a Binary Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc531。

(1) 對於每個row先找colsum == 1，若有，找到對應位置並搜尋row有沒有==1，
    若有，++res。
    因為每個row去搜尋row只會搜尋一次，所有點總共最多visit m*n次。
    time: O(m*n)
    space: O(1)
(2) lc531的method 2。
    time: O(m*n)
    space: O(m+n)

///////////////////////////////////////////////////////////////
//
// lc1583. Count Unhappy Friends (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n^2)，紀錄preference，這樣就可以從O(n^3)變成O(n^2)。

///////////////////////////////////////////////////////////////
//
// lc1586. Binary Search Tree Iterator II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc173。
    inorder stack traversal，將前後串連起來

///////////////////////////////////////////////////////////////
//
// lc1588. Sum of All Odd Length Subarrays (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 去計算A[i] 出現在subarry的次數
    O(n) time O(1) space
    從左邊subarray來看，有i, [i, i-1], ... [i, i-1, ..., 1, 0], i+1種選擇
    從右邊subarray來看，有i, [i, i+1], [i, i+1, ..., n-1], n-i種選擇
    所以A[i]出現在subarray共有 (i+1)*(n-i)，因為要找奇數，所以/2
    但有可能有小數點，且一定會有自己一次，所以 ((i+1)*(n-i)+1)/2;
    也可ceil((i+1)*(n-i)/2)。

    Example of array [1,2,3,4,5]
    1 2 3 4 5 subarray length 1
    1 2 X X X subarray length 2
    X 2 3 X X subarray length 2
    X X 3 4 X subarray length 2
    X X X 4 5 subarray length 2
    1 2 3 X X subarray length 3
    X 2 3 4 X subarray length 3
    X X 3 4 5 subarray length 3
    1 2 3 4 X subarray length 4
    X 2 3 4 5 subarray length 4
    1 2 3 4 5 subarray length 5

    5 8 9 8 5 total times each index was added.
    3 4 5 4 3 total times in odd length array with (x + 1) / 2
    2 4 4 4 2 total times in even length array with x / 2

///////////////////////////////////////////////////////////////
//
// lc1598. Crawler Log Folder
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，檢查 == "../" 和 != "./"即可。

///////////////////////////////////////////////////////////////
//
// lc1600. Throne Inheritance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1602. Find Nearest Right Node in Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bfs
(2) preorder morris traversal，注意計算深度問題。

///////////////////////////////////////////////////////////////
//
// lc1603. Design Parking System
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) thread safe solution，注意用mtx陣列，fix size，而不是用vector
https://stackoverflow.com/questions/16465633/how-can-i-use-something-like-stdvectorstdmutex/24170141

///////////////////////////////////////////////////////////////
//
// lc1608. Special Array With X Elements Greater Than or Equal X
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 從後往前找
(2) binary search

///////////////////////////////////////////////////////////////
//
// lc1609. Even Odd Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，和sign來判斷當前要是even level or odd level。

///////////////////////////////////////////////////////////////
//
// lc1612. Check If Two Expression Trees are Equivalent (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) preorder，利用cnt(26, 0)紀錄出現的次數
follow up: 如果root是'-'，left subtree不會被影響，right subtree sign*=-1。

///////////////////////////////////////////////////////////////
//
// lc1614. Maximum Nesting Depth of the Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) linear search。

///////////////////////////////////////////////////////////////
//
// lc1615. Maximal Network Rank (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用unordered_set記錄自己有連到幾個，跑一個O(n^2)，去算出最大的兩個邊。
    O(n^2)
    follow up: if average m is O(n), design a O(n) algo
follow up:
    1. 若最大數量的node只有一個，對於其他的node算出和最大數量的和，若這兩node有
    邊必須扣掉一。
    2. 若有兩個以上，想像若這些node 為m，若 m*(m-1)/2 > connect 這些彼此node
    的邊數量，代表一定有兩個node屬於最大數量邊，且沒有邊連這兩個，不用-1。
    note: fully connected of n nodes, its edge = n*(n-1)/2。

///////////////////////////////////////////////////////////////
//
// lc1616. Split Two Strings to Make Palindrome
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若找到不能找，換同string再去比較。

///////////////////////////////////////////////////////////////
//
// lc1619. Mean of Array After Removing Some Elements
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) sort entire array
(2) 用兩個priority queue。

///////////////////////////////////////////////////////////////
//
// lc1624. Largest Substring Between Two Equal Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find, use cnt to record position

///////////////////////////////////////////////////////////////
//
// lc1628. Design an Expression Tree With Evaluate Function (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) system design ood
    base node
    number node
    op node: addnode, subtract node, multiply node, divide node

///////////////////////////////////////////////////////////////
//
// lc1629. Slowest Key
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持最大diff和其label即可。

///////////////////////////////////////////////////////////////
//
// lc1631. Path With Minimum Effort
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1102，Dijkstra。
    time: O(mnlogmn)
    space: O(mn)

///////////////////////////////////////////////////////////////
//
// lc1636. Sort Array by Increasing Frequency
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1640. Check Array Formation Through Concatenation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map來儲存第一個pieces的type，然後對於arr的第一個數去找對應的type，
    並iterate 該pices。

///////////////////////////////////////////////////////////////
//
// lc1644. Lowest Common Ancestor of a Binary Tree II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 變形postordeder，遇到p或q，++cnt，cnt == 2才有lca。

///////////////////////////////////////////////////////////////
//
// lc1647. Minimum Deletions to Make Character Frequencies Unique
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) space
    記錄每個出現次數的字母數量，
    若cnt[i] > 1，cnt[i-1] += cnt[i-1], res += cnt[i]-1。
(2) O(1) space
    先記錄出現次數並sort。
    維持一個now_feq表示最近使用過的feq，
    若times[i] >= now_feq, --now_feq, res += times[i]-now_feq
    else now_feq = times[i]

///////////////////////////////////////////////////////////////
//
// lc1650. Lowest Common Ancestor of a Binary Tree III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc160
    O(log(n)) time O(1) space

///////////////////////////////////////////////////////////////
//
// lc1654. Minimum Jumps to Reach Home (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，建立queue with state，表示當前到position是foward or backward
    利用visit表示這個點有沒有到過，被foward到過或是backward到過。
    關於maxval，
    if (a >= b)，maxval = x+b
    if (a < b)，maxval = x+a+a+b
    https://leetcode.com/problems/minimum-jumps-to-reach-home/
    discuss/935419/Python-deque-BFS-O(max(x-max(forbidden))%2Ba%2Bb)

///////////////////////////////////////////////////////////////
//
// lc1656. Design an Ordered Stream
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個index，表示第一個空的位置，若非空，就push到res，並移到第一個空的
    位置。

///////////////////////////////////////////////////////////////
//
// lc1657. Determine if Two Strings Are Close (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) bucket sort
    if (n < 26log26) then O(26log26)。

///////////////////////////////////////////////////////////////
//
// lc1660. Correct a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs with map，利用parent map記錄自己的parent是誰，若當前自己right
    child被指過，表示自己的孩子和自己同一層，now->right = null，且自己
    的parent對自己設置null。

///////////////////////////////////////////////////////////////
//
// lc1664. Ways to Make a Fair Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc198。

(1) 維持 odd and even

///////////////////////////////////////////////////////////////
//
// lc1662. Check If Two String Arrays are Equivalent
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer searching

///////////////////////////////////////////////////////////////
//
// lc1666. Change the Root of a Binary Tree (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用recursion，當前有new parent，
    規則是如果當前now->left = new parent，則now->left = null，反之。
    old parent = now->parent
    now->parent = new parent，建立新的parent。
    且若當前砍掉連接後還有左孩子，則讓他變成右孩子。因為left child 要去接
    自己的parent: now->left = recursion(old_parent, now)。

///////////////////////////////////////////////////////////////
//
// lc1668. Maximum Repeating Substring
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大的k，repeat word for max k times and find this word
    in input string。

///////////////////////////////////////////////////////////////
//
// lc1669. Merge In Between Linked Lists
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear pass。

///////////////////////////////////////////////////////////////
//
// lc1670. Design Front Middle Back Queue
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 利用list and iterator，維持mid
(2) 利用兩個deque：left & right，left.size()-right.size() <= 1。

///////////////////////////////////////////////////////////////
//
// lc1672. Richest Customer Wealth
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find max row sum。

///////////////////////////////////////////////////////////////
//
// lc1673. Find the Most Competitive Subsequence (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用升序stack，若當前可以pop，檢查未來還有沒有足夠的element可以放入stack。

///////////////////////////////////////////////////////////////
//
// lc1676. Lowest Common Ancestor of a Binary Tree IV
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder，利用unordered set來記錄node。

///////////////////////////////////////////////////////////////
//
// lc1684. Count the Number of Consistent Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) set

///////////////////////////////////////////////////////////////
//
// lc1695. Maximum Erasure Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer，維持一subarray裡面的次數都只出現一個，類似lc3。

///////////////////////////////////////////////////////////////
//
// lc1696. Jump Game VI (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc239，用一降序deque。
time : O(n), space: O(k)
    this problem is like leetcode 239, just use a decreasing deque size k.
    More specifically, the head of the deque is the max score we can get from current index i.
    The size of deque is k because for current index i, 
    the farthest idx before i is i-k, and when we push i in to que, 
    we need to pop out any index smaller than i-k.

///////////////////////////////////////////////////////////////
//
// lc1700. Number of Students Unable to Eat Lunch
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) two pointer，計算不符合的數量，若等同於當前學生數量，return。
    O(n^2) time
    the worst case is like student [0 0 0 1 1 1], sandwich [1 0 1 0 1 0]
    and for each sandwich, we go though student array n/2 times. 
    That is, total time: n/2*n = O(n^2).

(2) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1704. Determine if String Halves Are Alike
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find

///////////////////////////////////////////////////////////////
//
// lc1708. Largest Subarray Length K (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大，直接去比較頭，若都一樣，代表是最後一個subarry
    ex: [1 1 1 1 2]，k = 3，選 [1 1 2]
*** follow up: numbers are not distinct.
    類似lc1163。
    唯一差別是不能update l = max(l+d+1, r)，只能l = r，因為這是有固定的長度k
    而不是像lc1163一樣substring沒有固定長度。
    另外多一個條件，因為限定長度k，確認現在比的r+k-1 < n才值得比。
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1710. Maximum Units on a Truck
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort，and greedy。

///////////////////////////////////////////////////////////////
//
// lc1716. Calculate Money in Leetcode Bank
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) math，O(1) time。
(2) loop，O(n) time

///////////////////////////////////////////////////////////////
//
// lc1721. Swapping Nodes in a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one pass
** follow up: change structure, maintain p1, n1, p2, n2
注意若 n1 == p2 or n2 == p1，要做相鄰的處理
且n2 == p1，要swap node，因為我們assume p1在左邊，p2在右邊做處理。

///////////////////////////////////////////////////////////////
//
// lc1725. Number Of Rectangles That Can Form The Largest Square
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find max of minlen of each rect。

///////////////////////////////////////////////////////////////
//
// lc1730. Shortest Path to Get Food
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1732. Find the Highest Altitude
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear找累加最大值。

///////////////////////////////////////////////////////////////
//
// lc1736. Latest Time by Replacing Hidden Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從左到右，找最大的數字，注意time[0]要看time[1]，time[1]要看time[0]

///////////////////////////////////////////////////////////////
//
// lc1740. Find Distance in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder

///////////////////////////////////////////////////////////////
//
// lc1753. Maximum Score From Removing Stones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找最大和最小，各扣一然後++res。

///////////////////////////////////////////////////////////////
//
// lc1754. Largest Merge Of Two Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string compare
    since at most substr will be executed n times for s1 and m times for s2.
    so total is (n+n-1+n-2+...+1) + (m+m-1+m-2+...+1) = O(n^2+m^2)

///////////////////////////////////////////////////////////////
//
// lc1758. Minimum Changes To Make Alternating Binary String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find 010101... error positions and return min(ones, n-ones)
    n-ones means 101010.... error positions.

///////////////////////////////////////////////////////////////
//
// lc1762. Buildings With an Ocean View
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) decreasing stack from left to right
(2) array search from right to left

///////////////////////////////////////////////////////////////
//
// lc1768. Merge Strings Alternately
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer

///////////////////////////////////////////////////////////////
//
// lc1769. Minimum Number of Operations to Move All Balls to Each Box
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc238。
(1) left_step表示到目前為止這個點有幾個人花的總共步數。
    left_cnt表示到目前為止有幾個1。
    right亦同。

///////////////////////////////////////////////////////////////
//
// lc1772. Sort Features by Popularity
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use stable sort with map and set

///////////////////////////////////////////////////////////////
//
// lc1773. count items matching a rule
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count

///////////////////////////////////////////////////////////////
//
// lc1780. Check if Number is a Sum of Powers of Three
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) greedy, always minus largest power of 3.
(2) 想像若 n = 3^0 + 3^2 + 3^4 = 3^0(1+3^2+3^4), 去掉一
        3^2+3^4 = 3^2(1+3^2)，去掉一
        3^2 = 3^2(1)，去掉一

        所以我們發現若n%3 == 1 可以n = (n-1)/3
                  若n%3 == 0 可以n /= 3
        若n%3 == 2，表示沒辦法約分，return false

///////////////////////////////////////////////////////////////
//
// lc1784. Check if Binary String Has at Most One Segment of Ones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為起始必為1，找到01就是代表第二個1。
(2) 從尾巴跑遇到1停，繼續跑，遇到不是0停，如果idx != -1表示有兩個以上1 block。
(2) 找邊界數量，找理說只有兩個。

///////////////////////////////////////////////////////////////
//
// lc1791. Find Center of Star Graph
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 中心點必和其他點相連。
(2) bfs

///////////////////////////////////////////////////////////////
//
// lc1796. Second Largest Digit in a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用兩個變數維持最大和第二大

///////////////////////////////////////////////////////////////
//
// lc1800. Maximum Ascending Subarray Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到數字比當前小就將sum = 當前數字。

///////////////////////////////////////////////////////////////
//
// lc1804. Implement Trie II (Prefix Tree)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) trie tree，用兩個cnt，一個代表結尾的，一個代表走過的。

///////////////////////////////////////////////////////////////
//
// lc1816. Truncate Sentence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count words

///////////////////////////////////////////////////////////////
//
// lc1822. Sign of the Product of an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count # of negative sing 

///////////////////////////////////////////////////////////////
//
// lc1824. Minimum Sideway Jumps (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) dijkstra
(2) bfs
(3) dp
    dp[0] dp[1] dp[2] 表示第ith lane最小方法數
    所以 dp[i] = min(dp[i], min(dp[i+1],dp[i+2])+1)

///////////////////////////////////////////////////////////////
//
// lc1827. Minimum Operations to Make the Array Increasing
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find diff between neighbor

///////////////////////////////////////////////////////////////
//
// lc1832. Check if the Sentence Is Pangram
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) set
(2) bit

///////////////////////////////////////////////////////////////
//
// lc1836. Remove Duplicates From an Unsorted Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本linked list operation

///////////////////////////////////////////////////////////////
//
// lc1839. Longest Substring Of All Vowels in Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到字母差值規律，用two pointer。

///////////////////////////////////////////////////////////////
//
// lc1844. Replace All Digits with Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string operation

///////////////////////////////////////////////////////////////
//
// lc1858. Longest Word With All Prefixes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc720
(1) trie tree
(2) set

///////////////////////////////////////////////////////////////
//
// lc1859. Sorting the Sentence
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) use pair to store index
(2) linear filling with the index

///////////////////////////////////////////////////////////////
//
// lc1869. Longer Contiguous Segments of Ones than Zeros
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer維持最大連續一樣的邊界。

///////////////////////////////////////////////////////////////
//
// lc1871. Jump Game VII (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bfs，對於當前位置i，
    起始點是要left = max(i+minJump, max_start+1)
    結束點是要right = min(i+maxJump, n-1)
    而max_start = right，因為這樣可以不visit一些之前就visit過的點。
    time: O(n*(maxjump-minjump))

(2) 表示到目前為止可以到的步數
    pre += dp[i-minjump]
    pre -= dp[i-maxjump-1]
    dp[i] = pre > 0 && s[i] == '0'
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1874. Minimize Product Sum of Two Arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort
(2) sort

///////////////////////////////////////////////////////////////
//
// lc1877. Minimize Maximum Pair Sum in Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort then two pointer

///////////////////////////////////////////////////////////////
//
// lc1893. Check if All the Integers in a Range Are Covered
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc253。
(1) 找出區間起始點+1，結束點的後一個減一。
    time: O(n+m)
    space: O(m)
(2) sort and find if current value in the range
    if yes, update to range[1]+1
    time: O(nlogn)

///////////////////////////////////////////////////////////////
//
// lc1897. Redistribute Characters to Make All Strings Equal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count, bucket

///////////////////////////////////////////////////////////////
//
// lc1902. Depth of BST Given Insertion Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map去找左和右最近的高度
    nlogn

///////////////////////////////////////////////////////////////
//
// lc1903. Largest Odd Number in String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find last odd number

///////////////////////////////////////////////////////////////
//
// lc1905. Count Sub Islands
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion

///////////////////////////////////////////////////////////////
//
// lc1941. Check if All Characters Have Equal Number of Occurrences
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort

///////////////////////////////////////////////////////////////
//
// lc1971. Find if Path Exists in Graph
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dfs recursion
(2) union find

///////////////////////////////////////////////////////////////
//
// lc1973. Count Nodes Equal to Sum of Descendants
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder recursion

///////////////////////////////////////////////////////////////
//
// lc1985. Find the Kth Largest Integer in the Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc215。
(1) built in function
(2) map build int lamda function

///////////////////////////////////////////////////////////////
//
// lc1991. Find the Middle Index in Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum

///////////////////////////////////////////////////////////////
//
// lc2000. Reverse Prefix of Word
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) reverse string

///////////////////////////////////////////////////////////////
//
// lc2011. Final Value of Variable After Performing Operations
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，可以發現operation[1]一定是'+'或'-'。

///////////////////////////////////////////////////////////////
//
// lc2016. Maximum Difference Between Increasing Elements
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc121。
(1) 維持minv代表開始到現在的最小值。

///////////////////////////////////////////////////////////////
//
// lc2021. Brightest Position on Street
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc253，lc729。
(1) 用map做counter。

///////////////////////////////////////////////////////////////
//
// lc2022. Convert 1D Array Into 2D Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear processing

///////////////////////////////////////////////////////////////
//
// lc2027. Minimum Moves to Convert String
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 存'x'的index，然後算個數。
(2) 遇到'x'，i+=3，++res。 
    遇到'o'，i++。

///////////////////////////////////////////////////////////////
//
// lc2039. The Time When the Network Becomes Idle
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找出第一個和最後一個message的overlap時間並且扣掉

///////////////////////////////////////////////////////////////
//
// lc2046. Sort Linked List Already Sorted Using Absolute Values
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若遇到cur->val < 0，把他connect到head，並且head = cur。

///////////////////////////////////////////////////////////////
//
// lc2049. Count Nodes With the Highest Score
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 把tree建立起來後利用postorder recursion去算每個node的score。

///////////////////////////////////////////////////////////////
//
// lc2057. Smallest Index With Equal Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用add取代mod。
    類似lc412。

///////////////////////////////////////////////////////////////
//
// lc2058. Find the Minimum and Maximum Number of Nodes Between Critical Points
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find local minimum or maximum point and compare with last one.

///////////////////////////////////////////////////////////////
//
// lc2062. Count Vowel Substrings of a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc930, lc992, lc1248, lc1358
(1) prefix sliding window

///////////////////////////////////////////////////////////////
//
// lc2068. Check Whether Two Strings are Almost Equivalent
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use cnt array and find the diff, should be <= 3

///////////////////////////////////////////////////////////////
//
// lc2073. Time Needed to Buy Tickets
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) a. 若i<k，res += min(tickets[i], tickets[k])
    b. 若i>k，val = min(tickets[i], tickets[k])
        若val == tickets[k]，必須 val--，因為當tickets[k]變成0後，我們
        不會處理在他後面的ticket。

///////////////////////////////////////////////////////////////
//
// lc2077. Paths in Maze That Lead to Same Room
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) set operation, 若有一個邊 n1 - n2，則
    若有一個cycle含這個邊，在set[n1]和set[n2]中必有重複的點。

///////////////////////////////////////////////////////////////
//
// lc2078. Two Furthest Houses With Different Colors
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy, 
    find the first house from right to left that has different color with colors[0]
    find the first house from left to right that has different color with colors[n-1]

(2) find min and max index for each color

///////////////////////////////////////////////////////////////
//
// lc2083. Substrings That Begin and End With the Same Letter
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到character就計算以這個character為結尾的substring
(2) (1+n)*n/2

///////////////////////////////////////////////////////////////
//
// lc2085. Count Common Words With One Occurrence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) map operation

///////////////////////////////////////////////////////////////
//
// lc2089. Find Target Indices After Sorting Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort 
(2) bucket sort

///////////////////////////////////////////////////////////////
//
// lc2095. Delete the Middle Node of a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 快慢指針。

///////////////////////////////////////////////////////////////
//
// lc2096. Step-By-Step Directions From a Binary Tree Node to Another
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) lca + tracking
(2) backtracking