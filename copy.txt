///////////////////////////////////////////////////////////////
//
// lc030. Substring with Concatenation of All Words (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 

///////////////////////////////////////////////////////////////
//
// lc214. Shortest Palindrome (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc459。

///////////////////////////////////////////////////////////////
//
// lc698. Partition to K Equal Sum Subsets
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1)

///////////////////////////////////////////////////////////////
//
// lc708. Insert into a Sorted Circular Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到interval
    (a) now_v <= val <= next_v
    (b) now_v > next_v && (now_v <= val || val <= next_v)

///////////////////////////////////////////////////////////////
//
// lc716. Max Stack (看*)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lru cache。lc146。
    建立一個map<int, vector<list<int>::iterator>> map
    和一個list，list做為stack使用。
    read: O(1), write: O(logn)。

///////////////////////////////////////////////////////////////
//
// lc718. Maximum Length of Repeated Subarray (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 利用dp iteration：tmp[j] = max(tmp[j], dp[j-1]);
    要用一個tmp dp的原因是這個dp數組不是升序或降序更新，為了避免這次更新到的數值
    影響到還未更新的數值，需要用一tmp dp來暫存。
    follow up : 這題其實就是longest commom subsequence。
    類似lc1143。
(2) O(n) space dp
    if (s[i] != s[j])
        dp[j] = 0;

///////////////////////////////////////////////////////////////
//
// lc720. Longest Word in Dictionary (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) sort, O(nllogn), n: # of words, l: average lenth of a word.
(2) trie tree
    time: O(nl), space: O(nl*26)

///////////////////////////////////////////////////////////////
//
// lc722. Remove Comments (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) We need to check three symbols

// : valid if we do not have /* before
/* : valid if we do not have /* before, skip to right next ch after '*'
*/ : valid if we have /* before, skip to right next ch after '/'

注意若*/ 的上一個match對象不是當前這一行，connect = 1，表示要和最後一line做連接。

///////////////////////////////////////////////////////////////
//
// lc726. Number of Atoms
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc394。
    利用map<string, int>表示該層所有原子出現的數量。

///////////////////////////////////////////////////////////////
//
// lc727. Minimum Window Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc076。

///////////////////////////////////////////////////////////////
//
// lc729. My Calendar I (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) map，upper_bound找到前後兩個event，
    若next->start < end || prev->end > start
    return false;
(2) O(n^2) search
    兩者相交表示
    max(start1, start2) < min(end1, end2)

///////////////////////////////////////////////////////////////
//
// lc731. My Calendar II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 若start time ++, end time --，
    計算event重複最大的數量。
    O(n*(n+logn))
(2) 維持兩個vector，一個one，一個two，two表示區間都是兩個event佔據。
    O(n^2)

///////////////////////////////////////////////////////////////
//
// lc754. Reach a Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為-10 和 10 次數都一樣，所以先將input轉成正的，再來累加到超過target。
    若sum和target差距為偶數d，表示其中一項d/2可以轉相反號(cnt)，若差奇數，判斷當前now，
    若now為奇數，則加上now(cnt+1)，若now為偶數，則加上now和now+1(cnt+2)

///////////////////////////////////////////////////////////////
//
// lc756. Pyramid Transition Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前level，跑到底，若到底，往下個level，較快，因為不用使用vector<string>
    去算出在單一level所有可能性的string。
(2) time complexity: O(a^n)，
    對於每個level算出所有可能性的string。    

///////////////////////////////////////////////////////////////
//
// lc759. Employee Free Time
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 建立merge interval array，則每一個interval之間即是free time
(2) 直接merge ，依照開始時間，到時候跑一次linear search當前比上一個大就是
    free time，這樣return arr只是merge based on start time，並沒有真的
    產生一個merge interval。
    兩個都是klogk*n, k: # of lists, n: # of element in a list

///////////////////////////////////////////////////////////////
//
// lc766. Toeplitz Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 比較matrix[i][j] == matrix[i+1][j+1]。

///////////////////////////////////////////////////////////////
//
// lc767. Reorganize String (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 類似lc621，將最大的字母算出來，先填入，接下來依字母由a~z依序填入就好。

///////////////////////////////////////////////////////////////
//
// lc768. Max Chunks To Make Sorted II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 若當前可分成兩塊表示left_max[i] <= right_min[i+1]，因為從0~i的最大值比
    i+1~n-1的最小值來的要小，表示這邊可切割。分成兩塊去sort。
(2) 利用stack維持一個升序序列，若有比top小，就要判斷他可以插入到哪，也就是說
    從top到他插入的位置都是一塊，中間的stack成員都要刪除，return sk.size()
    表示可分成幾塊，其中的數值是個區間的最大值。

///////////////////////////////////////////////////////////////
//
// lc771. Jewels and Stones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，bucket sort，開一個128 size for all problems->
    constant space。
    O(j + s) time 。

///////////////////////////////////////////////////////////////
//
// lc772. Basic Calculator III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) recursion + stack。
    對於()裡面expresion，用stack紀錄。

///////////////////////////////////////////////////////////////
//
// lc791. Custom Sort String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count priority

///////////////////////////////////////////////////////////////
//
// lc792. Number of Matching Subsequences (看)方法2。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc392。
(1) 用double pointer和hashmap去做。
(2) 用一vector of pair,size 26，儲存每個words[i]到目前為止的匹配進度和
    其下一個字母index，若下一個字母index = words[i].size，++res，相反就
    移到對在vector所在的index並push_back進去i和其words[i]下一個index。
    vector<pair<int, int>> map[26]

///////////////////////////////////////////////////////////////
//
// lc797. All Paths From Source to Target (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc801. Minimum Swaps To Make Sequences Increasing (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為當前要不要交換，也會牽扯到前一位要不要交換，因此利用state machine，
    建立swap[i] 和 noswap[i]兩變數，表示第i位交換的最小交換次數和第i位不交換
    的最小交換次數，則狀態方程可以分成兩個case：
    (1) A[i] > A[i-1] && B[i] > B[i-1]
        這個case本來就不用交換，所以noswap[i] = noswap[i-1]，
        但若i一定要交換則上一位也要交換，swap[i] = swap[i-1]+1。
    (2) A[i] > B[i-1] && B[i] > A[i-1]
        這個case是要交換的case，則swap[i] = min(swap[i], noswap[i-1]+1)，
        因為第i位要交換表示第i-1位不能交換。
        另外也可以第i位不交換，但第i-1位要交換：
        noswap[i] = min(noswap[i], swap[i-1])。
 ***可以優化成O(1) space，類似lc122，lc309。

///////////////////////////////////////////////////////////////
//
// lc802. Find Eventual Safe States
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs以及visit[i]，若當前visit[i] != -1，直接return visit[i]。
    visit[i]表示這個點是不是safe：0->not safe，1->safe。
    對於當前指向的都跑一遍dfs，只要一個return 0，就return visit[i] = 0。
    因為safe state表示怎麼走都要是safe。

///////////////////////////////////////////////////////////////
//
// lc807. Max Increase to Keep City Skyline
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先找到row_max和col_max，再算一次diff。

///////////////////////////////////////////////////////////////
//
// lc809. Expressive Words (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc208。
(1) 利用trie tree，將每個字串變為unique字串以及每個字母出現次數的組合。

///////////////////////////////////////////////////////////////
//
// lc811. Subdomain Visit Count
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) unordered_map 紀錄網址出現次數。

///////////////////////////////////////////////////////////////
//
// lc814. Binary Tree Pruning
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，當前為0且左右子樹為null，當前改null。

///////////////////////////////////////////////////////////////
//
// lc817. Linked List Components
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到斷點，代表有一個component，所以res = res+1。
    可用one pass with unordered_set。

///////////////////////////////////////////////////////////////
//
// lc819. Most Common Word (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先遍歷一遍將大寫轉成小寫，非字母轉成空白，再利用unordered_map與istringstream，
    去計算字串出現次數。
(2) 利用double pointer去比較，若當前字母不一樣，去驗證可不可以延展。
    即s[i-1] == s[i] == s[i+1] or s[i] == s[i-1] == s[i-2]
    為什麼不比較s[i] == s[i+1] == s[i+2]是因為如果在連續字母的第一格s[i] != w[j]
    後面也不用比了，直接return false。

///////////////////////////////////////////////////////////////
//
// lc821. Shortest Distance to a Character (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass，從左到右，第二次從右到左。
    第一次 idx = i-last_loc
    第二次 idx = min(idx, last_loc-i)
(2) 利用idx儲存字元==c的index，利用two pointer method去找左右兩個
    為c的idx和當前的比誰比較小。

///////////////////////////////////////////////////////////////
//
// lc823. Binary Trees With Factors (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dp，先將數組排序後，dp[A[i]] = (dp[A[i]] + dp[A[j]]*dp[A[i]/A[j]]) % M

///////////////////////////////////////////////////////////////
//
// lc824. Goat Latin
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用istringstream做處理。

///////////////////////////////////////////////////////////////
//
// lc828. Count Unique Characters of All Substrings of a Given String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp
https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/129021/O(N)-Java-Solution-DP-Clear-and-easy-to-Understand

///////////////////////////////////////////////////////////////
//
// lc830. Positions of Large Groups
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) check if s[i] != s[i-1] && i-last >= 3。

///////////////////////////////////////////////////////////////
//
// lc832. Flipping an Image
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每一列對調，然好跑一遍迴圈用xor把矩陣顛倒。
(2) 建一個新矩陣，對於每一列，用原矩陣從後面往前一一pushback到新矩陣的列中並xor。

///////////////////////////////////////////////////////////////
//
// lc835. Image Overlap
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n^2) time, O(n^2) space

///////////////////////////////////////////////////////////////
//
// lc836. Rectangle Overlap
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc729, lc731。
    將其轉成2d而已

///////////////////////////////////////////////////////////////
//
// lc838. Push Dominoes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) in place solution，只要注意last是R的case就好。
(2) 
    midlen = right-left-1;
    若d[left] == d[right]，中間都填上d[left];
    若d[left] == 'L' && d[right] == 'R'，中間都填上'.'
    若d[left] == 'R' && d[right] == 'L'，
    中間填上string(midlen/2, 'R') + string(midlen%2, '.') + string(midlen/2, 'L')。

///////////////////////////////////////////////////////////////
//
// lc840. Magic Squares In Grid
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 暴力解，注意magic square只能有1~9，且不能重複。
(2) 找規律，中間只能是5且四個corner是偶數，保持一個pattern："43816729"或
    其reverse。

///////////////////////////////////////////////////////////////
//
// lc841. Keys and Rooms
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) bfs走一遍，每走一個n--，結束後若n != 0 則return false。
(2) dfs，類似bfs，也是要利用一vector紀錄有沒有拜訪過。

///////////////////////////////////////////////////////////////
//
// lc844. Backspace String Compare (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，從尾巴開始，利用一變數來決定還要不要往前走。
(2) O(n) space，stack

///////////////////////////////////////////////////////////////
//
// lc845. Longest Mountain in Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) two pointer one pass, O(n) time, O(1) space
    use dir to specify we are ascending or descending in the mountian.

    dir = -1 : initial status
    dir = 0: uphill
    dir = 1: downhill
(2) no dir using，skip left to start uphill
    use right to uphill and downhill。

///////////////////////////////////////////////////////////////
//
// lc848. Shifting Letters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從右至左跑一遍累加次數，並且shift字母。

///////////////////////////////////////////////////////////////
//
// lc849. Maximize Distance to Closest Person (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要找出0距離1最遠的方法是，對於兩個1之間取中間值就可，但頭尾的話若是0
    不用找中間值，因為另外一邊是邊界。

///////////////////////////////////////////////////////////////
//
// lc852. Peak Index in a Mountain Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search

///////////////////////////////////////////////////////////////
//
// lc856. Score of Parentheses (看) 第一種解法。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space：
    遇到右括號，且上一個是左括號的，計算當前是幾層，就res += 1 << l (l為層數)。
    因為兩個括號一起在一個括號，他們兩個都可以各自當成在一個括號再相加。
    像乘法分配律 2*(a+b) = 2*a + 2*b。

(2) O(n) space：
    用stack，當前為')'
        遇到top是分數，累加直到top是'('。
        遇到top是'('，放入1。

///////////////////////////////////////////////////////////////
//
// lc860. Lemonade Change
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 保持五元和十元的數量去做追蹤，若數量不夠就return false。

///////////////////////////////////////////////////////////////
//
// lc861. Score After Flipping Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy approach，首先首位一定是要1，因為對於二進治：1000>0111。
    如此一來每列接翻轉完畢，再來翻轉每行(第一行不翻，因為已透過每列翻成1)，
    可以觀察到，不管本來是0還是1，只要和該列的頭(也就是首位)一樣的，必是翻完列後同樣的。
    因此可透過此方法來計算翻完列後都一樣的作為1，比較和0的個數誰比較多，作為翻轉的依據。

///////////////////////////////////////////////////////////////
//
// lc862. Shortest Subarray with Sum at Least K (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用prefix sum和deque，
    若A[right] - A[que.front()] >= K，表示這可能是最短，需要pop_front。
    若A[right] - A[que.front()] <= 0，表示這段是負的，對於後面算>=k沒有幫助，需要pop_back
    space: O(n)，time：O(n)。

///////////////////////////////////////////////////////////////
//
// lc863. All Nodes Distance K in Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為tree其實也是graph一種，先用一遍dfs(preorder)將tree的連接情況記錄起來，
    也就是轉成graph，再用bfs，從target開始層層算出k距離的所有點。

///////////////////////////////////////////////////////////////
//
// lc864. Shortest Path to Get All Keys (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，判斷這個點有沒有走過，看我當前的鑰匙種類，如6把key，
    111111，若這點為000001，表示這個點有'a' key，不能用數量去記錄，要用種類的原因是
    鑰匙是unique。用unordered_set紀錄 posx_posy_keytag。

///////////////////////////////////////////////////////////////
//
// lc865. Smallest Subtree with all the Deepest Nodes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於找到一個node其subtree可以包涵所以deepest node，其實就是類似找祖先的概念，
    利用postorder，並且維持左子樹和右子樹深度，當兩深度相同，return 當前node，
    不然就return 左子樹的node或是 右子數的node。

///////////////////////////////////////////////////////////////
//
// lc867. Transpose Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) res[j][i] = A[i][j]。

///////////////////////////////////////////////////////////////
//
// lc872. Leaf-Similar Trees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder，遇到leaf就push到stinrg中，最後比較兩個string有沒有一樣。

///////////////////////////////////////////////////////////////
//
// lc874. Walking Robot Simulation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用set來儲存obstacle。

///////////////////////////////////////////////////////////////
//
// lc875. Koko Eating Bananas
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，類似lc1283。

///////////////////////////////////////////////////////////////
//
// lc876. Middle of the Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本快慢指針問題。

///////////////////////////////////////////////////////////////
//
// lc880. Decoded String at Index (看*)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) stack，維持當前total len表示stack總長+now size。
    k = k%len;
    若k < tlen-now.size()，表示k在stack裡其中一個位置
    tlen = (tlen-now.size())/sk.back().second
    now = sk.back().first。
(2) O(1) space
    維持N表示總長度，一旦k == N停止。
    從i往回跑，若遇到數字，
        N /= digit
        k %= N;
    else 
        if (k == N || k == 0)
            return s[i]
        否則
            --N;

///////////////////////////////////////////////////////////////
//
// lc881. Boats to Save People (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) double pointer，先排序，若當前left+right <= limit，表示可配對，
    left++, --right，若不行，表示right一人坐船，left不用+1，left不能跟right做。

///////////////////////////////////////////////////////////////
//
// lc884. Uncommon Words from Two Sentences
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) map find word appearing once

///////////////////////////////////////////////////////////////
//
// lc885. Spiral Matrix III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc054，遍歷的點在範圍內再放入output中。

///////////////////////////////////////////////////////////////
//
// lc886. Possible Bipartition
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc785，bfs with coloring 0 or 1，inital is -1。

///////////////////////////////////////////////////////////////
//
// lc888. Fair Candy Swap
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 算出兩者之前的diff，(sumb-suma)/2，
    因為一定存在一個互換使得兩邊總和相同。
    a[i]+diff = x，x若在b中表示，是一個互換pair。

///////////////////////////////////////////////////////////////
//
// lc890. Find and Replace Pattern
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立兩個vector，一個映射過去，另一個inverse。當遇到第一個設過去的，也設定inverse。
    下次遇到已經設定過映射的，檢查inverse有沒有對到自己。
    未設定的，映射過去，若inverse已經有值，表示也錯誤。

///////////////////////////////////////////////////////////////
//
// lc892. Surface Area of 3D Shapes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於兩邊相鄰的，只做往右看和往下看，
    並且-2*min(grid[i][j], grid[i+1][j])，
       -2*min(grid[i][j], grid[i][j+1])。
    扣掉兩倍這樣到下個點就不用往左和上面扣了。

///////////////////////////////////////////////////////////////
//
// lc893. Groups of Special-Equivalent Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對每一個string根據index去sort然後用set找出group的數量。

///////////////////////////////////////////////////////////////
//
// lc889. Construct Binary Tree from Preorder and Postorder Traversal (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

O(n)
(1) dfs，利用pre_idx，post_idx，利用pre[pre_idx]搭建tree，
    判斷若root->val != post[post_idx] 則繼續搭建tree。
(2) stack iteration，
    利用pre vector做搭建，維持一個stack，
    若sk.back()->val == post[pos]，則pos++, s.pop_back()，
    若s.back()->left == null，now接左邊，不然now接右邊。
    s.push_back(now)。

///////////////////////////////////////////////////////////////
//
// lc894. All Possible Full Binary Trees (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc095，但因為左右對稱，所以只須要算左半邊的左右子樹(跑一半迴圈)，右半邊直接互換就好。
    中間點不互換，避免重複。
    另外，因為是binary tree，所以當前點數必為奇數點，選完點左右也要必是奇數，
    解法：跑回圈從奇數開始為i = i+2，這樣可以避掉左右為偶數點的情況。

///////////////////////////////////////////////////////////////
//
// lc896. Monotonic Array
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 計算出現次數，若兩者都大於0，return false。
(2) 計算bool of 上升或下降，若兩個都0，代表都不符合上升或下降，return false。

///////////////////////////////////////////////////////////////
//
// lc897. Increasing Order Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc094。
(1) inorder stack iteration，用dummy當作輔助使用。
(2) inorder recursion，利用double link list，因為在function中會改動其值，
    所以不能使用單*，要用雙＊。

///////////////////////////////////////////////////////////////
//
// lc901. Online Stock Span
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1019，維持一個降序stack。
    利用stack紀錄當前price和其持續天數，當進來的price比sk.top的price還大時(>=)，
    sk.pop，並將top的天數加到當前price上，最後將當前price和其天數push進sk。

///////////////////////////////////////////////////////////////
//
// lc904. Fruit Into Baskets (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找連續兩個不一樣，最長subarray，
    若目前長度為 a a a a b b b b b
    若
    (1) c == b -> ++cur, a = b, b = c, cnt_b++
    (2) c == a -> ++cur, a = b, b = c, cnt_b = 1
    (3) c!=a && c!=b -> cur = cnt_b + 1, a = b, b = c, cnt_b = 1

    time：O(n)，space：O(1)。
(2) sliding window，longest subarry with at most 2 distinct ingeger
    time：O(n)，space：O(n)。

///////////////////////////////////////////////////////////////
//
// lc905. Sort Array By Parity
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似quick select中partition用到的方法。

///////////////////////////////////////////////////////////////
//
// lc907. Sum of Subarray Minimums (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dp[i]，表示以i為結尾的最小總和，
    -   那如果A[i] >= A[i-1]，表示dp[i] = dp[i-1] + A[i]，因為當前比上一個大，
        以當前結尾就算去往前找，結果都是和以上一個結尾去找的總合一樣。
    -   反之，找到第一個A[i] >= A[idx]，dp[i] = dp[idx] + (i-idx) * A[i]。
    這可以用stack去做，因為每次都往前找，若給定降序input，每次都要找到頭，很浪費時間。
    所以用stack維持一個升序序列，若當前比top小就pop。
    類似lc977，lc1019，lc1130，lc654，1043。

///////////////////////////////////////////////////////////////
//
// lc908. Smallest Range I
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 只要看最大和最小值即可，若兩者差距<=k，表示這其中都可以移動到同一個點。
    反之，retunr maxv-minv-2*k。

///////////////////////////////////////////////////////////////
//
// lc909. Snakes and Ladders (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) 跑一遍紀錄index以及board關係。
(2) 跑一遍將2d array轉乘id array。
(3) real time轉，r = row-1-(now/row)，注意c判斷當前是順向還是逆向
    c = col-c-1 if r%2 != (row-1)%2。
    注意遇到不是-1的一定要跳，但是跳完的那個點不用記錄到visit，不然之後的如果
    有人走到就不能再跳一次(如果這個點也可以跳)，因為visit過。

///////////////////////////////////////////////////////////////
//
// lc912. Sort an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) merge sort
(2) quick sort
(3) selection sort
(4) insertion sort
(5) bubble sort

///////////////////////////////////////////////////////////////
//
// lc914. X of a Kind in a Deck of Cards
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find greatest divisor，如果最大公因數是1，表示只能分成group size是
    1的group。

///////////////////////////////////////////////////////////////
//
// lc915. Partition Array into Disjoint Intervals (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個local max表示到partition i的最大值，若localmax > A[i]，
    表示必須extend left 到包含index i，並更新local max到i的最大值，
    因此必須再額外維持一個global maxv。
(2) O(n) space，維持一個minv[i] 表示從n-1到i為止的最小值。
    if (maxv <= minv[i+1]) return i+1

///////////////////////////////////////////////////////////////
//
// lc917. Reverse Only Letters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用頭尾兩指針i, j，判斷若非字母則跳過，若兩者都是字母則交換，迴圈終止條件為
    i >= j。

///////////////////////////////////////////////////////////////
//
// lc919. Complete Binary Tree Inserter
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs維持一個queue，找到第一個沒孩子的head來做return以及插入孩子，
    注意：整個queue都是有一個或是沒有孩子的node，若頭為有兩個孩子，pop。
(2) 建heap，利用index找到沒有完整孩子的node。 (heap.size()/2)。

///////////////////////////////////////////////////////////////
//
// lc921. Minimum Add to Make Parentheses Valid
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 基本stack操作。
(2) 可不用stack，用left就可以。

///////////////////////////////////////////////////////////////
//
// lc922. Sort Array By Parity II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用double pointer，先找到第一個偶數位置是奇數和奇數位置是偶數的點，
    做swap。

///////////////////////////////////////////////////////////////
//
// lc924. Minimize Malware Spread (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find，注意若一個group裡只有一個感染，則找出最大的感然群的最小id，
    若沒有group只有一個原始感染，則找最小的id就好。

///////////////////////////////////////////////////////////////
//
// lc925. Long Pressed Name
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc809。
    利用double pointer去計算當前位置有沒有相同，若沒有，判斷typed當前
    和上一個有沒有相同，若沒有，return false。
    若name有走完表示true。

///////////////////////////////////////////////////////////////
//
// lc926. Flip String to Monotone Increasing (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當前方法數最小有兩種可能
    若當前n[idx] == 0
    (a) 前n-1位已經合法單調，那麼當前變1。 ->res+1
    (b) 到第n位有1的都變0。 -> res = min(res, ones)

///////////////////////////////////////////////////////////////
//
// lc930. Binary Subarrays With Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1248 method 2，one pass，O(n) time，O(1) space。

///////////////////////////////////////////////////////////////
//
// lc931. Minimum Falling Path Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前路徑往上一層找前後一個的最小值。
    O(n) space。

///////////////////////////////////////////////////////////////
//
// lc933. Number of Recent Calls
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) queue。
(2) arr loop。

///////////////////////////////////////////////////////////////
//
// lc934. Shortest Bridge (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs將島嶼標記，用bfs找到最短距離。

///////////////////////////////////////////////////////////////
//
// lc935. Knight Dialer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs with special dirs。

///////////////////////////////////////////////////////////////
//
// lc937. Reorder Data in Log Files
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對letter排序digit不用。

///////////////////////////////////////////////////////////////
//
// lc938. Range Sum of BST (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用preorder，
    對於往左孩子走，如果root->val > R，
    就可以往左走，root->val < L，代表可往右孩子走。
    若當前在區間內，sum += root->val，兩邊都可以走。

///////////////////////////////////////////////////////////////
//
// lc939. Minimum Area Rectangle (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 暴力解，對當前點(x1,y1)，找看過的點(x2,y2)，若(x1,y2)和(x2,y1)都看過
    update area。
    O(n^2)
(2) O(nx*ny*ny) < O(n^1.5)
    if (nx == ny) -> O(nx*ny*ny) = O(n^1.5)
    First, note that, in the 3-level loop, its complexity is o(nx * ny * ny). 
    We make the size of outmost loop, ie, nx, the largest, and in this way we 
    save much computation. However, when nx = ny, we do not save computation. 
    Thus, the worst case is nx = ny. The typical example is the N points form 
    a regular grid, where nx = ny = sqrt (N)
    (a) 對於每一個x，從小到大，若有一對y1, y2，且y1和y2上次被用過的是lastx
        -> res = min(res, (x - lastx) * (y1- y2))。

///////////////////////////////////////////////////////////////
//
// lc941. Valid Mountain Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 順著找就可以。

///////////////////////////////////////////////////////////////
//
// lc944. Delete Columns to Make Sorted
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) brute force去找就好。

///////////////////////////////////////////////////////////////
//
// lc946. Validate Stack Sequences (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space
    modify pushed array，two pointer。
    return j == popped.size()
(2) O(n) space，一般stack解法。

///////////////////////////////////////////////////////////////
//
// lc947. Most Stones Removed with Same Row or Column (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

這題是在講，對於連通的點可以移除的點數，可以用dfs或是union find，核心在於
同個島嶼移除的點數為這個島嶼的點數-1，所以總共的移除點數就是總共的點數-總共的島嶼數。
又或者每個島嶼在移除後都會剩下一個，所以若一個島嶼只有一個點，這個島嶼不能移除。
題目中的最大move數量，指的是，至個點旁邊有row或col相同的點，這個點可以move 
(也就是remove 這個點)。

(1) union find
(2) dfs

///////////////////////////////////////////////////////////////
//
// lc950. Reveal Cards In Increasing Order (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: nlogn
    利用deque，先將arr sort，再返著build return process。
    因為pusg當前的到res，會將next放到尾巴，所以對於reversed process，
    我們可以將尾巴放到當前的next。

    簡言之，push當前，next放到尾巴 -> 尾巴放到頭，push到頭。

///////////////////////////////////////////////////////////////
//
// lc951. Flip Equivalent Binary Trees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先判斷當前兩個node有沒有一樣，
    再return 左孩子左孩子 && 右孩子右孩子 || 左孩子右孩子 && 右孩子左孩子。

///////////////////////////////////////////////////////////////
//
// lc953. Verifying an Alien Dictionary
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 紀錄順序，兩兩比較，若a > b則return false。

///////////////////////////////////////////////////////////////
//
// lc957. Prison Cells After N Days (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個cycle，若當前res出現過， N = (N - 1) % (cycles-1);

///////////////////////////////////////////////////////////////
//
// lc958. Check Completeness of a Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，complete biniry tree特性為用bfs走訪一定全走非null node，遇到null
    node後，後面一定都是null，利用這特性可以跑第一遍while將node全push到queue直到遇到
    queue中第一個非null，再用另一個while繼續走queue直到遇到第一個非null node或走完queue。
    return index == que.size()。

///////////////////////////////////////////////////////////////
//
// lc959. Regions Cut By Slashes (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2。

(1) 利用union find，將每一個grid劃分成四小等份，上右下左依序為0,1,2,3。
    那麼其實就是對於這些小分塊做union find。
    要注意的是，相鄰的grid預設就要union，因為slash無法分割這些。
    若當前grid[i][j] != '/'，表示0 and 1要union，2 and 3要union。
    若當前grid[i][j] != '\'，表示0 and 3要union，1 and 2要union。
    count數量就是n*n*4。
(2) dfs，將grid分成3*3小塊，然後slash改成1其餘為0，這樣就是
    number of islands。

///////////////////////////////////////////////////////////////
//
// lc961. N-Repeated Element in Size 2N Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為一個陣列有一半都同樣，nums[i]必等於nums[i-1] or nums[i-2]。
    如果沒有只有一個情況
    1, 2, 3, 1。

///////////////////////////////////////////////////////////////
//
// lc965. Univalued Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，preorder。

///////////////////////////////////////////////////////////////
//
// lc969. Pancake Sorting
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到剩餘長度最大的(index: i)，翻到頭，再翻到剩餘長度的位置(index: n)。
    reverse(begin ~ i) then reverse(begin ~ n); --n;

///////////////////////////////////////////////////////////////
//
// lc971. Flip Binary Tree To Match Preorder Traversal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若當前node不等於voyage的對應點，return {-1}，若左孩子的val != voyage[now+1]，
    swap(root->left, root->right)。

///////////////////////////////////////////////////////////////
//
// lc973. K Closest Points to Origin (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) quick select，不好懂。 類似215。
(2) priority queue。

///////////////////////////////////////////////////////////////
//
// lc974. Subarray Sums Divisible by K (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc560類似。要注意餘數為負數的時候再加上K，prefix sum。
(2) 先算好所有的出現相同餘數的次數，再一次跑一個迴圈算好。
    ex: 若該餘數出現4次，則符合題目的次數為1+2+3。

///////////////////////////////////////////////////////////////
//
// lc976. Largest Perimeter Triangle (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大邊長，sort後從後面開始
    只檢查a[i-2] + a[i-1] 有沒有 > a[i]，因為若沒有，以a[i]為檢查點的
    後面i=0~i-3任兩點組合也不會>a[i]。

///////////////////////////////////////////////////////////////
//
// lc977. Squares of a Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 雙指針(頭尾)取絕對值大的填入res的尾端。
(2) stack，類似lc1019，維持一個降序陣列。

///////////////////////////////////////////////////////////////
//
// lc978. Longest Turbulent Subarray (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) > ： sign = 1， < ： sign = -1
    對於當前>或<，紀錄上次是相反結果(sign)的話cnt++，反之就重新初始化狀態(cnt = 2)。
    注意若當前=上一個，初始化sign = -1, cnt = 1。

///////////////////////////////////////////////////////////////
//
// lc979. Distribute Coins in Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，紀錄當前硬幣總數，此硬幣總數代表要往父節點移動的個數。

///////////////////////////////////////////////////////////////
//
// lc980. Unique Paths III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先計算要走的數量， 然後用一般的dfs即可。

///////////////////////////////////////////////////////////////
//
// lc981. Time Based Key-Value Store (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2，3。

類似lc1146。

(1) unordered_map<string, map<int, string>> map
    set: O(log(n))
    get: O(log(n))

(2) unordered_map<string, vector<pair<int, string>>> map;
    因為時間為遞增，可以使用vector pair，upper bound 也為log(n)
    set: O(1)
    get: O(log(n))

(3) 類似(2)，但implement upper_bound by binary search。

///////////////////////////////////////////////////////////////
//
// lc983. Minimum Cost For Tickets (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 跑365天循環，對當前天數，選擇最小付費方式。
    若不是搭車日期(初始化=INT_MAX)，照理說不花費，所以dp[i] = dp[i-1]。
    若是搭車日期(初始化=0)，找出最小付費方式。

///////////////////////////////////////////////////////////////
//
// lc985. Sum of Even Numbers After Queries (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持even sum，若query的index a[idx] is even，先扣掉
    even -= a[idx]
    update a[idx] = a[idx] + val
    再次檢查a[idx]是不是even，是的話，加回even。
    O(n):
    n here is the size of A. Based on the problem description, 
    it dominates the size of queries (0 <= queries[i][1] < A.length). 
    So, worst case scenario, we need 3 * n operations, which is O(n).

///////////////////////////////////////////////////////////////
//
// lc986. Interval List Intersections (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先判對兩個list有沒有交集，若沒有則換下一個，
    若有交集，頭取max(a.start, b.start)，
             尾取min(a.end, b.end)。
    類似lc56。

///////////////////////////////////////////////////////////////
//
// lc987. Vertical Order Traversal of a Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為相同的x y 需要排序，同一個x不同y，則y由小到大填入，因此map作為資料結構。
    map<int, map<int, set<int>>> info來記錄-> info[x][y].insert(node->val)。
    (a) dfs
    (b) bfs

///////////////////////////////////////////////////////////////
//
// lc988. Smallest String Starting From Leaf (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 錯誤想法：postorder去隨時找到最小字串。
    這題是對於所有string從leaf到root找最小字串，所以每次比較都必須是leaf到root
    的字串，這樣就必須用preorder(dfs)而非postorder。
    類似lc1026。

///////////////////////////////////////////////////////////////
//
// lc989. Add to Array-Form of Integer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後面往前走，一位一位的加。

///////////////////////////////////////////////////////////////
//
// lc991. Broken Calculator
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 如果 x >= y，res += x-y，
    但x < y，最快的方法就是讓y <= x，

    為什麼優先除： 假設(y+2n) / 2 = x
    若我們先+2n times then / 2， # of operations: 2n+1
    若我們先除：y/2 + n = x， # of operations: n+1
    所以永遠先除以2都是對的，會造成最小的結果。

    We do Y/2 all the way until it's smaller than X,
    time complexity is O(log(Y/X)).

///////////////////////////////////////////////////////////////
//
// lc992. Subarrays with K Different Integers (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 類似lc1004，lc1052，lc340。
    利用sliding window，紀錄所有子字串使用的integeres with different
    integers <= k。
    at most k - at most k-1。
    two pass
(2) one pass
    維持一個unique integer size = k 的window，且一變數prefix，表示
    在left之前有多少重複的number，res += prefix+1。且left為cnt[left] == 1，
    固定起始點的出現次數為1。所以left為unique interger subarray and 
    cnt[left] = 1。若 k < 0 => prefix = 0。要重新計算有多少prefix array。
    ex 1 1 1 2 2 2 3 3 3
       0 1 2 3 4 5 6 7 8
       k = 3
       left = 3, right = 9, prefix = 2，表示有除了當前subarry還有兩個prefix
       array，res += prefix+1 = 3。
       right = 6
       1 1 1 2 2 2 3
         1 1 2 2 2 3
           1 2 2 2 3

       right = 7
       1 1 1 2 2 2 3 3
         1 1 2 2 2 3 3
           1 2 2 2 3 3

       right = 8
       1 1 1 2 2 2 3 3 3
         1 1 2 2 2 3 3 3
           1 2 2 2 3 3 3

///////////////////////////////////////////////////////////////
//
// lc993. Cousins in Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs，隨時記錄當前node的parent和當前node高度，當遇到node->val等於x或是
    y，紀錄其高度，return true if parent不一樣且高度相同，否則false。
(2) bfs做法也是一樣。

///////////////////////////////////////////////////////////////
//
// lc994. Rotting Oranges (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，每清掉一層queue，++res，像洋蔥是剝皮。
    while (qsize) {
        for (int i = 0; i < qsize; ++i) {

        }
        days++;
    }

///////////////////////////////////////////////////////////////
//
// lc997. Find the Town Judge
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到一個點其in_degree - out_degree = N-1。

///////////////////////////////////////////////////////////////
//
// lc998. Maximum Binary Tree II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律。
    if (root->val < val)
        new TreeNode(val)->left = root;
    else
        root->right = func(root->right, val);

///////////////////////////////////////////////////////////////
//
// lc999. Available Captures for Rook
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到root，往四邊走。

///////////////////////////////////////////////////////////////
//
// lc1002. Find Common Characters (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用cnt(26)，每次和當前的比較，取最小值。

///////////////////////////////////////////////////////////////
//
// lc1003. Check If Word Is Valid After Substitutions (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用stack去解，遇到c時檢查當前最上面兩個是不是a和b，不是就return false。

///////////////////////////////////////////////////////////////
//
// lc1004. Max Consecutive Ones III (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 使用sliding window，右邊界一直往右，遇到0，k--，若k<0，移動左邊界，
    移動左邊界中遇到0，++k(每個iteration只移動一次，為的是right增長一次，left也要增長一次
    ，因為k<0，必需停止array大小增大)，直到k>=0，就不移動左邊界，
    此方法保持左右邊界維持合法吧0數量。

///////////////////////////////////////////////////////////////
//
// lc1005. Maximize Sum Of Array After K Negations (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用quick select將前k小的找出來，然後遍歷一次對於負數且在k次的取正號，
    若k有剩餘則代表都是正號，找到最小的，取負數。

///////////////////////////////////////////////////////////////
//
// lc1007. Minimum Domino Rotations For Equal Row (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於a[0]和b[0]，作為top和down，對top和down分別計算他們在a和b的
    出現次數，若有一個導致a[i]&b[i]都不等於top，top = 0，down也是，
    若top&down == 0，直接return -1。
    跑完loop去找top和down出現次數的最小值。

///////////////////////////////////////////////////////////////
//
// lc1008. Construct Binary Search Tree from Preorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

類似lc108。
(1) stack iteration：
    當前比stack的top小就丟入stack，且stack.top->left = 當前。
    當比stakc的top大，找到最後一個比top大的元素，將這元素->right = 當前。
(2) dfs recursion：
    跑n次迴圈，每次將一個node塞到tree中適當的位置(用遞迴)。

///////////////////////////////////////////////////////////////
//
// lc1010. Pairs of Songs With Total Durations Divisible by 60
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use map(60, 0) to store all possible time[i] % 60,
    res += map[now], with now = (60 - time[i]%60) % 60
    like prefix sum。

///////////////////////////////////////////////////////////////
//
// lc1011. Capacity To Ship Packages Within D Days
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc410，binary search找到最適合的大小。

///////////////////////////////////////////////////////////////
//
// lc1013. Partition Array Into Three Parts With Equal Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 算出sum/3，count 次數，必須>=3。比3大是因為有可能sum == 0。

///////////////////////////////////////////////////////////////
//
// lc1018. Binary Prefix Divisible By 5
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) mod 5 at every step

///////////////////////////////////////////////////////////////
//
// lc1019. Next Greater Node In Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將本來的stack array做成 pair<ListNode *, int>來表示 the relation 
    between list node and index in the res array。

(2) 類似lc503，但是因為只要找一輪，從尾巴往頭看，每次push當前val進入stack，
    找當前下一個大的，對stack找到第一個比當前大的就好(其他pop)，
    其他pop掉沒差，因為比當前小，代表往頭看當前絕對比其他val還要有可能是下一個大的。

///////////////////////////////////////////////////////////////
//
// lc1020. Number of Enclaves
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs把觸碰到boundary的1都改成0，接下來計算剩下的1的數量。

///////////////////////////////////////////////////////////////
//
// lc1021. Remove Outermost Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為最外邊的括號會和前後兩個primitive compotnent相連，用cnt計算括號，
    若不等於0則放入res。

///////////////////////////////////////////////////////////////
//
// lc1022. Sum of Root To Leaf Binary Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1025. Divisor Game
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs recursive
(2) 找規律

///////////////////////////////////////////////////////////////
//
// lc1026. Maximum Difference Between Node and Ancestor (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用preorder (dfs)，來對整條由上往下的路徑找最大最小，藉此找到max diff。
    錯誤想法：由下往上無法確定從單一leaf到root的分別最大最小，因為這樣找會變成整個tree的最大最小，
    這樣的最大最小不一定在同一路徑上，也就不存在祖孫後代的關係。

///////////////////////////////////////////////////////////////
//
// lc1028. Recover a Tree From Preorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用stack size來判斷，
    若當前size == 要插入深度，back->left = now，
    反之，pop_back直到size == 拆入深度，back->right = now。

///////////////////////////////////////////////////////////////
//
// lc1029. Two City Scheduling (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為有n人去a城市，有n人去b城市，對差值做排序，越大的越前面，表示前半部去b城市，
    後半部去a城市。

///////////////////////////////////////////////////////////////
//
// lc1030. Matrix Cells in Distance Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs。

///////////////////////////////////////////////////////////////
//
// lc1031. Maximum Sum of Two Non-Overlapping Subarrays (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window
    lmax: max value of window l before m window
    mmax: max value of window m before l window
    max(lmax + A[i]-A[i-M], mmax + A[i]-A[i-L])
    time: O(n)，space: O(1)
(2) 計算視窗大小，由尾巴往前，算idx以後最大的視窗和，再跑一個從頭開始另一個
    視窗 res = max(res, windwow + other_sum[i+1])
    做兩遍
    time and space: O(n)

///////////////////////////////////////////////////////////////
//
// lc1034. Coloring A Border (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將tagcolor全標-tagcolor，當前點跑完四個方向dfs後，若上下左右取abs後都是
    tagcolor，表示是component內部點，改為tarcolor。

///////////////////////////////////////////////////////////////
//
// lc1035. Uncrossed Lines (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp解，
    表示為dp[i][j]，
    若當前A[i] == B[j]，dp[i][j] = dp[i-1][j-1] + 1。
    否則，dp[i][j] = max(dp[i][j-1], dp[i-1][j])。
    *** 可優化為空間O(n)。

///////////////////////////////////////////////////////////////
//
// lc1037. Valid Boomerang (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算斜率，注意因為分母可能0，所以將兩個斜率的比較式變形。
    ya/xa == yb/xb is equal to ya*xb == yb*xa。

///////////////////////////////////////////////////////////////
//
// lc1038. Binary Search Tree to Greater Sum Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) inorder

///////////////////////////////////////////////////////////////
//
// lc1041. Robot Bounded In Circle (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 能在園內有兩個條件
    a. sequence回到原點
    b. 結束sequence 不是面向北方，這代表每次都會改方向，最後一定會回到原點。

///////////////////////////////////////////////////////////////
//
// lc1043. Partition Array for Maximum Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 區間內最多k個，用dp解。
    j = i ~ i-k+1
    dp[i] = max(dp[i], dp[j-1] + (i-j+1)*區間最大的A val)
    類似lc907。

///////////////////////////////////////////////////////////////
//
// lc1046. Last Stone Weight
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) nlogn sort。
(2) priority queue。 (較好)

///////////////////////////////////////////////////////////////
//
// lc1047. Remove All Adjacent Duplicates In String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc394，lc856，利用stack去做消掉括號的動作。
(2) 每次找到兩個一樣的用erase消除，且idx歸於0，但很慢。

///////////////////////////////////////////////////////////////
//
// lc1048. Longest String Chain (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp iteration。
    先將vector排序，
    對每一個word去做 last_str = word.substr(0,j) + word.substr(j+1)
    類似lc 301
    dp[cur_str] = max(dp[cur_str], dp[last_str]+1)

///////////////////////////////////////////////////////////////
//
// lc1049. Last Stone Weight II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc416，lc494。
    對於x!=y取diff，x==y抵銷，可以想像成數字分成兩堆，若一樣就是0，若不一樣取diff。
    這也就把題目轉換成0/1 Knapsacks problem。
    可用bitset，因為bitset是用來判斷那位有沒有。

///////////////////////////////////////////////////////////////
//
// lc1051. Height Checker
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1052. Grumpy Bookstore Owner
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window，往右遇到1加上，window size-1 是1扣掉。

///////////////////////////////////////////////////////////////
//
// lc1057. Campus Bikes (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，將所有配對可能通過bucket做排序，且worker從低idx到高idx，
    bikes也是從低idx到高idx，這樣的話，對同一個slot，先選低worker id，
    若worker id相同，一定低bike id先選。

///////////////////////////////////////////////////////////////
//
// lc1059. All Paths from Source Lead to Destination
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc802。
(1) dfs recursion，遇到dest檢查是終點(dst沒有指向其他點)，遇到visit[i]
    若visit[i] != -1表示之前走過，直接return。
    也可用visit表示當前路徑下走過的點，若遇到代表有環，return false。

///////////////////////////////////////////////////////////////
//
// lc1060. Missing Element in Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search
    func(idx)表示到idx為止missing number的個數。
    注意邊界問題，if k > func(arr.size()-1)，
    return arr[left] + k-func(left)
    otherwise
    return arr[left-1] + k-func(left-1)

///////////////////////////////////////////////////////////////
//
// lc1061. Lexicographically Smallest Equivalent String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

都是用union find
(1) 當ap != bp，因為要找同一group最小的，我們可以在接parent時，將大的往小的接，
    這樣保證root of union一定是最小。
(2) 用set來把同一個union的收集起來。

///////////////////////////////////////////////////////////////
//
// lc1063. Number of Valid Subarrays (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個升序stack，對於每一個element在stack里表示，到目前為止以這個
    element為起始點到當前num還是合法的subarray。
    res += sk.size() for each num in nums
    time: O(n), space: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1064. Fixed Point
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本binary search。

///////////////////////////////////////////////////////////////
//
// lc1065. Index Pairs of a String
//
///////////////////////////////////////////////////////////////

最佳解： method 2

k = # of words, m = len of text, n = avg len of a word
(1) brute force
    time: O(kmn)
(2) trie tree
    time: O(kn+m^2)

///////////////////////////////////////////////////////////////
//
// lc1071. Greatest Common Divisor of Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用輾轉相除去算即可，因為這裡整除代表str1的首str2.size()一定要是str2，
    若不是，即無法相除，return ""。

///////////////////////////////////////////////////////////////
//
// lc1072. Flip Columns For Maximum Number of Equal Rows (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找flip後最多一樣是0 or 1的個數，所以紀錄每個row出現的次數，次數越多
    表示對這些次數多得column flip，得到的結果一定是最大數量的 0 or 1 rows。

///////////////////////////////////////////////////////////////
//
// lc1079. Letter Tile Possibilities (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc047。
    dfs，檢查當前若和上一個一樣且上一個也是未visit，當前跳過。
        要未visit的才跳過是因為未visit表示屬於同層，visit表示上一層處理過。
        比較有沒有重複都是要同層的。
    若字符不是排序過後 如"ABA"，則用(1-2)

///////////////////////////////////////////////////////////////
//
// lc1080. Insufficient Nodes in Root to Leaf Paths
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) (a) Go to leaf to check if limit > 0.
    (b) for every internal node, if return child is both NULL, 
        it means that this node is insufficient node. So we return NULL.

///////////////////////////////////////////////////////////////
//
// lc1081. Smallest Subsequence of Distinct Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc316相同。

///////////////////////////////////////////////////////////////
//
// lc1085. Sum of Digits in the Minimum Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到最小值。

///////////////////////////////////////////////////////////////
//
// lc1086. High Five (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) counting sort
(2) partial sort

///////////////////////////////////////////////////////////////
//
// lc1087. Brace Expansion
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本permutaion的dfs

///////////////////////////////////////////////////////////////
//
// lc1089. Duplicate Zeros (看)* 第一種方法
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先計算額外空間 = 0的數量，再來用一指針j從尾巴開始，另一個指針從原arr尾巴
    開始，若--j < n才assign當前值 -> a[j] = a[i] (往後位移一個)，
    且若arr[i] = 0，且--j < n，assign a[j] = 0。
(2) 對於重複的插入0，並pop_back。

///////////////////////////////////////////////////////////////
//
// lc1090. Largest Values From Labels
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) priority queue

///////////////////////////////////////////////////////////////
//
// lc1091. Shortest Path in Binary Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1094. Car Pooling
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc731，lc253。
    利用一array紀錄人數，注意在結束的時候要扣掉人數。
    cnt[trip[i][1]] += trip[i][0];
    cnt[trip[i][2]] -= trip[i][0];
    traverse array累加capacity，若大於limit，return false。

///////////////////////////////////////////////////////////////
//
// lc1095. Find in Mountain Array (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用binary search先找到peak index，再來對兩邊的的arr分別做一次
    binary search。

///////////////////////////////////////////////////////////////
//
// lc1099. Two Sum Less Than K
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort then two pointers。

///////////////////////////////////////////////////////////////
//
// lc1100. Find K-Length Substrings With No Repeated Characters (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window，看clean code。

///////////////////////////////////////////////////////////////
//
// lc1101. The Earliest Moment When Everyone Become Friends (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find with path compression and union by size.
    先sort，一旦size == N，return time。
    union by size：只有union head的parent指向union size。
    這樣可以不用額外創一個空間儲存每一個union的size。

///////////////////////////////////////////////////////////////
//
// lc1102. Path With Maximum Minimum Value (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用Dijkstra找maximun path from source，且這個maximum表示路徑中的最小值
    是所有路徑最大的。算是Dijkstra的變形。

///////////////////////////////////////////////////////////////
//
// lc1103. Distribute Candies to People (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 每次分num個糖果，直到不能分為止。
    time:O(sqrt(n))

    we give out candies x times since the total number of candies is n, 
    then x*(x+1)/2 = n or O(x^2) = O(n) or O(x) = O(sqrt(n)).

    因為1+2+3+...+x = n
    跑x次，x(x+1)/2 = n -> time: x = O(sqrt(n))

///////////////////////////////////////////////////////////////
//
// lc1104. Path In Zigzag Labelled Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找出對稱性，除了第一個以外每個都是當前層級的對稱點。
    當前層級區間: res[i] = pow(2,i) - 1 + pow(2,i+1) - res[i+1]。

///////////////////////////////////////////////////////////////
//
// lc1105. Filling Bookcase Shelves (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp[i]表示到第i本書的最小高度
    dp[i] =  min(dp[i], dp[j-1] + h)
    j from i to 1
    h = max(h, books[j-1][1])
    且w要在max_width範圍內。

///////////////////////////////////////////////////////////////
//
// lc1108. Defanging an IP Address
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) inplace replacement，從後往頭走。
(2) 一般linear search。

///////////////////////////////////////////////////////////////
//
// lc1109. Corporate Flight Bookings (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將res[i] += res[i-1]
    若一個兼具為a~b，則在b+1 設置 -v
    這樣在b+1累加的可以扣掉。

///////////////////////////////////////////////////////////////
//
// lc1110. Delete Nodes And Return Forest
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用set來儲存delete node，後序由底層往上去扣除刪掉的點，postorder。

///////////////////////////////////////////////////////////////
//
// lc1111. Maximum Nesting Depth of Two Valid Parentheses Strings (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要找到max(depth(a), depth(b))是minimal，把重點放在nested ()
    ex: ((()))，若都給同一個，如a或b，一定會太大，最好的方式就是將這些平均分給
    a和b，所以輪流給。也就能將maxdepth of input分成兩半，max(a和b的depth)
    一定是最小的。

///////////////////////////////////////////////////////////////
//
// lc1114. Print in Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用counter和contition variable來控制順序。

///////////////////////////////////////////////////////////////
//
// lc1118. Number of Days in a Month
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation，閏年400潤一次，百年不潤，四年潤一次。

///////////////////////////////////////////////////////////////
//
// lc1119. Remove Vowels from a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one time pass push_back。

///////////////////////////////////////////////////////////////
//
// lc1120. Maximum Average Subtree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder。

///////////////////////////////////////////////////////////////
//
// lc1122. Relative Sort Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用counting sort，先計算各個數字的出現次數，再對於arr2的數字去填入res，
    再將不屬於arr2的數字從0~1000依序填入。

///////////////////////////////////////////////////////////////
//
// lc1123. Lowest Common Ancestor of Deepest Leaves (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 一次postorder，高度從最底層開始算(深度是由上往下算)，
    若左子樹高度 = 右子樹高度，return root。
    若左子樹高度 > 右子樹高度，return left 
                        (此left為遞迴return值，並不一定是root->left)。
    若左子樹高度 < 右子樹高度，return right 
                        (此right為遞迴return值，並不一定是root->right)。

(2) 兩次postorder，第一次找最大深度，第二次跑lc236找最小共同祖先。

///////////////////////////////////////////////////////////////
//
// lc1124. Longest Well-Performing Interval (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) > 8 ，cnt++, <= 8，cnt--
    要有最長的subarray，表示cnt == 1，因為正負都抵銷掉，然後再多一個1。
    想像cnt <= 0，為什麼要找cnt-1位置？因為中間和=1，若找cnt-2的位置，
    這一定在cnt-1之後，且忽略到一個1，所以cnt-1的位置必定是離當前位置最長的
    subarray起始點。

///////////////////////////////////////////////////////////////
//
// lc1128. Number of Equivalent Domino Pairs (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc049，lc1048。

(1) 利用bit operation去encode每個pair做出id。

///////////////////////////////////////////////////////////////
//
// lc1129. Shortest Path with Alternating Colors (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為有紅藍兩色，建立data structure {node, color}，表示這個點只能由
    color edge 連過來。從零開始用bfs。初始化個點最大path為2 * n，n為總數。

    其實最大是n*2-3：
    The maximum result happens when in a path from 0 to target, 
    all the intermediate nodes (excluding 0 and target) have 
    an additional self-edge. e.g.

    red_edges = [[0, 1], [1, 2], [2, 3]]
    blue_edges = [[1, 1], [2, 2]]
    n = 4
    The minimum step to reach 3 is 5 steps, because all intermediate 
    nodes 1 and 2 contain self-edges. In other words, 
    the maximum result can be 2 * (n - 2) + 1.

///////////////////////////////////////////////////////////////
//
// lc1130. Minimum Cost Tree From Leaf Values (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n^2)：greedy。
    每次遍歷一遍找到乘積最小的並刪掉較小的那一個數。
(2) O(n)：
    類似lc1019，使用stack。
    維持降序陣列在stack，當遇到第一個比陣列尾巴大的，要去除尾八，並且對
    尾巴左邊和當前比他大的中去取小的和(去除的值，也就是本來的尾巴)相乘，
    結束後再對陣列尾八繼續坐上述比較，直到沒有尾巴比當前小。
    最後將陣列兩兩相乘(這些為降序陣列)。
    原因：要找到兩倆乘積最小，若是降序則右乘回來，若任三個存在中間最小，則優先處理。

    如果題目要求non-leaf node是smallest node value of subtree，
    就要用升序陣列。

///////////////////////////////////////////////////////////////
//
// lc1133. Largest Unique Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bucket sort，從後面往前遍歷，看到第一個cnt == 1，return。

///////////////////////////////////////////////////////////////
//
// lc1135. Connecting Cities With Minimum Cost (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先將vector依照cost排序，若依一邊長兩個點的parent不同，連接他們，
    並res += cost，直到連接了n-1個node為止。
    union find
    類似lc721。

///////////////////////////////////////////////////////////////
//
// lc1136. Parallel Courses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc207，要修這門課，所有先修課必須在之前的學期修掉：洋蔥法bfs。

///////////////////////////////////////////////////////////////
//
// lc1137. N-th Tribonacci Number
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 一般for loop
(2) 利用一 array with fix size 3，這裏是3因為Tn_3 = Tn_2 + Tn_1 + Tn
    這樣的話，每次算新的就是val = sum(arr of element)，且dp[current_idx%3] = val

///////////////////////////////////////////////////////////////
//
// lc1140. Stone Game II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp recurtion
    dp[i][m]表示第從尾巴到第i個pile拿最多的數量，其實就是可以算出對方拿最小的，這樣我
    就是最大的。
    dp[i][m] = psum[i] - min(dp[i+x][max(x,m)]), for x = 1 ~ 2*m

///////////////////////////////////////////////////////////////
//
// lc1143. Longest Common Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1035，可用O(n) space，dp iteration。

///////////////////////////////////////////////////////////////
//
// lc1145. Binary Tree Coloring Game (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於x可以將樹分成三部分，x->left, x->right, 除了x->left, x->right, x的其他node
    數量，從這三部分中選取最大的數量，若 > n/2，return true。
    *** follow up
    Alex and Lee are going to play this turned based game.
    Alex draw the whole tree. root and n will be given.
    Now Lee says he want to color the first node.

    Return true if Lee can ensure his win, otherwise return false
    Could you find the set all the nodes, that Lee can ensure he wins the game?
    What is the complexity of your solution?

    對於每個點算出left child，right child，以及parent以外的個數，任一兩個>the rest的話，
    lee 就會贏。

///////////////////////////////////////////////////////////////
//
// lc1146. Snapshot Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) data structure: unordered_map<int, map<int, int>> record
    對每一格index，存他的版本和該版本的val。
    利用upper_bound去找到最大的版本 < snap_id。
    get: O(logn)
    set: O(logn)
    initial: O(nlogn)
    snap: O(1)
(2) 用binary search and unordered_map<int, vector<pair<int,int>>> record
    get: O(logn)
    set: O(1)
    initial: O(n)
    snap: O(1)

///////////////////////////////////////////////////////////////
//
// lc1150. Check If a Number Is Majority Element in a Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，找到第一個index，然後check nums[i + n/2] == nums[i]。

///////////////////////////////////////////////////////////////
//
// lc1152. Analyze User Website Visit Pattern (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc937。
    這題在於使用者取其visit pattern，因visit by the most users，單一user
    對同一個pattern只會visit一次，可用unordered_map<user_name, map<time_stamp, websit>>
    去紀錄，用三個for迴圈找出所有visit pattern by a user。

///////////////////////////////////////////////////////////////
//
// lc1155. Number of Dice Rolls With Target Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc70，lc518。
(1) iteration 解法類似lc494。
    因為可以有顛倒順序，amount要在外面，內圈則為dice。
(2) recursion，解法類似lc494。

///////////////////////////////////////////////////////////////
//
// lc1160. Find Words That Can Be Formed by Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) cnt(26)，若--cnt[words[i]][j] < 0，valid = false。

///////////////////////////////////////////////////////////////
//
// lc1161. Maximum Level Sum of a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs，用queue。

///////////////////////////////////////////////////////////////
//
// lc1162. As Far from Land as Possible
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs with queue。
    類似lc934。

///////////////////////////////////////////////////////////////
//
// lc1163. Last Substring in Lexicographical Order (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) l: max subarray start index
    r: current subarray start index
    去找到第一個 s[l+d] < s[r+d]，update l = max(l+d+1, r)
    為什麽不只要l = r，因為 'aaaaac'，l = l+d+1可以直接跳到c，節省時間，
    且r = l+1，從下一個位置開始重新搜尋。
    若s[l+d] > s[r+d]，update r += d+1，從這個位置開始重新搜尋，前面
    一定都比s[l+d]小。
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1165. Single-Row Keyboard
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) record index

///////////////////////////////////////////////////////////////
//
// lc1167. Minimum Cost to Connect Sticks (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy method，先將小的合併，之後總和會比較小 -> 我們要小的，代表層層迭代
    過程中，若小的越早合併，之後小的佔結果比例會較高，相反，若大的先合併，每次疊起來，
    最大的每次都會被加到。
    所以是用priority queue。

///////////////////////////////////////////////////////////////
//
// lc1169. Invalid Transactions
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用map記錄每個人的所有交易紀錄，對於每一個新的交易，檢查map中有沒有和
    當前交易為invalid的。

(2) 不用map，用四個vector紀錄訊息，跑一個n^2 for loop確認每個交易是不是invalid，
    最後跑一個n loop確認invalid的交易丟到res中。

///////////////////////////////////////////////////////////////
//
// lc1170. Compare Strings by Frequency of the Smallest Character
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，從尾巴往前累加cnt，對每一個query string，
    return cnt[f]。
    note: cnt[f]表示 所有words 其smallest ch 個數 > f的個數總和。

///////////////////////////////////////////////////////////////
//
// lc1171. Remove Zero Sum Consecutive Nodes from Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc437，lc560，lc974。
    利用prefix_sum，注意刪除的中間段必須把map中的sum也清除，用erase。

///////////////////////////////////////////////////////////////
//
// lc1176. Diet Plan Performance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window。

///////////////////////////////////////////////////////////////
//
// lc1180. Count Substrings with Only One Distinct Letter
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 判斷當前ch和last ch，若不一樣，更新。

///////////////////////////////////////////////////////////////
//
// lc1184. Distance Between Bus Stops
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) split to two array

///////////////////////////////////////////////////////////////
//
// lc1186. Maximum Subarray Sum with One Deletion (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc053.cpp。
    分成兩個case，主要是這兩個case都維持一個min，
    a. maxNoDelete就是lc053。
    b. maxWithDelete：考慮若當前要delete，就用上一輪的maxNoDelete，
       不delete就用maxWithDelete+arr[i]。

///////////////////////////////////////////////////////////////
//
// lc1188. Design Bounded Blocking Queue (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用unique_lock做write，shared_lock做read，condition_variable
    等待其他thread完成一定條件後解鎖，來做write。

///////////////////////////////////////////////////////////////
//
// lc1189. Maximum Number of Balloons
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，對所求的取min(l和o要除以2)。

///////////////////////////////////////////////////////////////
//
// lc1190. Reverse Substrings Between Each Pair of Parentheses (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) stack，initial sk = {""}，每次遇到新的'('，sk.push_back("")。
    O(n^2) time
(2) two pass，記錄每個pair，然後對於pair去走，只要碰到'('或')'，換方向。
    O(n) time

///////////////////////////////////////////////////////////////
//
// lc1192. Critical Connections in a Network (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用rank來判斷有沒有走過，若dfs return的rank > 當前rank，這edge要被加入，
    因為dfs往後的過程沒有cycle，有cycle的話return value一定 <= 當前 rank。
    另外遇到parent需要跳過。

///////////////////////////////////////////////////////////////
//
// lc1195. Fizz Buzz Multithreaded
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1188

///////////////////////////////////////////////////////////////
//
// lc1196. How Many Apples Can You Put into the Basket
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，O(1000 + N)，若Ｎ>>1000，bucket sort效果優於nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1197. Minimum Knight Moves (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use dfs + memorization

note that (1,1), (2,0), (0,2) would be special cases, these
three cost 2 step
The moment you reach 0,2 or 2,0 or 1,1 (visualize in the real chess board) 
the knight cannot move further to 0,0 or might go into negative axis, 
the smartest way is to if you are in (0,2) move the night to (2,1) 
then from there it could move to (0,0)..this takes 2 move. 
same applies for (1,1) and (2,0) too

why only (a) abs(x-1) abs(y-2) and (b) abs(x-2) abs(y-1)
This is because you are counting steps (and walking backwards) 
as you traverse from x,y to 0,0. 
The only way to reach 0.0 from x,y (x>0, y>0) is to either try (x-1,y-2) or (x-2,y-1)

time: O(m*n), m = x, n = y

(2) bfs
time: O(n^2), n = 300

///////////////////////////////////////////////////////////////
//
// lc1198. Find Smallest Common Element in All Rows
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) binary search
    因為每一個row都是有序，我們可以用last_start紀錄是一輪找到的位置來做這一輪
    開始的位置，再往前不用找的原因是一定比當前target還要小。
(2) 依照左到右上到下的方式搜尋，第一個滿足n個的一定是smallest common element。

///////////////////////////////////////////////////////////////
//
// lc1200. Minimum Absolute Difference
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，因為要找最小difference的所有組合，一定是相鄰兩個去做比較。

///////////////////////////////////////////////////////////////
//
// lc1202. Smallest String With Swaps (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find with path compression，compare with union size。
    將同一union的index放在一起，由小到大，然後sort後一一填入。

///////////////////////////////////////////////////////////////
//
// lc1207. Unique Number of Occurrences
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算每個數字出現次數。

///////////////////////////////////////////////////////////////
//
// lc1209. Remove All Adjacent Duplicates in String II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) stack iteration，類似lc723。
follow up: >= k
    (a) 先檢查若跟最後一個不一樣，判斷最後一個有沒有>=k，若有，pop
    (b) 再來判斷最後一個有沒有和自己一樣，若有cnt++，若沒有，push {1}。
    (c) 結束loop後檢查最後一個有沒有>=k，若有pop。
    注意只有在遇到和最後一個不同才去檢查有沒有>=k因為要一次移除所有相同的。

///////////////////////////////////////////////////////////////
//
// lc1213. Intersection of Three Sorted Arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當三個不一樣時，找出最大值，update其他兩個到至少比最大值大或相等。

///////////////////////////////////////////////////////////////
//
// lc1214. Two Sum BSTs (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 用stack做inorder traversal，類似lc1305。
(2) 用recursion，確認當前有沒有符合，若沒有，往左和往右去找。

///////////////////////////////////////////////////////////////
//
// lc1217. Play with Chips
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為移動一格為cost 1，移動兩格cost 2，所以若都是奇數位置或偶數位置，cost = 0，
    因此計算odd & even次數，reutrn min(odd, even)。

///////////////////////////////////////////////////////////////
//
// lc1219. Path with Maximum Gold
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 一般dfs。

///////////////////////////////////////////////////////////////
//
// lc1221. Split a String in Balanced Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算左右值，相消=0，res++。

///////////////////////////////////////////////////////////////
//
// lc1227. Airplane Seat Assignment Probability (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) f(n) = 1/n + 1/n * (n-2) * f(n-1)。
    (a) the 1st person gets his/her own seat. (with probability 1/n). 
        Then the n-th person is sure (with probability 1) to get the n-th seat.
    (b) the 1st person gets the n-th person's seat. (with probability 1/n). 
        Then the n-th person cannot (with probability 0) get the n-th seat.
    (c) the 1st person gets a seat between 2 and n-1 (with probability (n-2)/n). 
        Assume the 1st person gets a-th seat. Then in the next round, we have 3 choices again:
    3.1) if the a-th person gets 1st seat (with probability 1/(n-1)), 
         then this is just like 1st and a-th person swap their seats, 
         it never affect our result for the n-th person.
    3.2) if the a-th person gets n-th seat (with probability 1/(n-1)), 
         game over.
    3.3) if the a-th person gets a seat which is not 1st or n-th, 
         (with probability (n-1-2)/(n-1)), we jump into a loop.
(2) 利用數學歸納法得證 n > 1，f(n) = 0.5。

///////////////////////////////////////////////////////////////
//
// lc1228. Missing Number In Arithmetic Progression (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n) search
(2) binary search，利用a[0]+mid*d == a[mid]來判斷從0到mid為止有沒有都
    等差。
    d = (arr.back()-arr[0])/arr.size()。

///////////////////////////////////////////////////////////////
//
// lc1229. Meeting Scheduler
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找opverlap
    max(start1, start2) <= min(end1, end2)

///////////////////////////////////////////////////////////////
//
// lc1231. Divide Chocolate (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，類似lc410, lc1011。
    注意和上面兩題不同的是，我們要找minimum of subarray sum
    上面兩題找得是maximum of subarray sum
    We want each cut size >= mid. 
    We are binary searching minimum total sweetness.

///////////////////////////////////////////////////////////////
//
// lc1232. Check If It Is a Straight Line
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 斜率轉換，avoid divide by zero condition。
                (y2-y1) / (x2 - x1) == (y3-y2) / (x3 - x2) 
    is equal to 
                (y2-y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)

///////////////////////////////////////////////////////////////
//
// lc1234. Replace the Substring for Balanced String (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window
    若要變成balance array，想像一個window，若outside window的數量都比
    n/4小，表示裡面可以任意改動成balanced，所以要找最小的subarray，且
    這個subarray的外面四個字元都 <= n/4。
    time：O(n)
    space：O(1)

///////////////////////////////////////////////////////////////
//
// lc1235. Maximum Profit in Job Scheduling (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一map<int,int> dp表示map[time] = profit，到time為止最大profit
    對endtime, starttime, profit, 做sort
    對當前job，找到上一個time <= job.starttime, use prev(upper_bound)
    
    **  不用lower_bound是因為，若當前沒有job.starttime in dp，要用prev，若有，
        不能用prev，但用upper_bound，只要prev(upper_bound)就可以解決，
        類似lc1146。
    
    cur = dp[last_time] + job.profit
    若cur > dp.rbegin()->profit then dp[job.endtime] = cur;

///////////////////////////////////////////////////////////////
//
// lc1236. Web Crawler
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion

///////////////////////////////////////////////////////////////
//
// lc1243. Array Transformation (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，紀錄nums[i]為prev，作為下一輪使用。

///////////////////////////////////////////////////////////////
//
// lc1244. Design A Leaderboard
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用兩個map，一個set of pair，記錄每個分數和他的名字，
    另一個key:名字，value:分數。

///////////////////////////////////////////////////////////////
//
// lc1245. Tree Diameter
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 類似lc310，維持當前還沒用的剩餘node，while (n > 1)，若剩1表示2*res，
    對稱的。
    若n = 0，表示不對稱，2*res - 1。

(2) 計算以每個node為root的最大path，且不能走過parent node的點，不然會無窮
    迴圈。

///////////////////////////////////////////////////////////////
//
// lc1247. Minimum Swaps to Make Strings Equal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 收集xy和yx pattern，因為要最小的swap，先去看xy自己能不能組完，yx也是，
    也就是res += (xy/2 + yx/2)，再來 xy % 2 和 yx % 2 表示用剩下來的，
    這一定是0個或1個，若只有其中是一個，return -1，若兩個都是1，表示可以swap，
    方法數 = 2，兩個都是0，維持原狀。

///////////////////////////////////////////////////////////////
//
// lc1248. Count Number of Nice Subarrays (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

類似lc992。
(1) use atmost(k) - atmost(k-1)
    O(1) space，two pass
(2) 992 method 2。
    O(1) space，one pass
(3) 維持一個max size k的queue，表示當前odd num的index。
    若size == k，res += que.front()-last+1。
    若size > k，last = que.front()+1，que.pop()。
    O(k) space，one pass

///////////////////////////////////////////////////////////////
//
// lc1249. Minimum Remove to Make Valid Parentheses (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc301。

(1) stack iteration，將不合法得改成'*'。

///////////////////////////////////////////////////////////////
//
// lc1252. Cells with Odd Values in a Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(m*n + l)，l: length of indeces
    紀錄出現過的row和col次數，遍歷一次matrix，看當前的row和col的合是不是odd。

(2) O(m + n + l)，計算被點到odd次數的row數量和col數量
    return even_row * odd_col + even_col * odd_row。

///////////////////////////////////////////////////////////////
//
// lc1254. Number of Closed Islands
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 做dfs，碰到邊就return 1。
(2) 先將四邊做dfs，再對內部做dfs。

///////////////////////////////////////////////////////////////
//
// lc1257. Smallest Common Region (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立tree map，from bottom to top，然後建立visit map，把region1 走過的
    都插入，再來traverse region2 parent path，若任一點在visit有看過，r
    return這一點。
(2) 建立tree map，from top to bottom，再來用一般lowest common ancestor
    去做。

///////////////////////////////////////////////////////////////
//
// lc1260. Shift 2D Grid
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算出最終column位置 by i+shift，shift = k % col
    計算共同往下shift的變數times = k / col。
    shift也可代表額外往下shift 1 的個數，從col-1往前shift個column都要額外
    往下shift 1。

///////////////////////////////////////////////////////////////
//
// lc1261. Find Elements in a Contaminated Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use bit set，save memory。
(2) use hash set

///////////////////////////////////////////////////////////////
//
// lc1265. Print Immutable Linked List in Reverse (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

(1) 一般recursion解法
(2) 先計算一次list長度，再利用雙loop迴圈，每次印最後一個node的value。
(3) 將node存到size為sqrt(n)的stack。

///////////////////////////////////////////////////////////////
//
// lc1266. Minimum Time Visiting All Points
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，因為若兩者有差，會走完共同的，然後再多走差的數量，這就表示
    兩者之間走的距離就是max(diffx, diffy)。

///////////////////////////////////////////////////////////////
//
// lc1268. Search Suggestions System (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 先將string lexicographically排序，這樣會有一個性質：
    如果a[i] is prefix of a[j] -> a[i] is prefix of x, x from i+1~j-1。
    所以我們從上一次起始點 last_start 往後開始搜尋第一個word >= search word，
    也就是new_start，開始搜尋，然後更新start place from last_start to new start。
    time: O(log(N)) for each query
(2) 直接用set，lower_bound為 O(log(N))

///////////////////////////////////////////////////////////////
//
// lc1271. Hexspeak
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) turn string into long long int and transformed into hex type。

///////////////////////////////////////////////////////////////
//
// lc1272. Remove Interval
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc986。
    對於有交集的，找出沒有在remove interval中的，分三case
    a. 沒交集
    b. 交集且interval[0] < start
    c. 交集且interval[1] > end

///////////////////////////////////////////////////////////////
//
// lc1273. Delete Tree Nodes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從nodes-1跑到1，value[parent[i]] += vallue[i]。
    且res[i]，表示當前i為root的subtree中所有不能抵消的點。
    若value[i] != 0，要把這些點給parent[i]。
    即res[parent[i]] += res[i]。
(2) build tree，跑一遍postorder，若sum == 0，return nodes = 0。

///////////////////////////////////////////////////////////////
//
// lc1274. Number of Ships in a Rectangle
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: T(n) = 4*T(n/4)+c = O(n)
    注意邊界問題。

///////////////////////////////////////////////////////////////
//
// lc1275. Find Winner on a Tic Tac Toe Game
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc348。

///////////////////////////////////////////////////////////////
//
// lc1277. Count Square Submatrices with All Ones (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc221。
    dp[i][j] means the size of biggest square with A[i][j] as bottom-right corner.
    dp[i][j] also means the number of squares with A[i][j] as bottom-right corner.
    O(n^2)
(2) 用prefix sum，O(n^3)，類似lc1314。

///////////////////////////////////////////////////////////////
//
// lc1279. Traffic Light Controlled Intersection (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1188，但不用conditional variable。

///////////////////////////////////////////////////////////////
//
// lc1281. Subtract the Product and Sum of Digits of an Integer 
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) val %= n，sum += val，product *= val。

///////////////////////////////////////////////////////////////
//
// lc1282. Group the People Given the Group Size They Belong To (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持gp(n+1)，
    對於group size，如 = 3，將 = 3的idx收集，直到gp[3].size() == 3，然後push到
    res，並清空gp[3]，這樣就可以依序將所有同一個group size的人收集。
(2) sort idx by group size，一一填入。

///////////////////////////////////////////////////////////////
//
// lc1283. Find the Smallest Divisor Given a Threshold
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，left = 1, right = max(nums)
    time: O(nlog(right))
    注意round up，可以用(nums[i]+val-1) / val。

///////////////////////////////////////////////////////////////
//
// lc1287. Element Appearing More Than 25% In Sorted Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(logN)，binary search，找出candiate first location & last location。
    類似lc33。
(2) 因為是sorted且只有一個arr[i] cnt > 25%，對每個arr[i]去檢查
    若arr[i] == arr[i+n/4]，表示arr[i]數量>25%。

///////////////////////////////////////////////////////////////
//
// lc1290. Convert Binary Number in a Linked List to Integer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit manipulation

///////////////////////////////////////////////////////////////
//
// lc1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum
    O(m*n)
    若當前i~i-len且j~j-len的方形 <= threshold，len++。
(2) prefix sum + binary search to find max side length
    O(m*n*log(m+n))

///////////////////////////////////////////////////////////////
//
// lc1293. Shortest Path in a Grid with Obstacles Elimination (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dijkstra
    time: O(kmn log kmn)
(2) bfs
    time: O(kmn)

///////////////////////////////////////////////////////////////
//
// lc1295. Find Numbers with Even Number of Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 因為maxv為10^5，可以直接用區兼職判斷，O(n)
(2) digit by digit check，O(n*k)，k為number of digit for each nums[i]

///////////////////////////////////////////////////////////////
//
// lc1296. Divide Array in Sets of K Consecutive Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

類似lc659。

(1) unordered_map
    time: O(nlogn+kn)
(2) map
    time: O(kmlogm+nlogm)

///////////////////////////////////////////////////////////////
//
// lc1299. Replace Elements with Greatest Element on Right Side (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後面走回去，維持一個最大值。

///////////////////////////////////////////////////////////////
//
// lc1302. Deepest Leaves Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs
(2) queue iteration，bfs。

///////////////////////////////////////////////////////////////
//
// lc1304. Find N Unique Integers Sum up to Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 不要用1+2+...+n-1，因為如果n很大會overflow，
    find rule。
    2*i - (n-1)

///////////////////////////////////////////////////////////////
//
// lc1305. All Elements in Two Binary Search Trees (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1214，two stack inorder traversal。
(2) 將node value放入res然後sort

///////////////////////////////////////////////////////////////
//
// lc1306. Jump Game III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1311. Get Watched Videos by Your Friends
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs + sort。

///////////////////////////////////////////////////////////////
//
// lc1313. Decompress Run-Length Encoded List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本array operation。

///////////////////////////////////////////////////////////////
//
// lc1314. Matrix Block Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc1292。
(1) 先算出dp[i][j]，表示(0,0)到(i,j)的總和
    再來res[i][j] = res[i+k][j+k] - res[i+k][j-k-1] 
                                 - res[i-k-1][j+k] 
                                 + res[i-k-1][j-k-1]

///////////////////////////////////////////////////////////////
//
// lc1315. Sum of Nodes with Even-Valued Grandparent
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，類似lc337。

///////////////////////////////////////////////////////////////
//
// lc1317. The K Weakest Rows in a Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) binary search + priority queue。
    O(m*(logn + logm) + klogm)
(2) binary search + set。
    O(m*(logn + logm) + k)

///////////////////////////////////////////////////////////////
//
// lc1319. Number of Operations to Make Network Connected
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find

///////////////////////////////////////////////////////////////
//
// lc1325. Delete Leaves With a Given Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder。

///////////////////////////////////////////////////////////////
//
// lc1329. Sort the Matrix Diagonally (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 可以將dig分類成用i-j歸類
    time: O(m*nlogd), d = min(m,n)
    space: O(m*n)
(2)
    time: O(m*n + (m+n)*(dlogd)), d = min(m,n)
    space: O(d)

///////////////////////////////////////////////////////////////
//
// lc1331. Rank Transform of an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort index，add to result array。

///////////////////////////////////////////////////////////////
//
// lc1337. The K Weakest Rows in a Matrix
//
///////////////////////////////////////////////////////////////

(1) bucket sort
    O(m*n + max(k, 100))
(2) binary search + priority queue。
    O(m*(logn + logm) + klogm)
(3) binary search + set。
    O(m*(logn + logm) + k)

///////////////////////////////////////////////////////////////
//
// lc1338. Reduce Array Size to The Half
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bucket sort
(2) priority queue

///////////////////////////////////////////////////////////////
//
// lc1339. Maximum Product of Splitted Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 兩次postorder，第一次算總和，第二次算乘積最大值。

///////////////////////////////////////////////////////////////
//
// lc1340. Jump Game V (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dag + dfs
    time: O(n)
    利用降序stack建立dag
    因為 4 2 1 5 6，d = 2
    5->1, 5->2
    6->5，其實6->1但因為這條不會是最深的，(6->5->1)在做降序sk時自動過濾掉這條
    往右降序可以把所有i左邊的都加進去，往左降序可把所有u的右邊都加進去。

    在build dag最一般就是O(nd)，但這樣會加入一些冗邊，向上面的利子，這些邊
    都不會在最深路徑裡。

    最後做dfs找最深路徑。

///////////////////////////////////////////////////////////////
//
// lc1342. Number of Steps to Reduce a Number to Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation

///////////////////////////////////////////////////////////////
//
// lc1345. Jump Game IV (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，注意走過的點，該val一定走過，所以可以將其整個vector都清空，避免再走一次。

///////////////////////////////////////////////////////////////
//
// lc1346. Check If N and Its Double Exist
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find pair of nums[i]*2 or nums[i]/2。

///////////////////////////////////////////////////////////////
//
// lc1347. Minimum Number of Steps to Make Two Strings Anagram
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算s的出現次數，扣除t的出現次數，若有負的，表示需要轉換的，把負的加總
    即為答案。
(2) 維持兩個cnt，取min(cnt1[i], cnt2[i])，表示絕對不用換的字母，加總res
    return s.size() - res。

///////////////////////////////////////////////////////////////
//
// lc1348. Tweet Counts Per Frequency (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

* n: # of record for one tweet

(1) 利用multiset<int>，lower_bound找出第一個>=startime的position
    recordTweet time: O(logn)
    getTweetCountsPerFrequency: O(logn) + O(# of record between startTime and endTime)

(2) vector<int>，linear find。
    recordTweet time: O(1)
    getTweetCountsPerFrequency: O(n)

///////////////////////////////////////////////////////////////
//
// lc1358. Number of Substrings Containing All Three Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1248 method 2。

///////////////////////////////////////////////////////////////
//
// lc1351. Count Negative Numbers in a Sorted Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc74。
(1) O(m+n)，因為row & col sorted，從右上角開始往左下角走。

///////////////////////////////////////////////////////////////
//
// lc1352. Product of the Last K Numbers (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix product，類似prefix sum
    若遇到0，將arr = {1}。
    若k >= arr.size() ? 0 : arr.back()/arr[arr.size()-k-1];

///////////////////////////////////////////////////////////////
//
// lc1353. Maximum Number of Events That Can Be Attended (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort events。
    利用min priority queue，維持一d表示當前available time，
    將所有start == d 的end加入queue，並檢查queue中的end若 < d，都pop。

///////////////////////////////////////////////////////////////
//
// lc1356. Sort Integers by The Number of 1 Bits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count bits，計算有幾個一有兩種做法：
    (a) cnt += n&1, n >>= 1
    (b) cnt++, n = n&(n-1)

///////////////////////////////////////////////////////////////
//
// lc1359. Count All Valid Pickup and Delivery Options (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) for n-1 pairs, the first one can be inserted into 2*(n-1)+1
    positions, and the second one can be inserted into 2*n positions
    so # of methods are (2*n-1) * 2*n
    因為有順序，要/2，所以為 (2n-1)*n。

///////////////////////////////////////////////////////////////
//
// lc1365. How Many Numbers Are Smaller Than the Current Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bucket sort，bucket[i]表示所有比i小的數量總和。
    time: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1366. Rank Teams by Votes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每個ch計算得到的votes數量。
    m: # of votes, n: # of teams
    count votes: O(m*n)
    sort: O(n^2logn)

///////////////////////////////////////////////////////////////
//
// lc1367. Linked List in Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前點，直接對link list往下找，若都找到reutrn true，不然就遞迴。

///////////////////////////////////////////////////////////////
//
// lc1370. Increasing Decreasing String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) buckeet sort。

///////////////////////////////////////////////////////////////
//
// lc1372. Longest ZigZag Path in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，維持當前node是parent的left還是right direction。
    若是left，則取自己right child return的value，反之。

///////////////////////////////////////////////////////////////
//
// lc1376. Time Needed to Inform All Employees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs
(2) dfs

///////////////////////////////////////////////////////////////
//
// lc1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1380. Lucky Numbers in a Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space
    let A(i,j) be the min of row i, max of col j,
    if there exists another A(i',j') as lucky number,
    (1) A(i',j') > A(i,j') > A(i, j)
    (2) A(i',j) > A(i',j')
    so A(i',j) > A(i,j)
    based on lucky number definition, its a contradiction,
    so there exists only one lucky number in a matrix.

(2) O(m+n) space，維持rowv，colv表示該row的最小值和該col的最大值。

///////////////////////////////////////////////////////////////
//
// lc1381. Design a Stack With Increment Operation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用inc array，inc[i]，表示需要加到0~i，當前若pop，inc[i-1] += inc[i]
    並且將pop value += inc[pop index]。
    time: O(1)。
    space: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1382. Balance a Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) inorder + postorder
    time: O(n)，space: O(n)

follow up: O(1) space DSW algo
https://leetcode.com/problems/balance-a-binary-search-tree/discuss/541785/C%2B%2BJava-with-picture-DSW-O(n)orO(1)
** dont need to write code but briefly explain how it works
(a) Convert the initial tree into a vine. By doing right rotations, 
    we flatten a tree into a 'linked list', where the head is the former leftmost node, and tail - former rightmost node.
(b) As you convert the tree into a vine, count the total number of nodes in cnt.
(c) Calculate the height of the closest perfectly balanced tree: h = log2(cnt + 1).
(d) Calculate the number of nodes in the closest perfectly balanced tree: m = pow(2, h) - 1.
(e) Left-rotate cnt - m nodes to cover up the excess of nodes.
Note: you rotate the root node, then you rotate the right child of the new root node, 
and so on. In other words, left rotations are performed on every second node of the vine.

(f)Left-rotate m / 2 nodes.
(g) Divide m by two and repeat the step above while m / 2 is greater than zero.

///////////////////////////////////////////////////////////////
//
// lc1385. Find the Distance Value Between Two Arrays (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(m*n)，brute force
(2) O(nlogn)，先sort，
    i 表示當前index in arr1，j表示對於到目前為止的i，都0~j-1和0~i相差都>d。
    結束loop時，看i~n1-1都要放入res。

///////////////////////////////////////////////////////////////
//
// lc1387. Sort Integers by The Power Value
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) built-in sort function
(2) quick select

///////////////////////////////////////////////////////////////
//
// lc1389. Create Target Array in the Given Order (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(nlogn)，類似lc315。
    想像一下，題目要求，i < j，index[i] >= index[j]，則index[i]要往右移一位。
    可以用divide and conquer，依照最終index去做排序。
    if (index[i] + shift >= index[j]) {
        res.push_back(index[j])
        shift += 1 --> 這裡表示因為index[j]要插在index[i]前面，shift要加一。
    } else {
        res.push_back(index[i]+shift) --> update index[i]最終位置，並且
                                          放到res裡。
    }
(2) O(n^2)，一般insertion方法。將i開始全都往後移一位。

///////////////////////////////////////////////////////////////
//
// lc1391. Check if There is a Valid Path in a Grid (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前，先到下一點，再對下一點back回去，若可以回到當前點，表示下一點
    是合法圖形。
    用visit來判斷下一點有沒有走過，若有就跳過。加入queue就標記走過。

///////////////////////////////////////////////////////////////
//
// lc1394. Find Lucky Integer in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1395. Count Number of Teams (看)*
//
///////////////////////////////////////////////////////////////

(1) O(n^3)，暴力解。
(2) 對於每個candidate，跑一次回圈
    維持兩個變數vector<int> less, greater。
    less[0]表示在左邊比自己小，less[1]表示在右邊比自己小。
    greater[0]表示在左邊比自己大，greater[1]表示在右邊比自己大。
    res = less[0] * greater[1] + greater[0] * less[1]。

///////////////////////////////////////////////////////////////
//
// lc1396. Design Underground System (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 考慮edge case，利用map紀錄，key: start_end，value: {total_time, cnt}
    第二個map是個人資料，key: id，value: {start, start_time}

///////////////////////////////////////////////////////////////
//
// lc1399. Count Largest Group
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count digit。

///////////////////////////////////////////////////////////////
//
// lc1403. Minimum Subsequence in Non-Increasing Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。
(2) nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1408. String Matching in an Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

k average len of a word

(1) prefix trie tree
    time: O(nk^2)
    將每一個word從 word.substr(i)全部insert到trie tree中，
    並且經過的點end++，這樣代表之後我們搜尋這個word，若走到底後end > 1，
    表示至少有一個除了自己以外的word的substring是這個word。
(2) sort and find n^2
    time: O(nlogn+n^2*k)

///////////////////////////////////////////////////////////////
//
// lc1409. Queries on a Permutation With Key (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lru cache的方式去做，O(n^2)
(2) 利用bit，binary index tree。
(3) 利用segment tree。
    (2) 和 (3)都想像成range sum，arr[0,i]表示0~i的個數，也就是對於i+1位置
    中，前面有幾個number。
    因為題目要求當前number是在arr中第幾個位置，想像成每個位置都是1，那就是說
    given index i，他前面的數量就是rangesum(0,i-1)。
    另外用map紀錄number和其對應在arr的位置。

///////////////////////////////////////////////////////////////
//
// lc1413. Minimum Value to Get Positive Step by Step Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為在每個for loop step sum > 0，表示追蹤minimum sum of for loop，
    return -minv + 1。
(2) 對於每輪若sum < 1，補足到1，即 res += 1-sum。

///////////////////////////////////////////////////////////////
//
// lc1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

greedy method。
always find the largest one less than K。
(1) recursion
    Time O((logk)^2), since O(log k) Fibonacci numbers smaller than k.
    Space O(logK), can be saved by tail recursion.
(2) iteration
    Time O((logk))
    Space O(1)

///////////////////////////////////////////////////////////////
//
// lc1422. Maximum Score After Splitting a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) maxv = zeros_left + ones_right
         = zeros_left + ones_total - ones_left
         = zeros_left - ones_left + ones_total
    所以 maxv = max(maxv, zeros_left - ones_left)
    return maxv + ones_total

///////////////////////////////////////////////////////////////
//
// lc1423. Maximum Points You Can Obtain from Cards (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) sliding window，維持n-k大小的window，找最小。
    time: O(n)
(2) sliding window，先算出左邊開始大小為k總和: left
    然後跑一個k for loop，
    left -= arr[k-1-i];
    right += arr[n-1-i];
    res = max(res, left+right)
    這表示每次從left扣掉一個，right加上一個，維持大小為k的兩邊總和
    time: O(k)

///////////////////////////////////////////////////////////////
//
// lc1425. Constrained Subsequence Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc239。
(1) 用一降序deque。
    time: O(n), space: O(k)
(2) 用一priority queue，max heap。
    time: O(nlogK), space: O(K)

///////////////////////////////////////////////////////////////
//
// lc1427. Perform String Shifts
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string concatenation

///////////////////////////////////////////////////////////////
//
// lc1428. Leftmost Column with at Least a One
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(rlog(c))，binary search
(2) O(r+c)，類似lc240。

///////////////////////////////////////////////////////////////
//
// lc1429. First Unique Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc146 lru，用list和map紀錄list得iterator。
    find first unique: O(1)
(2) 用queue和map，map紀錄出現次數，若為1，push to que。
    find first unique: O(n)

///////////////////////////////////////////////////////////////
//
// lc1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1431. Kids With the Greatest Number of Candies
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find maxv then check if candies[i] + extra >= maxv。

///////////////////////////////////////////////////////////////
//
// lc1433. Check If a String Can Break Another String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，從0~25，計算兩者當前數量，若次數交錯，表示不能break。
(2) nlogn sort

///////////////////////////////////////////////////////////////
//
// lc1436. Destination City
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass，第一次把start place加進去，第二次對於end place看有沒有在
    set裡。

///////////////////////////////////////////////////////////////
//
// lc1437. Check If All 1's Are at Least Length K Places Away
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find last index with a[idx] == 1 and check if 
    i-idx-1 < k or not。

///////////////////////////////////////////////////////////////
//
// lc1441. Build an Array With Stack Operations
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) When we find target[i] is greater than current number, 
    just push and pop and update it until they are equal.

///////////////////////////////////////////////////////////////
//
// lc1443. Minimum Time to Collect All Apples in a Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) build graph first, start from 0, use dfs.
    We add 2 to res when we have collect all return value from
    our descendents that sum is bigger than 0 or current node is an apple.

///////////////////////////////////////////////////////////////
//
// lc1448. Count Good Nodes in Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。
(2) preorder。

///////////////////////////////////////////////////////////////
//
// lc1450. Number of Students Doing Homework at a Given Time
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本判斷interval。

///////////////////////////////////////////////////////////////
//
// lc1457. Pseudo-Palindromic Paths in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation，利用xor兩個  1
(2) set，利用set只有唯一性的特性來判斷set <=1，是的話就是回文。

///////////////////////////////////////////////////////////////
//
// lc1460. Make Two Arrays Equal by Reversing Sub-arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bucket sort
(2) a. use xor to check if bit counting is same between arr and target.
    b. check if target sum is equal to arr sum.

///////////////////////////////////////////////////////////////
//
// lc1462. Course Schedule IV
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion

///////////////////////////////////////////////////////////////
//
// lc1464. Maximum Product of Two Elements in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use pointer to linear find

///////////////////////////////////////////////////////////////
//
// lc1466. Reorder Routes to Make All Paths Lead to the City Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用rel map來判斷當前邊的關係，比如 a->b，
    rel[a].push_back({b, 1})
    rel[b].push_back({a, 0})
    這樣在做bfs就可以知道若連過去的是1，++res。

///////////////////////////////////////////////////////////////
//
// lc1469. Find All The Lonely Nodes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用tag來判斷當前node是不是lonley，
    ex: preorder(root->left, !root->right)
    ex: preorder(root->right, !root->left)

///////////////////////////////////////////////////////////////
//
// lc1470. Shuffle the Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit manipulation，把後半端作為cache，儲存前半段的所有數字，
    nums[i] = nums[j] >> 10;
    nums[i+1] = nums[j] & 1023;

///////////////////////////////////////////////////////////////
//
// lc1472. Design Browser History
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2，3

(1) two stack，history & future，注意history size 必須大於1。
    visit時，future clear.
(2) list，維持now & end，注意visit，如果++now >= arr.size()，push_back()
    否則，arr[now] = url
(3) unordered_map
    visit: map[++now] = url, end = now

///////////////////////////////////////////////////////////////
//
// lc1474. Delete N Nodes After M Nodes of a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one pass，對於n，now->next = now->next->next。這樣now不用動但可以
    一直接下一個。

///////////////////////////////////////////////////////////////
//
// lc1475. Final Prices With a Special Discount in a Shop
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) stack iteration，維持一個升序stack。

///////////////////////////////////////////////////////////////
//
// lc1477. Find Two Non-overlapping Sub-arrays Each With Target Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum，往左找到第一個arry後，再往右去找第二個array。
    並且每次都更新左邊的array長度。
    類似lc560。
(2) sliding window
    dp[i] = 到目前為止最短的array，
    res = min(res, dp[i-1] + right-left+1)
    且 維持一個變數表示到目前為止最短的array: best_so_far
    dp[right] = best_so_far。

///////////////////////////////////////////////////////////////
//
// lc1480. Running Sum of 1d Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 單純累加上一位的值。

///////////////////////////////////////////////////////////////
//
// lc1481. Least Number of Unique Integers after K Removals
//
///////////////////////////////////////////////////////////////

最佳解： method 2，3

類似lc347

(1) sort
    O(n + nlogn), space: O(logn)
(2) priority queue
    time: O(n + ulogu + mlogu), space: O(logu)
(3) bucket
    time: O(n), space O(n)

///////////////////////////////////////////////////////////////
//
// lc1485. Clone Binary Tree With Random Pointer
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 類似lc138，O(1) space, three pass，必須NodeCopy class和Node class
    一致才行
(2) 利用map，O(n) space, one pass。

///////////////////////////////////////////////////////////////
//
// lc1486. XOR Operation in an Array (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，對於start = 0, 1, 2, 4, n = 1, 1, 2, 3, .... 8

start = 0, 1, n = 1~8
[N % 4 == 1] Green Row: Ans = Number[N]
[N % 4 == 2] Yellow Row: Ans = 2
[N % 4 == 3] Red Row: Ans = Number[N] ^ 2
[N % 4 == 0] Blue Row: Ans = 0

start = 2, 3, n = 1 ~ 8
N % 4 == 1] Green Row: Ans = Number[1]
[N % 4 == 2] Yellow Row: Ans = Number[N] ^ Number[1]
[N % 4 == 3] Red Row: Ans = Number[1] ^ 2
[N % 4 == 0] Blue Row: Ans = Number[N] ^ Number[1] ^ 2

https://leetcode.com/problems/xor-operation-in-an-array/discuss/699141/Visual-Solution-Python-or-O(1)-Time-or-O(1)-Space

///////////////////////////////////////////////////////////////
//
// lc1490. Clone N-ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc133
(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1491. Average Salary Excluding the Minimum and Maximum Salary
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find

///////////////////////////////////////////////////////////////
//
// lc1493. Longest Subarray of 1's After Deleting One Element
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) maintain a sliding window with at most 1 zero.

///////////////////////////////////////////////////////////////
//
// lc1494. Parallel Courses II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 

///////////////////////////////////////////////////////////////
//
// lc1496. Path Crossing
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用set紀錄走過的。 

///////////////////////////////////////////////////////////////
//
// lc1502. Can Make Arithmetic Progression From Sequence (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) time, O(1) space
    類似lc041。
    因為要找diff，可以先找到maxv, minv算出diff
    跑一個回圈，對於是自己的點，跳過(++idx)，若不是自己的點，算位置，若沒辦法算，
    return false，最後得到自己得pos，若pos < idx，表示這個點和之前已找到的點一樣，表示重複
    ，但不可能重複，除非diff = 0，所以return false，不然arr[idx] == arr[pos]，這也表示i>pos，
    也要return false，因為如果一樣，diff會=0，一開始就跳過(++idx)，diff!=0但又有
    arr[idx] == arr[pos]表示idx != pos，會造成無窮迴圈，
    最後swap(arr[idx], arr[pos])。

(2) O(nlogn) time, O(logn) space
    sort then find difference

///////////////////////////////////////////////////////////////
//
// lc1504. Count Submatrices With All Ones
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc085
(1) 用lc085 method 1去解。
(2) 用lc085 method 2去解。
    因為要算當前高度的所有rectangle，
    sum[i] = sum[sk.back()]
    sum[i] += (i-sk.back())*dp[i]。

///////////////////////////////////////////////////////////////
//
// lc1506. Find Root of N-Ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n) space，找deg == 0的點，map紀錄。
(2) O(1) space，利用xor，只有root只會出現一次。

///////////////////////////////////////////////////////////////
//
// lc1507. Reformat Date
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 判斷長度來檢查是1 ~ 9還是 > 10來做substr。

///////////////////////////////////////////////////////////////
//
// lc1509. Minimum Difference Between Largest and Smallest Value in Three Moves
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc486。

(1) dfs recursion
(2) iteration

///////////////////////////////////////////////////////////////
//
// lc1512. Number of Good Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum

///////////////////////////////////////////////////////////////
//
// lc1518. Water Bottles (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(log(n)) time，
    res += empty / exchange
    empty = empty / exchange + empty % exchange
(2) O(1) time

The "price" of buying a refill is handing over two empties. 
However, you must have your own empty bottle to receive the refill.
Therefore after drinking the initial numBottles, 
we "keep aside" one empty for receiving the refills (therefore we do 9 minus 1) 
and trade in the remaining 8 empties to get refills @ 2 bottles/refill. 

///////////////////////////////////////////////////////////////
//
// lc1522. Diameter of N-Ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc543。

///////////////////////////////////////////////////////////////
//
// lc1525. Number of Good Ways to Split a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass dp, maintain a dp[i] means # of unique characters 
    from 0 ... i.

///////////////////////////////////////////////////////////////
//
// lc1528. Shuffle String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc041。
    swap until i == indices[i]。

///////////////////////////////////////////////////////////////
//
// lc1530. Number of Good Leaf Nodes Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，track左子樹leaf和右子樹leaf的距離和 <= d。

///////////////////////////////////////////////////////////////
//
// lc1534. Count Good Triplets
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) brute force，O(n^3)，可以在跑第三個loop時先檢查abs(a[i]-a[j]) <= a

///////////////////////////////////////////////////////////////
//
// lc1539. Kth Missing Positive Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1060。
    唯一差別是要從1開始算。

///////////////////////////////////////////////////////////////
//
// lc1541. Minimum Insertions to Balance a Parentheses String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 
    (a) when s[i] == ')' && (s[i+1] == '(' or i == s.size()-1), we need to insert one ')'; 
        Otherwise, there are two consecutive ')', and we skip the next one: i++
    (b) when every time we face two ')', subtract one '(' and check if it is < 0. 
        If yes, we need to insert one '(' and reset left to 0.
    (c) after one time pass. res += left*2 to make sure if there are not enough ')'.

///////////////////////////////////////////////////////////////
//
// lc1544. Make The String Great
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) stack
(2) two pointer
    note: 'a'^'A' = 32

///////////////////////////////////////////////////////////////
//
// lc1550. Three Consecutive Odds
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find 連續三個奇數，若遇偶數，cnt = 0。

///////////////////////////////////////////////////////////////
//
// lc1557. Minimum Number of Vertices to Reach All Nodes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找沒有in-degree的node。
*** follow up: 先對沒有in-degree的node跑一遍dfs，最後再對那些環找任一點
               做dfs。

///////////////////////////////////////////////////////////////
//
// lc1570. Dot Product of Two Sparse Vectors
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) map operation，儲存非零位置。
(2) two pointer，類似lc349，lc350。
    用vector<pair<int, int>>儲存非零位置。

///////////////////////////////////////////////////////////////
//
// lc1572. Matrix Diagonal Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: O(n)，跑一遍找對角線，若n是奇數，扣掉重複算的。

///////////////////////////////////////////////////////////////
//
// lc1573. Number of Ways to Split a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass
(2) one pass

///////////////////////////////////////////////////////////////
//
// lc1578. Minimum Deletion Cost to Avoid Repeating Letters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個sum和到目前為止最大maxv，若遇到s[i] != s[i-1]
    res += sum-maxv, sum = maxv = 0;

///////////////////////////////////////////////////////////////
//
// lc1582. Special Positions in a Binary Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc531。

(1) 對於每個row先找colsum == 1，若有，找到對應位置並搜尋row有沒有==1，
    若有，++res。
    因為每個row去搜尋row只會搜尋一次，所有點總共最多visit m*n次。
    time: O(m*n)
    space: O(1)
(2) lc531的method 2。
    time: O(m*n)
    space: O(m+n)

///////////////////////////////////////////////////////////////
//
// lc1583. Count Unhappy Friends (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n^2)，紀錄preference，這樣就可以從O(n^3)變成O(n^2)。

///////////////////////////////////////////////////////////////
//
// lc1586. Binary Search Tree Iterator II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc173。
    inorder stack traversal，將前後串連起來

///////////////////////////////////////////////////////////////
//
// lc1588. Sum of All Odd Length Subarrays (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 去計算A[i] 出現在subarry的次數
    O(n) time O(1) space
    從左邊subarray來看，有i, [i, i-1], ... [i, i-1, ..., 1, 0], i+1種選擇
    從右邊subarray來看，有i, [i, i+1], [i, i+1, ..., n-1], n-i種選擇
    所以A[i]出現在subarray共有 (i+1)*(n-i)，因為要找奇數，所以/2
    但有可能有小數點，且一定會有自己一次，所以 ((i+1)*(n-i)+1)/2;
    也可ceil((i+1)*(n-i)/2)。

    Example of array [1,2,3,4,5]
    1 2 3 4 5 subarray length 1
    1 2 X X X subarray length 2
    X 2 3 X X subarray length 2
    X X 3 4 X subarray length 2
    X X X 4 5 subarray length 2
    1 2 3 X X subarray length 3
    X 2 3 4 X subarray length 3
    X X 3 4 5 subarray length 3
    1 2 3 4 X subarray length 4
    X 2 3 4 5 subarray length 4
    1 2 3 4 5 subarray length 5

    5 8 9 8 5 total times each index was added.
    3 4 5 4 3 total times in odd length array with (x + 1) / 2
    2 4 4 4 2 total times in even length array with x / 2

///////////////////////////////////////////////////////////////
//
// lc1598. Crawler Log Folder
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，檢查 == "../" 和 != "./"即可。

///////////////////////////////////////////////////////////////
//
// lc1600. Throne Inheritance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1602. Find Nearest Right Node in Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bfs
(2) preorder morris traversal，注意計算深度問題。

///////////////////////////////////////////////////////////////
//
// lc1603. Design Parking System
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) thread safe solution，注意用mtx陣列，fix size，而不是用vector
https://stackoverflow.com/questions/16465633/how-can-i-use-something-like-stdvectorstdmutex/24170141

///////////////////////////////////////////////////////////////
//
// lc1608. Special Array With X Elements Greater Than or Equal X
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 從後往前找
(2) binary search

///////////////////////////////////////////////////////////////
//
// lc1609. Even Odd Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，和sign來判斷當前要是even level or odd level。

///////////////////////////////////////////////////////////////
//
// lc1612. Check If Two Expression Trees are Equivalent (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) preorder，利用cnt(26, 0)紀錄出現的次數
follow up: 如果root是'-'，left subtree不會被影響，right subtree sign*=-1。

///////////////////////////////////////////////////////////////
//
// lc1614. Maximum Nesting Depth of the Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) linear search。

///////////////////////////////////////////////////////////////
//
// lc1615. Maximal Network Rank (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用unordered_set記錄自己有連到幾個，跑一個O(n^2)，去算出最大的兩個邊。
    O(n^2)
    follow up: if average m is O(n), design a O(n) algo
follow up:
    1. 若最大數量的node只有一個，對於其他的node算出和最大數量的和，若這兩node有
    邊必須扣掉一。
    2. 若有兩個以上，想像若這些node 為m，若 m*(m-1)/2 > connect 這些彼此node
    的邊數量，代表一定有兩個node屬於最大數量邊，且沒有邊連這兩個，不用-1。
    note: fully connected of n nodes, its edge = n*(n-1)/2。

///////////////////////////////////////////////////////////////
//
// lc1619. Mean of Array After Removing Some Elements
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) sort entire array
(2) 用兩個priority queue。

///////////////////////////////////////////////////////////////
//
// lc1624. Largest Substring Between Two Equal Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find, use cnt to record position

///////////////////////////////////////////////////////////////
//
// lc1628. Design an Expression Tree With Evaluate Function (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) system design ood
    base node
    number node
    op node: addnode, subtract node, multiply node, divide node

///////////////////////////////////////////////////////////////
//
// lc1629. Slowest Key
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持最大diff和其label即可。

///////////////////////////////////////////////////////////////
//
// lc1631. Path With Minimum Effort
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1102，Dijkstra。
    time: O(mnlogmn)
    space: O(mn)

///////////////////////////////////////////////////////////////
//
// lc1636. Sort Array by Increasing Frequency
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1640. Check Array Formation Through Concatenation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map來儲存第一個pieces的type，然後對於arr的第一個數去找對應的type，
    並iterate 該pices。

///////////////////////////////////////////////////////////////
//
// lc1644. Lowest Common Ancestor of a Binary Tree II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 變形postordeder，遇到p或q，++cnt，cnt == 2才有lca。

///////////////////////////////////////////////////////////////
//
// lc1647. Minimum Deletions to Make Character Frequencies Unique
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) space
    記錄每個出現次數的字母數量，
    若cnt[i] > 1，cnt[i-1] += cnt[i-1], res += cnt[i]-1。
(2) O(1) space
    先記錄出現次數並sort。
    維持一個now_feq表示最近使用過的feq，
    若times[i] >= now_feq, --now_feq, res += times[i]-now_feq
    else now_feq = times[i]

///////////////////////////////////////////////////////////////
//
// lc1650. Lowest Common Ancestor of a Binary Tree III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc160
    O(log(n)) time O(1) space

///////////////////////////////////////////////////////////////
//
// lc1654. Minimum Jumps to Reach Home (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，建立queue with state，表示當前到position是foward or backward
    利用visit表示這個點有沒有到過，被foward到過或是backward到過。
    關於maxval，
    if (a >= b)，maxval = x+b
    if (a < b)，maxval = x+a+a+b
    https://leetcode.com/problems/minimum-jumps-to-reach-home/
    discuss/935419/Python-deque-BFS-O(max(x-max(forbidden))%2Ba%2Bb)

///////////////////////////////////////////////////////////////
//
// lc1656. Design an Ordered Stream
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個index，表示第一個空的位置，若非空，就push到res，並移到第一個空的
    位置。

///////////////////////////////////////////////////////////////
//
// lc1657. Determine if Two Strings Are Close (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) bucket sort
    if (n < 26log26) then O(26log26)。

///////////////////////////////////////////////////////////////
//
// lc1660. Correct a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs with map，利用parent map記錄自己的parent是誰，若當前自己right
    child被指過，表示自己的孩子和自己同一層，now->right = null，且自己
    的parent對自己設置null。

///////////////////////////////////////////////////////////////
//
// lc1664. Ways to Make a Fair Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc198。

(1) 維持 odd and even

///////////////////////////////////////////////////////////////
//
// lc1662. Check If Two String Arrays are Equivalent
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer searching

///////////////////////////////////////////////////////////////
//
// lc1666. Change the Root of a Binary Tree (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用recursion，當前有new parent，
    規則是如果當前now->left = new parent，則now->left = null，反之。
    old parent = now->parent
    now->parent = new parent，建立新的parent。
    且若當前砍掉連接後還有左孩子，則讓他變成右孩子。因為left child 要去接
    自己的parent: now->left = recursion(old_parent, now)。

///////////////////////////////////////////////////////////////
//
// lc1668. Maximum Repeating Substring
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大的k，repeat word for max k times and find this word
    in input string。

///////////////////////////////////////////////////////////////
//
// lc1669. Merge In Between Linked Lists
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear pass。

///////////////////////////////////////////////////////////////
//
// lc1670. Design Front Middle Back Queue
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 利用list and iterator，維持mid
(2) 利用兩個deque：left & right，left.size()-right.size() <= 1。

///////////////////////////////////////////////////////////////
//
// lc1672. Richest Customer Wealth
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find max row sum。

///////////////////////////////////////////////////////////////
//
// lc1673. Find the Most Competitive Subsequence (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用升序stack，若當前可以pop，檢查未來還有沒有足夠的element可以放入stack。

///////////////////////////////////////////////////////////////
//
// lc1676. Lowest Common Ancestor of a Binary Tree IV
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder，利用unordered set來記錄node。

///////////////////////////////////////////////////////////////
//
// lc1684. Count the Number of Consistent Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) set

///////////////////////////////////////////////////////////////
//
// lc1695. Maximum Erasure Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer，維持一subarray裡面的次數都只出現一個，類似lc3。

///////////////////////////////////////////////////////////////
//
// lc1696. Jump Game VI (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc239，用一降序deque。
time : O(n), space: O(k)
    this problem is like leetcode 239, just use a decreasing deque size k.
    More specifically, the head of the deque is the max score we can get from current index i.
    The size of deque is k because for current index i, 
    the farthest idx before i is i-k, and when we push i in to que, 
    we need to pop out any index smaller than i-k.

///////////////////////////////////////////////////////////////
//
// lc1700. Number of Students Unable to Eat Lunch
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) two pointer，計算不符合的數量，若等同於當前學生數量，return。
    O(n^2) time
    the worst case is like student [0 0 0 1 1 1], sandwich [1 0 1 0 1 0]
    and for each sandwich, we go though student array n/2 times. 
    That is, total time: n/2*n = O(n^2).

(2) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1704. Determine if String Halves Are Alike
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear find

///////////////////////////////////////////////////////////////
//
// lc1708. Largest Subarray Length K (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大，直接去比較頭，若都一樣，代表是最後一個subarry
    ex: [1 1 1 1 2]，k = 3，選 [1 1 2]
*** follow up: numbers are not distinct.
    類似lc1163。
    唯一差別是不能update l = max(l+d+1, r)，只能l = r，因為這是有固定的長度k
    而不是像lc1163一樣substring沒有固定長度。
    另外多一個條件，因為限定長度k，確認現在比的r+k-1 < n才值得比。
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1710. Maximum Units on a Truck
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort，and greedy。

///////////////////////////////////////////////////////////////
//
// lc1716. Calculate Money in Leetcode Bank
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) math，O(1) time。
(2) loop，O(n) time

///////////////////////////////////////////////////////////////
//
// lc1721. Swapping Nodes in a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one pass
** follow up: change structure, maintain p1, n1, p2, n2
注意若 n1 == p2 or n2 == p1，要做相鄰的處理
且n2 == p1，要swap node，因為我們assume p1在左邊，p2在右邊做處理。

///////////////////////////////////////////////////////////////
//
// lc1725. Number Of Rectangles That Can Form The Largest Square
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find max of minlen of each rect。

///////////////////////////////////////////////////////////////
//
// lc1730. Shortest Path to Get Food
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1732. Find the Highest Altitude
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear找累加最大值。

///////////////////////////////////////////////////////////////
//
// lc1736. Latest Time by Replacing Hidden Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從左到右，找最大的數字，注意time[0]要看time[1]，time[1]要看time[0]

///////////////////////////////////////////////////////////////
//
// lc1740. Find Distance in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder

///////////////////////////////////////////////////////////////
//
// lc1753. Maximum Score From Removing Stones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找最大和最小，各扣一然後++res。

///////////////////////////////////////////////////////////////
//
// lc1754. Largest Merge Of Two Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string compare
    since at most substr will be executed n times for s1 and m times for s2.
    so total is (n+n-1+n-2+...+1) + (m+m-1+m-2+...+1) = O(n^2+m^2)

///////////////////////////////////////////////////////////////
//
// lc1758. Minimum Changes To Make Alternating Binary String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find 010101... error positions and return min(ones, n-ones)
    n-ones means 101010.... error positions.

///////////////////////////////////////////////////////////////
//
// lc1762. Buildings With an Ocean View
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) decreasing stack from left to right
(2) array search from right to left

///////////////////////////////////////////////////////////////
//
// lc1768. Merge Strings Alternately
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer

///////////////////////////////////////////////////////////////
//
// lc1769. Minimum Number of Operations to Move All Balls to Each Box
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc238。
(1) left_step表示到目前為止這個點有幾個人花的總共步數。
    left_cnt表示到目前為止有幾個1。
    right亦同。

///////////////////////////////////////////////////////////////
//
// lc1772. Sort Features by Popularity
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use stable sort with map and set

///////////////////////////////////////////////////////////////
//
// lc1773. count items matching a rule
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count

///////////////////////////////////////////////////////////////
//
// lc1780. Check if Number is a Sum of Powers of Three
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) greedy, always minus largest power of 3.
(2) 想像若 n = 3^0 + 3^2 + 3^4 = 3^0(1+3^2+3^4), 去掉一
        3^2+3^4 = 3^2(1+3^2)，去掉一
        3^2 = 3^2(1)，去掉一

        所以我們發現若n%3 == 1 可以n = (n-1)/3
                  若n%3 == 0 可以n /= 3
        若n%3 == 2，表示沒辦法約分，return false

///////////////////////////////////////////////////////////////
//
// lc1784. Check if Binary String Has at Most One Segment of Ones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為起始必為1，找到01就是代表第二個1。
(2) 從尾巴跑遇到1停，繼續跑，遇到不是0停，如果idx != -1表示有兩個以上1 block。
(2) 找邊界數量，找理說只有兩個。

///////////////////////////////////////////////////////////////
//
// lc1796. Second Largest Digit in a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用兩個變數維持最大和第二大

///////////////////////////////////////////////////////////////
//
// lc1800. Maximum Ascending Subarray Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到數字比當前小就將sum = 當前數字。

///////////////////////////////////////////////////////////////
//
// lc1816. Truncate Sentence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count words

///////////////////////////////////////////////////////////////
//
// lc1822. Sign of the Product of an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count # of negative sing 

///////////////////////////////////////////////////////////////
//
// lc1824. Minimum Sideway Jumps (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) dijkstra
(2) bfs
(3) dp
    dp[0] dp[1] dp[2] 表示第ith lane最小方法數
    所以 dp[i] = min(dp[i], min(dp[i+1],dp[i+2])+1)

///////////////////////////////////////////////////////////////
//
// lc1827. Minimum Operations to Make the Array Increasing
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find diff between neighbor

///////////////////////////////////////////////////////////////
//
// lc1832. Check if the Sentence Is Pangram
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) set
(2) bit

///////////////////////////////////////////////////////////////
//
// lc1836. Remove Duplicates From an Unsorted Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本linked list operation

///////////////////////////////////////////////////////////////
//
// lc1839. Longest Substring Of All Vowels in Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到字母差值規律，用two pointer。

///////////////////////////////////////////////////////////////
//
// lc1844. Replace All Digits with Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string operation

///////////////////////////////////////////////////////////////
//
// lc1859. Sorting the Sentence
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) use pair to store index
(2) linear filling with the index

///////////////////////////////////////////////////////////////
//
// lc1869. Longer Contiguous Segments of Ones than Zeros
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer維持最大連續一樣的邊界。

///////////////////////////////////////////////////////////////
//
// lc1874. Minimize Product Sum of Two Arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort
(2) sort

///////////////////////////////////////////////////////////////
//
// lc1871. Jump Game VII (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bfs，對於當前位置i，
    起始點是要left = max(i+minJump, max_start+1)
    結束點是要right = min(i+maxJump, n-1)
    而max_start = right，因為這樣可以不visit一些之前就visit過的點。
    time: O(n*(maxjump-minjump))

(2) 表示到目前為止可以到的步數
    pre += dp[i-minjump]
    pre -= dp[i-maxjump-1]
    dp[i] = dp > 0 && s[i] == '0'
    time: O(n)

///////////////////////////////////////////////////////////////
//
// lc1877. Minimize Maximum Pair Sum in Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort then two pointer

///////////////////////////////////////////////////////////////
//
// lc1893. Check if All the Integers in a Range Are Covered
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc253。
(1) 找出區間起始點+1，結束點的後一個減一。
    time: O(n+m)
    space: O(m)
(2) sort and find if current value in the range
    if yes, update to range[1]+1
    time: O(nlogn)

///////////////////////////////////////////////////////////////
//
// lc1897. Redistribute Characters to Make All Strings Equal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count, bucket

///////////////////////////////////////////////////////////////
//
// lc1902. Depth of BST Given Insertion Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map去找左和右最近的高度
    nlogn

///////////////////////////////////////////////////////////////
//
// lc1903. Largest Odd Number in String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find last odd number

///////////////////////////////////////////////////////////////
//
// lc1905. Count Sub Islands
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion