123 ( 多創: 698 214
///////////////////////////////////////////////////////////////
//
// lc001. Two Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 2:

(1) 將index和大小排序後，從頭尾process，若和小於target，left++，反之
(2) 用hashmap (ubordered map)

///////////////////////////////////////////////////////////////
//
// lc002. Add Two Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1)	digit by digit相加，並加上前一位的商數，取餘數放到新節點，取商數再到下一digit做運算。
	注意若商數還不等於0要再做一次。

///////////////////////////////////////////////////////////////
//
// lc003. Longest Substring Without Repeating Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 利用left&right來判斷不重複的最大子字串分界。
	若right跑到重複的，檢查本來的字元index有沒有小於left，若有不處理，因為不在分界內。
	若大於或等於left，更新left到本來的字元index+1，因為在分界內，必須更新left到重複的index再+1。
	每回圈紀錄當前length = right-left+1。
(2) 若當前cnt[s[right]] > 1，shift left until cnt[s[right]] == 1。

///////////////////////////////////////////////////////////////
//
// lc004. Median of Two Sorted Arrays (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於奇數或偶數，可找(m+n+1)/2和(m+n+2)/2，奇偶通吃。
	對於兩個array找共同第k個，可對兩個array分別找第k/2個，若左邊的k/2 < 右邊的k/2，
	則左邊k/2個都不考慮，因為都不可能是合併後第k個的候選人，因此左邊shift k/2位，反之。
	若左邊k/2找不到，直接shift右邊k/2個，因為左邊不夠，代表右邊第k/2個不可能是第k個，反之。
	log(min(m, n))

///////////////////////////////////////////////////////////////
//
// lc005. Longest Palindromic Substring (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持當前的index，因為case有一個或是兩個連續，因此必需分開討論，
	但如果以當前index值往右找連續一樣，這樣下次找就可以從連續一樣的下一個點當作當前點。
	然後延續的邊界為left和right去判斷有沒有回文。
	注意: 檢查剩餘長度有沒有>maxLen/2，若沒有就return

///////////////////////////////////////////////////////////////
//
// lc006. ZigZag conversion
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找出數學規律，row by row去算會發現當前與下一個差了2*row-2，
	而中間點則為下一個點往左邊走2*r (r為當前row)。

///////////////////////////////////////////////////////////////
//
// lc007. Reverse Integer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從尾數一次一次拿出，並在要加上當前值時確認當前值*10+尾數比INT_MIN大或比INT_MAX小才能計算，
	否則return 0。

///////////////////////////////////////////////////////////////
//
// lc008. String to Integer (atoi)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 在出現數字前，若不是' '，'+'，'-'，直接return 0。
	出現'+'，'-'後的下面一位一定要數字，否則直接return 0。

///////////////////////////////////////////////////////////////
//
// lc009. Palindrome Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 轉為字串，頭尾往中間跑檢查有無相同。 若size=1直接return true。

///////////////////////////////////////////////////////////////
//
// lc011. Container With Most Water (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 假如最左邊left比最右邊right小，則以left為底為大容量一定是right為邊界而不是right-2或right-2，
	因為最小高度相同，距離最長容量最大。
	但如果left++到left >= right，則換邊從right方向往左邊遍歷，即right--，直到right==left。.

///////////////////////////////////////////////////////////////
//
// lc012. Integer to Roman
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 把所有數字的case用字串表示，digit by digit累加。
(2) digit by digit，遇到4，5，9特別處理，最後inverse字串。

///////////////////////////////////////////////////////////////
//
// lc013. Roman to Integer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先定義switch return integer value，然後判斷當前value若<下一個則減掉，反之。

///////////////////////////////////////////////////////////////
//
// lc014. Longest Common Prefix (看)* merge sort & binary search。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

解法有vertical scanning，horizontal scanning，divide & conquer，binary search
(1) vertical scanning: 每次判斷所有字串的同一index，若有不同直接return
(2) horizontal scanning: 每次當前str和下一個比較出相同的minIdx，維持這個minIdx
(3) divide & conquer: 每次在merge的時候比較當前左邊的long_str和右邊的long_str
(4) binary search: 每次維持一個找的點L(從當前low+high/2來決定)，若L的substr沒有lcp，
                   則high = L-1; 反之，low = L+1; 此為二分法。

///////////////////////////////////////////////////////////////
//
// lc015. 3Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，3

(1) 先排序，
	設定條件，若當前連續三個和大於target，break。
	 		 若當前和倒數兩個和小於target，continue。
	若下一數等同於當前要固定的數，則在做過當前數的while後，往後相同數都跳過(避免重複固定相同的數)。
	在找到left和right後，因為不能重複組合，若找到往旁邊看有沒有相同，有的話就跳過。
(3) 對於最外層loop判斷有沒有遇過，對於第二層loop，判斷comp = target-nums[i]-nums[j]
	有沒有看過且有沒有指到i，若有，為一組解答。

///////////////////////////////////////////////////////////////
//
// lc016. 3Sum Closest
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) lc015的變形，紀錄最小abs(diff)，return target-diff。

///////////////////////////////////////////////////////////////
//
// lc017. Letter Combinations of a Phone Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs，
	若process到nIdx = string size，則放到output vector。

///////////////////////////////////////////////////////////////
//
// lc018. 4Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先排序，
	外迴圈：
		設定條件，若當前連續四個和大於target，break。
		 		 若當前和倒數三個和小於target，continue。
		若下一數等同於當前要固定的數，則在做過當前數的迴圈後，往後相同數都跳過(避免重複固定相同的數)。
	內回圈，做當前三個數
		若下一數等同於當前要固定的數，則在做過當前數的while後，往後相同數都跳過(避免重複固定相同的數)。
		在找到left和right後，因為不能重複組合，若找到往旁邊看有沒有相同，有的話就跳過。

///////////////////////////////////////////////////////////////
//
// lc019. Remove Nth Node From End of List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為從後面數過來第n個，代表從頭開始走len-n次所到的點，
	但我們不知道len是多少，然而可以先用一個指針走n步，
	那麼當這個指針再走了x步數道null的話，這x就是len-n。
	所以再用一個指針和已經走了x步的指針同時一起走，
	便可找到第len-n個要刪除的位置。

(2) 傳統作法，先跑一次找到長度，再跑一次找到對應位置。

///////////////////////////////////////////////////////////////
//
// lc020. Valid Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用stack，跑完整個input若size > 0，return false，反之。
	若input和stack最後一個不對等，或是stack == 0，return false，否則stack.pop_back()。

///////////////////////////////////////////////////////////////
//
// lc021. Merge Two Sorted Lists
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc023。

(1) divide & conquer
(2) 利用遞迴，return當前比較小的，process當前的next和另一個linklist的node。
    若null，return另一個linklist。

///////////////////////////////////////////////////////////////
//
// lc022. Generate Parentheses (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，放入左括號時機：left < n。
	放入右括號時機：left > right。

///////////////////////////////////////////////////////////////
//
// lc023. Merge k Sorted Lists (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

若直接倆倆合併，其time: O(k^2*N)
time: O(klogk*N)
(1) divide & conquer，利用recursive 寫法合併兩個lists。
	類似lc21。
(2) 利用priority_queue，將所有node加入queue，每次取出最小的，再將最小的next
	放入queue中，直到queue為空的。

///////////////////////////////////////////////////////////////
//
// lc024. Swap Nodes in Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 使用dummy，建立三個pointer：last，prev，now做連接就可以。

///////////////////////////////////////////////////////////////
//
// lc025. Reverse Nodes in k-Group
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc92，lc206。

///////////////////////////////////////////////////////////////
//
// lc026. Remove Duplicates from Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似quick select的partiion，利用一個tag存放最右邊界，其左邊都是不重複的數字。

///////////////////////////////////////////////////////////////
//
// lc027. Remove Element
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc26。

///////////////////////////////////////////////////////////////
//
// lc028. Implement strStr()
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 線性搜尋。

What should we return when needle is an empty string? 
For the purpose of this problem, we will return 0 when needle is an empty string 
(priority greater than haystack is empty). 
This is consistent to C's strstr() and Java's indexOf().

//////////////////////////////////////////////////////////////
//
// lc029. Divide Two Integers (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 維持外圈 while (a - b >= 0)
	內圈找最大的 b使得a - max_b >= 0，也就是 max_b = b*2^n.
	這樣內圈就是O(logN)
	因為外圈每次至少reduce一半的n，外圈是O(logN)，total -> O((logN)^2)。
	The outer loop reduces n by at least half each iteration. So It has O(log N) iterations.
	The inner loop has at most log N iterations.
	So the overall complexity is O((log N)^2)
(2) 跑一個32bit loop，
	如果a >> x - b >= 0，表示存在a - b << x >= 0，x就是b的倍數，可加入
	到res，x可以從31 ~ 0。
	必須從最大往最小走，因爲每次要扣掉最大的b倍數，如同(1)的max_b概念。

///////////////////////////////////////////////////////////////
//
// lc030. Substring with Concatenation of All Words (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 

///////////////////////////////////////////////////////////////
//
// lc031. Next Permutation (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要找到比他大的下一個排列，代表從右往左走，要找到第一個比前一個小的，
	若找不到代表為降序排列，此數字為最大的，若找到，代表此數字往右是降序，
	找到比他大的最小數字，即為下一個最大的開頭，swap後，
	再往右排序即為比他大的最小且下一個排列的數字。

///////////////////////////////////////////////////////////////
//
// lc033. Search in Rotated Sorted Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用二分法(binary search)判斷，(可遞迴可iteration)
	若左區間是有序上升的話，且target在這區間內，則走左區間，反之。
	若右區間是有序上升的話，且target在這區間內，則走右區間，反之。

///////////////////////////////////////////////////////////////
//
// lc034. Find First and Last Position of Element in Sorted Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用兩個binary search，一個正常找左邊邊界，另一個要找右邊邊界，較特殊。
	右邊邊界條件
	while (left <= right)
		if (nums[mid] <= target)
			left = mid+1;
		else
			right = mid-1;

///////////////////////////////////////////////////////////////
//
// lc035. Search Insert Position
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到第一個 >= target，return其index。

///////////////////////////////////////////////////////////////
//
// lc036. Valid Sudoku
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) encode string： i(val), (val)j, i/3(val)j/3
	第一個是第i個row，再來是第j個col，最後是第(i/3, j/3)個block。

///////////////////////////////////////////////////////////////
//
// lc038. Count and Say
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 跑n次迴圈，每次跑一個迴圈對上一個res計算同樣數字出現次數，累加在tmp，結束
	這個迴圈後，res = tmp。

///////////////////////////////////////////////////////////////
//
// lc039. Combination Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc077，利用recursion去做。
https://leetcode.com/problems/combination-sum/discuss/742449/Explanation-of-Time-Complexity

///////////////////////////////////////////////////////////////
//
// lc040. Combination Sum II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc47，因為要不重複，所以要跳過當前做過的重複數字(和上一個比較)。
https://leetcode.com/problems/combination-sum/discuss/742449/Explanation-of-Time-Complexity

///////////////////////////////////////////////////////////////
//
// lc041. First Missing Positive (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找到第一個正整數，可以利用swap換到nums[i] == nums[nums[i]-1]或是
	nums[i] < 0 || nums[i] > n。

///////////////////////////////////////////////////////////////
//
// lc042. Trapping Rain Water (看) 第二種解法
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 跑兩遍，第一遍找當前位置往左邊看最大值，
		   第二遍找當前位置往右邊看最大值，
		   取兩者之小-height[i]，若 > 0，則紀錄。
(2) 類似lc11，維持兩邊最小值，若在左邊，往右找，每個比最小值小的，都記錄差值，
	直到找到比最小值大的，就再重新比較。
	右邊同理。

///////////////////////////////////////////////////////////////
//
// lc043. Multiply Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從兩字串後面算回去，起使index在每個num1的index跑完後往前移一格，
	代表相家從這個index開始，這index以後都是運算完畢的，如同乘法。

///////////////////////////////////////////////////////////////
//
// lc045. Jump Game II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2
(1) 對於i+nums[i] <= maxstep，跳過，若>，maxstep+1~i+nums[i]更新dp值，
	且maxstep = i+nums[i]。若i+nums[i] >= n-1，return dp[i]+1。
(2) O(1) spac，維持兩個變數，last & cur，last表示上次要走的最大步數，cur表示
	當前要走的最大步數，若i == last表示走到上次最大，last = cur，res++，
	若cur >= n-1，直接return。

///////////////////////////////////////////////////////////////
//
// lc046. Permutations (看) 方法1，4。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，用visit紀錄走過的點。
(2) dfs，用swap做排列組合。
(3) dfs，用erase and insert來扣掉做過的點(類似visit)。
(4) iterative，先選一個，再選一個插入當前vector的所有空隙，以此類推。

///////////////////////////////////////////////////////////////
//
// lc047. Permutations II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，檢查當前若和上一個一樣且上一個也是未visit，當前跳過。
	要未visit的才跳過是因為未visit表示屬於同層，visit表示上一層處理過。
	比較有沒有重複都是要同層的。

///////////////////////////////////////////////////////////////
//
// lc048. Rotate Image
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先上下顛倒再對角線交換。

///////////////////////////////////////////////////////////////
//
// lc049. Group Anagrams (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

皆使用unordered_map做查找。
(1) counting sort(O(n*m))來做排序。
	time: O(m*n)
(2) 內建nlogn排序。
	time: O(m*nlogn)

///////////////////////////////////////////////////////////////
//
// lc050. Pow(x, n) (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用遞迴二分法，注意n是負的邊界處理以及n為奇數在遞迴的處理。
(2) 利用iteration，將n分為2進位則當n%2 = 1代表在該idx有值，所以乘上對應的x^k次方。
	ex: x^13，13 = 二進位1101，則x = x^8 * x^4 * x^1。

///////////////////////////////////////////////////////////////
//
// lc053. Maximum Subarray (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持當前到此點的上一點的最大subarr值，若小於0，則此點的subarr值為自己，
    若大於0，則此點的subarr值為上一點的subarr值加上自己。
(2) divide & conquer: 除了左邊和右邊的最大subarr值，還要考慮cross case。
 					  效能不到最好但可以了解divide & conqure的精髓。

///////////////////////////////////////////////////////////////
//
// lc054. Spiral Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從row,col = 0,-1 開始。
	紀錄水平還可以可走次數和垂直還可以可走次數，
	若有0直接break。

///////////////////////////////////////////////////////////////
//
// lc055. Jump Game (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用greedy，維持一個reach，表示當前位置，每次都走最大的步數，
	即reach = max(reach, i+nums[i])。

///////////////////////////////////////////////////////////////
//
// lc056. Merge Intervals
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先排序，若當前比較的頭 <= 最後一個interval的頭，
	取兩者的尾的max當作最後一個interval的尾。
	類似lc986。

///////////////////////////////////////////////////////////////
//
// lc057. Insert Interval
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc056，唯一差別是每次都比較當前interval[i][0]和newInterval[0]，較小的
	進入lc056的核心方法比較。

///////////////////////////////////////////////////////////////
//
// lc058. Length of Last Word
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後面算回去。

///////////////////////////////////////////////////////////////
//
// lc059. Spiral Matrix II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

從(r,c) = (0, -1)開始順著跑。

///////////////////////////////////////////////////////////////
//
// lc060. Permutation Sequence (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先算出1~n-1階乘，再來對k一層一層除以階層來算出順序。

///////////////////////////////////////////////////////////////
//
// lc061. Rotate List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 算出list長度，對k取餘數，在從左往右找到斷點重新連接。
	注意邊界問題 (k = 0或k%len = 0)。

///////////////////////////////////////////////////////////////
//
// lc062. Unique Paths
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) iterative dp，當前=左邊+上面，i = 0 or j = 0 直接給1。
(2) dfs遞迴：用一n*m陣列紀錄有沒有走過(back track)。
	若有直接加上當前走過的值，這樣就不用再重複往(0,0)方向遞迴，
	因為之前就走過。

///////////////////////////////////////////////////////////////
//
// lc063. Unique Paths II
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dfs 遞迴，遇到障礙直接給0。
(2) dp iteration，遇到障礙直接跳過(因為預設所有陣列都是0)。

///////////////////////////////////////////////////////////////
//
// lc064. Minimum Path Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 3

類似lc062，
(1) dfs recursion with space O(mn)。
(2) dp iteration with space O(mn)。
(3) dp iteration with space O(n)。

///////////////////////////////////////////////////////////////
//
// lc066. Plus One
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從右到左，將>9的改成0，若沒有則跳出迴圈，對於跳出迴圈錢紀錄的最後一位index加一。

///////////////////////////////////////////////////////////////
//
// lc067. Add Binary
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc002。
(1) 跑一個迴圈是aidx，bidx，carry，只要上述這三個任一還達到條件就繼續跑。

///////////////////////////////////////////////////////////////
//
// lc069. Sqrt(x) (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc50，用binary search加速找到x的根號值。

///////////////////////////////////////////////////////////////
//
// lc070. Climbing Stairs (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc518，但原理相反，dp[n] = dp[n-1] + dp[n-2];
	若有先後順序，外層回圈為amount，內層為方法數(coins, step)。
	因為這樣就是當前數量是之前數量的排列組合，會有先後順序，如1+2和2+1。
	若沒有先後順序，外層為方法數(coins, step)，內層回圈為amount。
	每次都算出所有amount對於一種coin的dp方法。

///////////////////////////////////////////////////////////////
//
// lc073. Set Matrix Zeroes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先確認第零row或第零col有沒有0，有的話tag = true，再來對非零列或非零行
	找有沒有0，若有將其matrix[i][0] 和 matrix[0][j] 設置成0，此設法不會
	影響結果，用作tag，再來對非零列或非零行找matrix[i][0] 和 matrix[0][j] 
	有沒有=0，若有就改成0，最後若一開始的0 row或0 col tag = true，將整行或整列
	改成0。

///////////////////////////////////////////////////////////////
//
// lc074. Search a 2D Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search, O(log(m*n))。
(2) linear search, O(m+n)。

///////////////////////////////////////////////////////////////
//
// lc075. Sort Colors (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) (較好)
	利用兩指針，L代表最右邊的0，R代表最左邊的2，
	遇到0就和最左邊界下一位換(++L)，i++。
	遇到2就和最右邊界下一位換(--R)，若i >= 最右邊界，不換且i++。
	遇到1，i++。

(2) 遇到0插入vector頭，遇到2插入vector尾。
	注意拜訪index，插入頭不影響index，所以i++，
	插入尾影響index，所以i不便，
	不做插入則i++ (遇到1的情況)。

///////////////////////////////////////////////////////////////
//
// lc076. Minimum Window Substring (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window，因為是subsequence，只要區間內有足夠的cnt就可以，不用連續。
	所以向右找直到cnt == t.size()後，滑動left window直到最後一個cnt == 0，表示
	最短的window。

///////////////////////////////////////////////////////////////
//
// lc077. Combinations (看) 第二種解法
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs
(2) C(n, k) = C(n-1, k) + C(n-1, k-1)
上述兩種遞迴解法需要注意當n小於要選的數量k就要return。

///////////////////////////////////////////////////////////////
//
// lc078. Subsets (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs遞迴紀錄最後使用的index來當每次function的起始迴圈位置。
(2) iterative疊加：
	對於當前output，每個子集合加入一尚未加過的數字，並保有原本的子集合。

///////////////////////////////////////////////////////////////
//
// lc079. Word Search
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs，若走過，將字元做標記。
	若找不到路，將走過的字元還原成本來的值。
	!!注意!!若要用遞迴，傳入參數size過大，要用reference傳。

///////////////////////////////////////////////////////////////
//
// lc080. Remove Duplicates from Sorted Array II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: O(n), space: O(1)。
	維持idx表示final array的長度，若當前nums[i] > nums[idx-k]，表示
	不是連續k個一樣的，nums[idx++] = nums[i]。
	這題求的是duplicate，可改為k。

///////////////////////////////////////////////////////////////
//
// lc081. Search in Rotated Sorted Array II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc033差不多，
	唯一要注意的是若nums[start] = nums[mid]，start++，
	因為nums[start] = nums[mid]的話無法確定有沒有遞增，
	時間複雜度還是O(logN)，但worst case是O(N)。

///////////////////////////////////////////////////////////////
//
// lc082. Remove Duplicates from Sorted List II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當遇到now->val和now->next->val不同時
	利用flag來判斷now->val是不是一直重複，
	有的話pre->next = now->next。
	沒有的話 pre = now, now = now->next。

///////////////////////////////////////////////////////////////
//
// lc083. Remove Duplicates from Sorted List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到最後一個與當前一樣的，pre->next = cur，pre = cur，cur = cur->next。
	注意邊界問題(NULL)。

///////////////////////////////////////////////////////////////
//
// lc084. Largest Rectangle in Histogram (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc42，lc11，要求區間內最大值，可以往單調陣列去想。
	假設維持降序序列，當遇到value > sk.top時計算sk.top往前的容量，然而若給定
	是升序序列，則每個val都只能算自己的值。
	因此我們必須採用升序序列去做，若遇到比自己小的值就把sk.top的值往前看計算期長度，
	另外升序的話才能先處理大的再處理小的，因為先處理高的，其寬度較小，在處理矮的，
	寬度較大，如此能把所有case都包含進去，也就是找局部峰值。
	***Note: 處理時，當前val的最大寬度為i-sk.top()-1。

另一種解法較簡單，將每個val當作尾巴往前找最小值*上寬度，求最大面積即可。

///////////////////////////////////////////////////////////////
//
// lc085. Maximal Rectangle (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc221，先跑一遍算出每個點的最長row，再來跑一遍對於當前點往上看，
	保持一個最小row，與高度相乘，隨時更新max rectangle。
(2) 類似lc084。
	將每一層往上當一個histogram去看。

///////////////////////////////////////////////////////////////
//
// lc086. Partition List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1)	建一個list，在本來list中小於val的放到這個list，最後將這list接到本來list的頭。
(2)	建兩個list，小於val放一個，大於等於val放另外一個。
	注意連接兩個list的NULL與否問題。

///////////////////////////////////////////////////////////////
//
// lc088. Merge Sorted Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 跑一次迴圈，從後面填入val (nums1[i] > nums2[j]，填nums1[i]，反之)。

///////////////////////////////////////////////////////////////
//
// lc090. Subsets II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) iteration，若這次數字和上次相同，只需要從上次插入數字前的size開始即可。
	也就是插入經過上次新增數字，這些數字都沒有被插入過，所以不會重複。
	ex: 1. 插入2: [] -> [] 2
	    2: 插入2: 因為與上次相同，所以只需要從idx = 1(上次插入前的size)開始插入。

(2) 如同3sum處理重複的作法，這次插入的數字和上次一樣，就跳過。 
	(條件要加上 i>pos, pos為這次遞迴的起點idx)。

///////////////////////////////////////////////////////////////
//
// lc091. Decode Ways (看) 第二種方法
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dp iteration：
	若當前數字不等於'0' 
		dp[i] += dp[i-1];
	若當前數字和上一數字組合為 "1x" or "20"~"26"，
		dp[i] += dp[i-2];

(2) O(1) space:
	利用兩遍量紀錄當前的i-1(i_1)和i-2(i_2)方法數，迴圈從1開始:
	若s[i] = '0'，i_1 = 0，
	
	另外核心思想是i_2再下一輪會是i_1的值：i_2 = i_1
	若符合的當前和上一位可以解碼，i_1 += i_2，i_2 = i_1-i_2。
	反之，i_2 = i_1。

///////////////////////////////////////////////////////////////
//
// lc092. Reverse Linked List II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc206，注意邊界問題就好。
	有用虛擬head: dummy指向head，比較好general處理邊界問題。

///////////////////////////////////////////////////////////////
//
// lc094. Binary Tree Inorder Traversal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 3

(1) 遞迴跑inorder
(2) iterative method: 
	用stack做inorder，每次都把left放進stack直到NULL，
	pop出一個，對這個node放入node->right，代表要往右處理tree的右半部，
	右半部裡面若有左子樹又會照上述的步驟進行，直到樹被跑完且stack為空。
(3) morris traversal:
	if left child不是空的，
		讓當前node成為left child的最右邊的孩子的right child，
		前提是這個right child不是當前node，
		若是的話代表node的左子樹整個都走過了，那就print當前這個node，並移往右孩子。
	else
		print 當前node，並移往右孩子。

///////////////////////////////////////////////////////////////
//
// lc095. Unique Binary Search Trees II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 使用方法為類似lc096的dp遞迴，差異在每次拿出的左子樹和右子樹，不只要數量，還要所有組合。
	因此要多使用vector<TreeNode *>表示子樹的組合種類。

///////////////////////////////////////////////////////////////
//
// lc096. Unique Binary Search Trees (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

用dp解 dp[n] = dp[i]*dp[n-i-1]， i = 0~n-1， sigma起來總和
(1) iteration
(2) recursion: 注意recursion如果要跑遞迴的值已經不為0就不用跑。
			   避免重複累加計算。

///////////////////////////////////////////////////////////////
//
// lc098. Validate Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 前序遍歷，動態維持當前node的邊界(min，max)
	若往右走min改為當前node，若往左走，max改為當前node。
(2) 中遍歷，和上一個點比，若比上一個點小，則不合法。

///////////////////////////////////////////////////////////////
//
// lc099. Recover Binary Search Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc94。
(1) O(1) space 解法，利用morris traversal。
(2) O(n) space 解法：
	- recursion。
	- stack iteration。
利用雙指針，first & second，代表第一個和第二個不符合規則的。

///////////////////////////////////////////////////////////////
//
// lc100. Same Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

和101類似。
(1) recursion解法
(2) 可用兩個queue去解，同方向丟入queue(que1丟left，que2就丟left，反之)。

///////////////////////////////////////////////////////////////
//
// lc101. Symmetric Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc951，遞迴解。
(2) 可用兩個queue去解，對稱式丟入queue(que1丟left，que2就丟right，反之)。

///////////////////////////////////////////////////////////////
//
// lc102. Binary Tree Level Order Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dfs：
	每次call dfs將當前的val放入output。
	若output size <= 當前level，則new一vector並push_back，
	反之就對於相應位置的vector用push_back。
	當left or right!= NULL，就call並傳入當前level+1。

(2) bfs：
	預設qsize = 1，並把root丟到queue
	當queue不是空的，將head的孩子丟到queue裡並pop。
	每次pop就qsize--並且把pop的元素加入vec
	當qsize = 0，將vec push_back到output並讓qsize = 當前queue.size()。

///////////////////////////////////////////////////////////////
//
// lc103. Binary Tree Zigzag Level Order Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用bfs印出左到右，當為由到左時，reverse (有不用STL function的方法)。

///////////////////////////////////////////////////////////////
//
// lc104. Maximum Depth of Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，return對於左子樹和右子樹取大者再+1。

///////////////////////////////////////////////////////////////
//
// lc105. Construct Binary Tree from Preorder and Inorder Traversal (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遞迴解。
(2) iteration with stack，
	push preorder into stack and pop with inorder。
	push左半邊並建左半邊樹，
	pop直到左半邊都結束就可將下一個root接到右孩子，在繼續往右孩子的左半邊做。

///////////////////////////////////////////////////////////////
//
// lc106. Construct Binary Tree from Inorder and Postorder Traversal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc105。
(1) postorder的最後一個是root，就如同preorder的第一個是root，利用這規律make tree。

///////////////////////////////////////////////////////////////
//
// lc107. Binary Tree Level Order Traversal II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc102一模一樣，可用bfd或dfs。

///////////////////////////////////////////////////////////////
//
// lc108. Convert Sorted Array to Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到陣列中間，當root，遞迴跑root->left, root->right。
	binary search。

///////////////////////////////////////////////////////////////
//
// lc109. Convert Sorted List to Binary Search Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用快慢指針找出中間點，遞迴找left & right
	利用頭尾當邊界來算出中間點，當頭=尾，return NULL。

///////////////////////////////////////////////////////////////
//
// lc110. Balanced Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用postorder遍歷到底端後往top計算深度，當前節點為最大深度為max(左節點,右節點)+1
(2) 用preorder計算當前節點的最大深度: max(左節點,右節點)，由上往下遍歷

///////////////////////////////////////////////////////////////
//
// lc111. Minimum Depth of Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，因為要從葉子往上算，所以當前節點中只有一子樹為null的話，往另一個子數做遞迴。
	遇到null，return 0。

///////////////////////////////////////////////////////////////
//
// lc112. Path Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc111，因為要從葉子往上算，所以當前節點中只有一子樹為null的話，往另一個子數做遞迴。
	遇到葉子去看sum有沒有和葉子的val一樣。

///////////////////////////////////////////////////////////////
//
// lc113. Path Sum II (看) 沒想到從上往下，思路卡在由下往上做。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用preorder (dfs) 解。

///////////////////////////////////////////////////////////////
//
// lc114. Flatten Binary Tree to Linked List (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs recursion，使用dummy。
(2) 將右子樹放到左子樹的最右邊，將左子樹放到右子樹，左子樹=NULL。

///////////////////////////////////////////////////////////////
//
// lc116. Populating Next Right Pointers in Each Node
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 與lc117一樣作法。

///////////////////////////////////////////////////////////////
//
// lc117. Populating Next Right Pointers in Each Node II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method  1

(1) 實作queue，
	紀錄當前level的點：now，head和rear紀錄當前層的下一層。
	當把now的left和right加入queue後，now = now->next，
	若now為NULL代表該層已做完，更新now至下層的頭：head，然後head = rear = NULL。

(2) 實作queue，(自己想的)
	紀錄當前和上一層的queue size，每加入一個元素至queue，當前q_size+1
	每次pop時，上層q_size減一，當等於0的時候代表該層已全處理完，
	更新上層q_size至當前queue的size，(代表移往下層做處理)，
	並將該次pop出的元素->next指向NULL。

(3) 利用STL容器queue，並跑bfs，紀錄當前level的size:q_size，
	每次pop就減一，當等於0的時候代表該層已全處理完，
	更新q_size至下一層queue的size，
	並將該次pop出的元素->next指向NULL。

///////////////////////////////////////////////////////////////
//
// lc118. Pascal's Triangle
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc120，從上往下做，注意頭尾邊界處理。

///////////////////////////////////////////////////////////////
//
// lc119. Pascal's Triangle II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc120，差別在這題是取單列，用一個vector紀錄最後一列，當前列用最後一列算出。
	可作空間用化，只用一個vector而非兩個。

///////////////////////////////////////////////////////////////
//
// lc120. Triangle (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用iteration dp解，遞迴會TLE。
	!!!注意O(n) space解法，從底層往上做。
	dp[j] = min(dp[j], dp[j+1]) + triangle[i-1][j]

///////////////////////////////////////////////////////////////
//
// lc121. Best Time to Buy and Sell Stock
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個最小值，為到目前為止的最小買入價格，
	維持一個最大值，為到目前為止的售出價格-買入價格。
	return 最大值。

///////////////////////////////////////////////////////////////
//
// lc122. Best Time to Buy and Sell Stock II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc309，利用state machine來記錄每個階段的最大利潤s_sell和s_buy。
	賣的狀態：s_sell = max(s_sell, s_buy+prices[i]);
	買的狀態：s_buy = max(s_buy, s_sell-prices[i]);
	return s_sell。

///////////////////////////////////////////////////////////////
//
// lc124. Binary Tree Maximum Path Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc865。
	利用postorder，
	若該點為路徑最高點，則root->val+leftv+rightv。
	若該點只是經過，則max(root->val+max(leftv,rightv), root->val)。
	***follow up：返回最大陸路徑和的路徑。

///////////////////////////////////////////////////////////////
//
// lc125. Valid Palindrome
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於不是數字或字母的都跳過，
	比較s[left] == s[right] or (s[left]^32) == s[right]。


///////////////////////////////////////////////////////////////
//
// lc126. Word Ladder II (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bi directional，維持一個unordered_set<string, vector<string>>
	表示當前word的下一步，用來到時候getpath可以串連路線。注意若不是從begin
	開始，加入時要倒著加，可用一變數判斷當前是從end開始還是begin開始。
	和lc127不同的是因為可能當前這輪都會走到同一點，lc127是找到那一點就erase，
	這題不行，不然其他點就走不到，solution會變少，所以做法是做完這一輪再erase所有這輪
	走過的點。

	time complexity:
	Let's call k the max number of neighbors of a node, and d is the distance from start to end. 
	In traditional BFS, we explore k nodes at each BFS level, each one generating in the worst case k 
	neighbors till we find end. So the maximum number of nodes we explore till we reach end is k*k*k...*k, d times. So it's O(k^d).

	In double-ended BFS we finish when the forward and backward searches collide. 
	Where do they collide? Approximately at d/2 distance. Let's call this point mid. 
	So it's O(k^(d/2)) (start to mid) + O(k^(d/2)) (end to mid), yielding O(k^(d/2)). 
	Yes, it's the same class of complexity of standard BFS, 
	but for large graphs double-ended BFS may give you the right result waaaaaaay faster.

///////////////////////////////////////////////////////////////
//
// lc127. Word Ladder (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，bidirectional，對少的詞的一邊做expand。
(2) bfs，對每個詞的每一位，有26個走法，O(n)。
(3) bfs，對每個詞找wordList中和自己差一位的，O(n^2)。

///////////////////////////////////////////////////////////////
//
// lc128. Longest Consecutive Sequence (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) unordered_set
	先將所有element放到set中，然後遍歷vector，如果在set中，erase並且
	往左右找直到找不到，這中間找到的都要erase，然後儲存長度與res比。
(2) unordered_map
	遍歷vector，如果在map中則跳過，不在的話，找出左右一個元素的value，
	sum = left + right + 1。
	且
	map[nums[i]-left] = sum，
	map[nums[i]+right] = sum。
	這目的是一個連續邊界的最大值，這樣下次碰到邊界的旁邊(沒遇到過的，
	在邊界裡的會跳過)，可以直接取該連續數列的長度。

///////////////////////////////////////////////////////////////
//
// lc129. Sum Root to Leaf Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc130. Surrounded Regions
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，從邊上走dfs轉成特殊字母，最後跑一次遍歷，特殊字母轉乘‘O’，其餘
	轉成'X'。

///////////////////////////////////////////////////////////////
//
// lc131. Palindrome Partitioning (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先將i到j是否回文紀錄好，類似lc647。
	再跑dfs，對於每個切的點判斷可不可以切，不可以就跳過，可以就再call dfs。
	time complexity: n*(2^n)。

///////////////////////////////////////////////////////////////
//
// lc133. Clone Graph (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map作為node和clone node的對應，可bfs或dfs。

///////////////////////////////////////////////////////////////
//
// lc134. Gas Station (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若從頭到目前為止和為負的，下一個點當起點，因為之前都是負的表示之前的點都不適合
	當起點，起點必須為一直加都為正的。

///////////////////////////////////////////////////////////////
//
// lc136. Single Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 同樣的數字xor會=0，因此single number會直接維答案。

///////////////////////////////////////////////////////////////
//
// lc137. Single Number II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為xor代表bit相加，我們可以開立目前為止出現一次的bit情況：ones
										二次的bit情況：twos
										三次的bit情況：threes
	若當前數字和ones做xor一定會有進位問題，表示兩個都1，那我們要先儲存這個1
	到二進位的話，可以先tows = twos | ones & nums;這樣就可以記錄當前數字有1的bit和
	ones也有1的bit，有兩個，進位到twos中。
	再來做一進位的相加 ones = ones ^ nums;
	若ones和two兩者同位都有1表示出現三次，清空。
	return ones即為答案。
(2) 在每一位bit都和所有數字做&，若次數％3不等於0，表示該為有出現一次的值。
	累加這些值在這32位過程即為答案。
follow up：出現兩次的就return twos。
https://www.cnblogs.com/daijinqiao/p/3352893.html

///////////////////////////////////////////////////////////////
//
// lc138. Copy List with Random Pointer (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先複製一份與本來的一樣的點在本來的點的後面，讓複製的點的random指到本來的點的random的next，
	最後將這arr分成兩個即為結果。

///////////////////////////////////////////////////////////////
//
// lc139. Word Break (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dp iteration：
	假設dp[i]表示到i為止都可以被拆分，
	dp[i] = 1 if dp[j]=1且 s[j+1:i]在word list裡。
	細節：找dp時從j = i往0找，因為從0找substr相當於從頭找，會比較慢。
(2) dp recursion：
	類似lc140，所用方法為lc140的精髓，參考lc140。

///////////////////////////////////////////////////////////////
//
// lc140. Word Break II (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於這種return 組合的題目，通常用recurion和記憶模組(unordered_map<string, vector<string>>)。
	因此對於input string，找一個wordDict[i]使得s可被拆分為wordDict[i] + s.substr(wordDict[i].size());
	遞迴下去跑s.substr(wordDict[i].size()) 得到vector<string> recur;
	將其一一和wordDict[i]合併即為map[s]的vector<strin>。
	time complexity: O(n^2)
	With memoization since we are storing all possible strings in map 
	so the max number of string in map can be N and for each string 
	we are considering all possible substring so the complexity in this case is N^2

///////////////////////////////////////////////////////////////
//
// lc141. Linked List Cycle
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc142，一樣用快慢指針。

///////////////////////////////////////////////////////////////
//
// lc142. Linked List Cycle II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

利用快慢指針所到的交會點，再從此交會點和原點一起順著走，相遇點即為cycle入口。
假設head至入口為a，入口至相遇點為b，相遇點再到入口為c，
2*(a+b) = a+b+n*(b+c) -> a+b = n*(b+c) -> a = (n-1)(b+c) + c;
也就是說從head走到入口的距離等同於從交會點順著走n-1圈後再走長度c。 

///////////////////////////////////////////////////////////////
//
// lc143. Reorder List (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

先用快慢指針算出中間點，把後半段reverse後，和前半段merge。
要注意奇數merge和偶數merge在最後一個node的不同。
*** 更新: merge的時候不用管奇偶數，在找到對半點就將slow->next = NULL就好。
	參考方法一。

///////////////////////////////////////////////////////////////
//
// lc144. Binary Tree Preorder Traversal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 3

(1) 遞迴跑preorder
(2) print當前cur，加入cur->right至stack，cur = cur->left。
	接著若cur是NULL，且stack不為空，則從stack pop出一個。
(3) 和inorder的morris traversal差不多。
	唯一的差別是在push的時候是當cur的left的最右孩子指向null時print cur。

///////////////////////////////////////////////////////////////
//
// lc145. Binary Tree Postorder Traversal (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 3

(1) 遞迴跑postorder
(2)	每次在迴圈開始對stack的top做處理。
	利用一便數控制有沒有自己的孩子有沒有處理過，
	若有自己才能print並pop，且讓便數等於自己。
	若沒有處理過且自己有孩子，將孩子放入stack。
(3) 與preorder或inorder的morris traversal不同
	需要有一個super root，其leftchild = root，
	連接方式和preorder，inorder相同，當cur的左孩子的最右節點為cur時，
	必須倒敘print出，因此後續原理就是每次都倒敘print出從該點往右下斜線所有點。
	(倒著印，當該點的爸爸=右下斜線最後一點的right)。

///////////////////////////////////////////////////////////////
//
// lc146. LRU Cache (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用c++ list去做，建立unordered_map<key, list<pair<int, int>>>::iterator> map;
	注意map存方的value是這對pair在list的位置，而不是單純的key對應到的val，目的是這樣取得位置
	就可以做刪除和insert的動作。

///////////////////////////////////////////////////////////////
//
// lc147. Insertion Sort List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個insersition list，每次看到新的從左開始找適合的點插入
	insertion->next->val > cur->val，則插入。

///////////////////////////////////////////////////////////////
//
// lc148. Sort List (看)* 第一種方法。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) merge sort，中間點用快慢指針，類似lc021。 
	要注意找出中間點時，左邊的尾巴要指向NULL。
(2) quick sort，將list分為三種：大於，等於，小於。
	將這3個list尾巴都指向NULL，遞迴後得到sort過的list再拿去merge。

///////////////////////////////////////////////////////////////
//
// lc150. Evaluate Reverse Polish Notation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) stack operation。

///////////////////////////////////////////////////////////////
//
// lc152. Maximum Product Subarray (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp，維持當前最大和當前為小，做三比較(當前最大*當前數字，當前最小*當前數字，當前數字)
	遇到0，當前最大和當前最小要設為0。
(2) 類似lc053的divide and conquer，差別在橫跨中間時，左邊要算出最大和最小，右邊要算出最大和最小
	取最大*最大和最小*最小做比較當作橫跨中間的最大值。

///////////////////////////////////////////////////////////////
//
// lc153. Find Minimum in Rotated Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc33，lc81，最小值一定會在非上升序列的那個區段，若左右兩序列都上升
	序列，return 左右兩個頭中最小的。

///////////////////////////////////////////////////////////////
//
// lc155. Min Stack (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用一個stack，若當前x <= min_val，push(min_val)後，min_val = x。
	目的是儲存上一個min_val。因此當pop掉的是min_val，skack的下一個必為
	push這個值之前的min_val。

///////////////////////////////////////////////////////////////
//
// lc156. Binary Tree Upside Down (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，root->left->left = root->right
			   root->left->right = root，用**pointer去紀錄new root。

///////////////////////////////////////////////////////////////
//
// lc159. Longest Substring with At Most Two Distinct Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pointer，維持subarry讓diff <= 2。

///////////////////////////////////////////////////////////////
//
// lc160. Intersection of Two Linked Lists (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 走完自己走別人，最後的點即為相遇點(沒有的話會null)
(2) 長的list先走和短的list差距的長度，然後一起走，必有相遇點(沒有的話會null)

///////////////////////////////////////////////////////////////
//
// lc162. Find Peak Element (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用binary search，一直找到最高點，即
	if (nums[mid] < nums[mid+1]) left = mid+1;
	else right = mid;

///////////////////////////////////////////////////////////////
//
// lc167. Two Sum II - Input array is sorted
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc001，這題更簡單，因為已經排序過，用left，right兩指針來逼近target值就好。

///////////////////////////////////////////////////////////////
//
// lc168. Excel Sheet Column Title
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc171，比較特別且要注意的是每次要n--再取餘數，才能取到正確的字母。

///////////////////////////////////////////////////////////////
//
// lc169. Majority Element (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為會過半數，所以和自己不同的兩兩抵銷(用count紀錄當前major出現次數)必會剩下一個，此為最多數。
(2) 可通過排序再取中間數，但為O(nlogn)，沒有(1)的O(n)好

///////////////////////////////////////////////////////////////
//
// lc171. Excel Sheet Column Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似26進位， res = res*26 + s[i]-'A'+1。

///////////////////////////////////////////////////////////////
//
// lc172. Factorial Trailing Zeroes (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算n!中0的個數，代表計算10的個數，也就是2和5的個數，因為2遠比5多，
	所以計算5的個數。
	n/5 + n/(5*5) + n/(5*5*5)...。

///////////////////////////////////////////////////////////////
//
// lc173. Binary Search Tree Iterator
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 類似lc094 stack作法，constructor放入當前左子樹，每次取出一個，
	若有右孩子，將右孩子的左子樹放入stack。
(2) morris traversal

///////////////////////////////////////////////////////////////
//
// lc179. Largest Number
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 先轉字串，利用排序法，比較a和b時，a+b>b+a則a放在b前面。
(2) 也可用內建sort排序，定義compare function。

///////////////////////////////////////////////////////////////
//
// lc189. Rotate Array (看)* 看方法2。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先翻轉vector，再對前k個翻轉，後n-k就翻轉。
(2) (難想)：
	對當前項紀錄cur = nums[idx+k]，且將最後一次紀錄的pre填到nums[idx+k]，
	即nums[idx+k] = pre, pre = cur，idx = (idx+k)%n，
	為避免造成只會繞著某幾位轉(ex：nums.size() = 6, k = 2，1->3->5->1->3->5)，
	當idx回到start，idx = ++start，pre = nums[pre]。
(3) 將首項pushback n-k次且同時erase。

///////////////////////////////////////////////////////////////
//
// lc190. Reverse Bits (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc136，都是bit operation的操作。
	對於res的當前一位，先shift 1( res << 1)，將n的最後一位放到res的第1位。

///////////////////////////////////////////////////////////////
//
// lc191. Number of 1 Bits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc190，對最後一位去看是不是1： res += (n & 1);
	取最後一位就用1去做&就好。

///////////////////////////////////////////////////////////////
//
// lc198. House Robber (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個dp[i] = max(dp[i-1], dp[i-2]+nums[i])。
	表示當前最大偷錢為 (a) 當前不偷，選用上一個偷錢數量。
				  	(b) 當前偷，加上上上個偷錢數量。
	(a)和(b)取最大值。				 

***優化為：維持evenMax和oddMax
		  若當前為偶數idx，則抓錢最大化為 max(evenMax+nums[idx], oddMax)。
		  奇數反之。

///////////////////////////////////////////////////////////////
//
// lc199. Binary Tree Right Side View (看) 反向dfs。
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) bfs
(2) dfs，將preorder左右順序互換，反向dfs。

///////////////////////////////////////////////////////////////
//
// lc200. Number of Islands (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dfs
(2) bfs: bfs要在加入que的時候就改，避免一個node被兩個同時連到的情況：
		 a和c都連b，在處理a的時候將b加入queue，a改被處理過，這時queue裡有b和c，
		 取出b又會再將c加入一次，但其實c已經被走過。
(3) follow up: (未解決)
		算最短曼哈頓距離
		算島嶼面積
		填上一個點後，哪個點可以使得到最大島嶼面積

///////////////////////////////////////////////////////////////
//
// lc202. Happy Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

happy number和不會是4。
(1) 一般跑回圈，n == 4 或 n == 1跳出return。
(2) 利用快慢指針來找出重複數字，(類似找環)。
	類似lc142。

///////////////////////////////////////////////////////////////
//
// lc203. Remove Linked List Elements
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dummy和pre，cur雙指針來做link list重新連接。
	如果cur->val == val，pre->next = cur->next。

///////////////////////////////////////////////////////////////
//
// lc204. Count Primes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

利用質數篩檢法，將小於sqrt(n)的所有質數倍數挑出來，剩下的就是質數。
time complexity: O(NloglogN)
https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html

///////////////////////////////////////////////////////////////
//
// lc205. Isomorphic Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立雙向bi-directional vector紀錄字母是一對一映射。
	類似lc890。

///////////////////////////////////////////////////////////////
//
// lc206. Reverse Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) recursion (double link list)。
(2) iteration。

///////////////////////////////////////////////////////////////
//
// lc207. Course Schedule (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

有向圖找環
(1) dfs找灰色點(白色call dfs，黑色跳過)。
(2) bds拓樸排序，丟入度為0的點進queue。

///////////////////////////////////////////////////////////////
//
// lc208. Implement Trie (Prefix Tree) (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立trie tree data structude和一個變數判斷當前是不是string。
** follow up ** delete word (可參考討論區)。

///////////////////////////////////////////////////////////////
//
// lc209. Minimum Size Subarray Sum (看)* 看nlogn解法
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) one pass解法：
	維持left和right，先往右找到>=s的點再讓left往右到<s，
	每次都維持min_len，直到right > 邊界。
(2) O(nlogn) binary search，先維持一個到任意idx總和的陣列：sum，
	再利用binary search 逼出總和>=s的點。
	**===要注意當return的right為最後一個點，直接檢查有沒有>=s。===**

///////////////////////////////////////////////////////////////
//
// lc210. Course Schedule II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc207一樣。

///////////////////////////////////////////////////////////////
//
// lc212. Word Search II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用trietree，以及dfs，當前不能在trietree有東西時，就return。
	time complexity:
	// time O(cnt * len + m * n * min(4 ^ maxlen, m * n))
	// space O(cnt * len)
	// cnt is the number of words
	// len is the average length of words
	// m * n is the size of board
	// maxlen is the max length of words
(2) 將每一個word跑一遍m*n dfs，每一個dfs為m*n，利用len 表示當前檢測到
	哪一個位置，若idx == word.size()-1，return true。

///////////////////////////////////////////////////////////////
//
// lc213. House Robber II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 偷第一間就不能偷最後一間，反之。
	因此分兩步驟走：
	- (1)不偷第一間的情況   (0 ~ n-2)。
	- (2)不偷最後一間的情況 (1 ~ n-1)。

	兩種情況取最大值。

///////////////////////////////////////////////////////////////
//
// lc214. Shortest Palindrome (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc459。

///////////////////////////////////////////////////////////////
//
// lc215. Kth Largest Element in an Array (看)* heap sort
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 4

(1) quick select partion，若找到的mid>k則往左找，反之。
	注意選擇的pivot要用random。
(2) max heap, O(n) + klogn
(3) sort, nlogn
(4) priority queue, klogn

///////////////////////////////////////////////////////////////
//
// lc216. Combination Sum III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用遞迴，檢查k==0 && target==0 就將當前vec加入到res中。
	time complexity: O(9^k) or C(9, k)
	space complexity: O(k)

///////////////////////////////////////////////////////////////
//
// lc217. Contains Duplicate
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) hash map。
(2) sort。

///////////////////////////////////////////////////////////////
//
// lc219. Contains Duplicate II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用hashmap，因為要找重複項index差距最多不超過k，所以每次更新nums[i]的位置，
	這樣差距只會越來越小。

///////////////////////////////////////////////////////////////
//
// lc221. Maximal Square (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 紀錄當前點的最大邊長，利用dp[i] = min(dp[i], dp[i-1], pre)。
	pre為當前點的左斜上的點，意即matrix[i-1][j-1]。

///////////////////////////////////////////////////////////////
//
// lc222. Count Complete Tree Nodes (看) 有點難想。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為是complete tree，左子樹或右子樹必為full complete tree，
	所以算到full complete tree，直接算pow(2,h)-1，
	若當前不是full complete tree，遞回去算full complete tree
	=> 1 + dfs(root->left) + dfs(root->right)
	time complexity: O(logN*logN)
	since always at least one of the two recursive calls is such a full tree, 
	at least one of the two calls immediately stops. Again we have runtime O(log(n)^2).

///////////////////////////////////////////////////////////////
//
// lc225. Implement Stack using Queues
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當push x時，把當前queue重新push進入queue。

///////////////////////////////////////////////////////////////
//
// lc226. Invert Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs互換left和right tree。

///////////////////////////////////////////////////////////////
//
// lc227. Basic Calculator II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(1) space： 遇到數字，把所有*和/算完，與當前ans做相加或相減。
(2) O(n) space： 使用stack，遇到+-*/時，
				 先用op把sum和stack的top做運算，在將當前運算符號記錄到op中。

///////////////////////////////////////////////////////////////
//
// lc228. Summary Ranges (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1)跑回圈找到連續number的尾部，連同start一起push到res。

///////////////////////////////////////////////////////////////
//
// lc229. Majority Element II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc169類似，一組數列中超過n/3的數字最多兩個，如果三個代表總合>n/3，與題目的n
	個不成立，因此維持兩個計數器，當有第三個和這兩個不一樣，兩個計數器都減一。
	最後再便利一次確定計數器中的值是正確過n/3的值。

///////////////////////////////////////////////////////////////
//
// lc230. Kth Smallest Element in a BST (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 3

和lc094類似。
(1) dfs recursion。
(2) stack iteration。
(3) morris traversal。

** follow up
priroty_queue, insert, delete, find O(log(n))。
vector<> save, insert, delete O(n), but find O(1)。

///////////////////////////////////////////////////////////////
//
// lc231. Power of Two (看) 第二個方法
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為2的次方，整個數字只有一個1，所以可以cnt += (n&1)，cnt = 1才是2的次方。
(2) O(1) time，因為2的次方只有1個1，所以可以用 n&(n-1)是否等於0來判斷是否為2的次方。

///////////////////////////////////////////////////////////////
//
// lc232. Implement Queue using Stacks (看)* 看方法2。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 在push x的時候翻轉當前stack，翻轉出來的值先用一個tmp stack裝著，push後，
	再將tmp中的值放回主stack。
(2) 因為方法一要在每次push x時process兩個stack，效率差，
	這邊用一個stack sk_tmp專門push x進去，當要pop或peep，將當前stack翻轉放到sk_now，
	並取出其top，當sk_now.size() == 0，將sk_tmp再翻轉進去sk_now。
	注意！！一定要sk_now用完才能將sk_tmp翻轉進入stack，因為要保持其順序。

///////////////////////////////////////////////////////////////
//
// lc234. Palindrome Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) time, O(1) space
	利用快慢指針找到中間點後
	(a) fast = NULL 則右半段 = mid，
	(b) fast->next = NULL 則右半段 = mid->next，
	反轉前半段，再一一比較。

(2) O(n) time，O(n) space
	很扯的遞迴解法。

///////////////////////////////////////////////////////////////
//
// lc235. Lowest Common Ancestor of a Binary Search Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc236，但有bst這個特性，所以較簡單，可以用比大小列出case來找出祖先。
	可用遞迴，也可用iteration。

///////////////////////////////////////////////////////////////
//
// lc236. Lowest Common Ancestor of a Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用祖先特性，最先找到的點，下面就不用找。因為他或他以上才可能是祖先。
	若左子樹找到p，右子樹找到q則祖先為root。
	若左子樹先找到p，右子樹沒找到(NULL)，則祖先為p。
	若左子樹先找到q，右子樹沒找到(NULL)，則祖先為q。
	反之。
(2) 利用dfs紀錄到p的path和到q的path，然後比較兩個path的共同點。

///////////////////////////////////////////////////////////////
//
// lc237. Delete Node in a Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將當前值由下一個node的val取代，
	且當cur->next->next = NULL，cur->next = NULL，結束。

///////////////////////////////////////////////////////////////
//
// lc238. Product of Array Except Self (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當前乘積等於左邊的乘積*右邊的乘積，因此同時維持一個右邊的乘積，和左邊的乘積。
	time： O(n), space： O(1)。

///////////////////////////////////////////////////////////////
//
// lc239. Sliding Window Maximum (看)* 看第二種解法。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) priority_queue維持區間內最大值(max_heap)。
(2) O(n)，利用deque STL，
	維持一個降序陣列，此外當頭 <= i-k，pop_front,
	每當push_back時，若尾端 < nums[i]，pop_back。
	
///////////////////////////////////////////////////////////////
//
// lc240. Search a 2D Matrix II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear search (右上起點)，better。
(2) 兩次binary search

///////////////////////////////////////////////////////////////
//
// lc241. Different Ways to Add Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用divide & conquer with dp memorization。
	time complexity: 
	https://stackoverflow.com/questions/27371612/catalan-numbers-recursive-function-time-complexity
	http://people.math.sc.edu/howard/Classes/554b/catalan.pdf

///////////////////////////////////////////////////////////////
//
// lc242. Valid Anagram
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc49，lc567，利用一data structure紀錄次數，若--str[s[i]-'a'] < 0
	return false。

///////////////////////////////////////////////////////////////
//
// lc243. Shortest Word Distance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) double pointer, one pass，利用last1, last2表示兩個最後遇到word1, word2
	的index，若當前 == word1，res = min(res, i - last2)，不用絕對值
	是因為i 一定於last2。

///////////////////////////////////////////////////////////////
//
// lc244. Shortest Word Distance II
//
///////////////////////////////////////////////////////////////

Approach 1: Preprocessing: O(n^2) Compute:O(1)
Approach 2: Preprocessing: O(n) Compute:O(n)

If the compute method is getting called a lot of times, approach 1 is better. 
Let's say compute is called n times. 
approach1 would be O(n^2) + O(n)
approach2 would be O(n) + O(n)*O(n)
so if compute > n times, approach 1 is better。

approach 1: We can use a hash map to store the shortest distances for any pair of words.
			then compute would be O(1).

最佳解： method 1

(1) 先將words用hashmap存起來同一個word出現的index位置，再用double pointer
	去算出smallest distance。

///////////////////////////////////////////////////////////////
//
// lc245. Shortest Word Distance III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用double pointer，多一個條件：
	words[i] == word1 && words[i] == word2。

///////////////////////////////////////////////////////////////
//
// lc246. Strobogrammatic Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，num[i] == num[j]，num[i]一定要是0, 1, 8，若num[i] != num[j]，
	只能是 69 or 96。

///////////////////////////////////////////////////////////////
//
// lc247. Strobogrammatic Number II
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 基本dfs
(2) 先到最底(i == j or i > j)，然後拿到下一層的res處理後再繼續return。
	類似lc095。

///////////////////////////////////////////////////////////////
//
// lc248. Strobogrammatic Number III (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 因為有low，high，可以generate number from n = low.size() ~ high.size()，
	當now.size() == n，去判斷可不可以在區間內。
	優化速度：當now.size() < n-1，就不用遞迴，因為絕對不會變成now.size() == n
	而去做判斷。
(2) 對於當前size，給定left和right去填。

///////////////////////////////////////////////////////////////
//
// lc249. Group Shifted Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) map operation，字串shift後一樣，表示彼此的差距是一樣的。

///////////////////////////////////////////////////////////////
//
// lc250. Count Univalue Subtrees
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 維持最底下的leaf值，若當前和leaf不一樣，當前的comp = INT_MIN，else，
	comp = max(left_comp, right_comp)。
(2) postorder，當前和孩子比較，若不同，return false，但若比較之前postorder中
	其中一個孩子returnfalse，直接return false。

///////////////////////////////////////////////////////////////
//
// lc252. Meeting Rooms
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若start < last_end -> return false。

///////////////////////////////////////////////////////////////
//
// lc253. Meeting Rooms II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 排序start time and end time，
	若start time < end time -> ++res。
	反之 -> ++endPos。
(2) 類似lc731，若start time ++, end time --，
	計算event重複最大的數量。

///////////////////////////////////////////////////////////////
//
// lc255. Verify Preorder Sequence in Binary Search Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，利用另一個index表示stack index。
(2) O(n) space，利用降序stack，每次踢掉的當標準值，當比標準值小的，return false。

///////////////////////////////////////////////////////////////
//
// lc256. Paint House
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當前cost[i]的這個顏色 = min(cost[i-1]的其他兩個顏色) + cost[i]的這個顏色。

///////////////////////////////////////////////////////////////
//
// lc257. Binary Tree Paths
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc258. Add Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找出規律，發現所有數字相加得到的1 digit為該數字的9的餘數。

///////////////////////////////////////////////////////////////
//
// lc259. 3Sum Smaller
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc611，two pointer。

///////////////////////////////////////////////////////////////
//
// lc260. Single Number III (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要找出出現一次的兩個數字，首先將所有數字xor，剩餘的就是出現一次的數字bit。
	我們目的是拿出第一位為1的bit(由右至左算)，使用方式為diff &= (~diff+1)，
	原因是這bit可以分出兩個出現一次的數字，
	因為只出現一次，代表其中一個數字and會為0，另一個數字and為1。
	其餘數字因為都成對出現，所以xor到對應位置都會為0。

///////////////////////////////////////////////////////////////
//
// lc261. Graph Valid Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find
(2) bfs + queue

///////////////////////////////////////////////////////////////
//
// lc263. Ugly Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對num除2除3除5到不能再除，若為1則為ugly nubmer。

///////////////////////////////////////////////////////////////
//
// lc264. Ugly Number II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前的dp數字，要找到下一個比他大的，因為有2,3,5，所以對於這三個數字
	找到第一個idx使得該醜數*2大於now，這樣這個idx for 2 可以下一輪當醜樹候選人。
	3，5同理。

///////////////////////////////////////////////////////////////
//
// lc268. Missing Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 將vector的value全部相加，和本來應該要有的總和取diff極為答案。
(2) 類似lc136，和方法ㄧ也類似，差別在於用xor找出單獨的數字。
(3) 類似lc287，binary search。
	先將數列排序，若取到mid > nums[mid]，則right = mid，反之，left = mid+1。

///////////////////////////////////////////////////////////////
//
// lc270. Closest Binary Search Tree Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) preorder，利用bst特性選要走的路，類似lc669，lc938。

///////////////////////////////////////////////////////////////
//
// lc276. Paint Fence (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當前dp[i]，表示到第i位的方法數 = same[i] + diff[i]，
	same[i]是和上一位一樣，diff[i]是和上一位不一樣的方法數。
	可以想像成
	(1) ith和i-1th不一樣的方法數。
	(2) ith和i-1th一樣的方法數。
	(1) 就是dp[i-1]*(k-1)
	(2) 就是和上一位一樣，保證不能連三位一樣，所以diff[i-1] * 1，因為diff[i-1]
		表示i-1和i-2不一樣的方法數，那們再加上一個和i-1一樣的color也不會連三位一樣。

	dp[i] = same[i] + diff[i]
		  = diff[i-1] + dp[i-1] * k-1
		  = dp[i-2] * k-1 + dp[i-1] * k-1
		  = (dp[i-1] + dp[i-2]) * k-1
	可用O(1) space去做。

///////////////////////////////////////////////////////////////
//
// lc277. Find the Celebrity (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先跑一遍去找到candidate，若a knows b，則b是candidate，a不是，這樣跑一圈
	後，只會有一個candiate，其他都會被淘汰。因為若a不知道b，b不可能是candi，
	b會被跳過。初始化candi = 0，
	if knows(candi, i)則 candi = i。
	然後對於candidate，若有一a使得a不知道candi或candi知道a，return -1。

///////////////////////////////////////////////////////////////
//
// lc278. First Bad Version
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本binary search

///////////////////////////////////////////////////////////////
//
// lc279. Perfect Squares (看)* 看遞迴解法。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

用dp解
方法一為iteration，方法二為遞迴。
(1)
	(1-1) 每次跑一個迴圈決定好第i個的數量
		dp[i] = min(dp[i], dp[i-j*j]+1]), j=1; j*j<=i 
	(1-2) 核心思想為dp[i+j*j] = min(dp[i+j*j], dp[i]+1);
		  i = 0 ~ n, 
		  j = 1; i+j*j <= n;
	(2-1)
		dp[n] = min(dp[n], dp[n-i*i]+1)

///////////////////////////////////////////////////////////////
//
// lc280. Wiggle Sort
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 判斷奇偶數，決定要不要swap。

///////////////////////////////////////////////////////////////
//
// lc283. Move Zeroes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 紀錄當前最後一個非零的index，遇到非零的數字做swap。

///////////////////////////////////////////////////////////////
//
// lc285. Inorder Successor in BST (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) inorder recursion，類似lc094。
(2) stack iteration，類似lc094。
(3) 利用bst特性，找到>=p->val的第一個node，類似lc510。

///////////////////////////////////////////////////////////////
//
// lc286. Walls and Gates
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc287. Find the Duplicate Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 將index(0~n)用自己的值(1~n)做串聯，若有重複數字代表有兩個以上指到自己，如此必有環。
	例如第一個index為0，後面n個(index:1~n指到1~n)，假設每個都指到別人且不重複，
	剩下一個點必指到已經被指過的，這樣就會有環。
	可用快慢指針解。
(2) binary search: 
    n+1個洞有1~n，必有一重複。
    若沒有重複數字，每次切中間，左邊的數量應該=mid(條件設<=mid，這樣奇偶都可以cover)，
    然後一直往右推移，若到left=right=n則代表沒有重複數字。
    若>mid代表左邊比較多，right = mid，若<=mid代表右邊比較多，left = mid+1。

///////////////////////////////////////////////////////////////
//
// lc289. Game of Life (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將狀態分為四種：
	00：0變0
	01：1變0
	10：0變1
	11：1變1
	搜尋鄰居時，若周圍有1或3的值代表本來是1，累積次數。

///////////////////////////////////////////////////////////////
//
// lc290. Word Pattern
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc205，用兩個hashmap來建立雙向連接關係。
	注意極端情況如pattern.size() == "" 或 str分割後的數量 != pattern.size()
	return idx == pattern.size() ? true : false;

///////////////////////////////////////////////////////////////
//
// lc295. Find Median from Data Stream (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將左半邊和右半邊用priority queue儲存，左半大到小，右半小到大。
follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it?
利用bucket sort去解。

///////////////////////////////////////////////////////////////
//
// lc297. Serialize and Deserialize Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc449方法2。

///////////////////////////////////////////////////////////////
//
// lc298. Binary Tree Longest Consecutive Sequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，判斷自己跟parent差1，就return max(lv, rv) + 1。

///////////////////////////////////////////////////////////////
//
// lc300. Longest Increasing Subsequence (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個升序序列，利用binary search找到合適點做取代或push_back。
(2) 維持一個升序序列，將當前的index放到序列做binary search找到適合的位子取代
	若適合的位子為尾八且尾八<插入數字，則push_back進入序列。
(3) dp[i] 為最後結尾為nums[i]的升序序列長度
	if (nums[i] > nums[j])
		dp[i] = max(dp[i],dp[j]+1)，where j = 0 ~ i;

///////////////////////////////////////////////////////////////
//
// lc301. Remove Invalid Parentheses (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2，2可以在面試中先提，如果想不到1的話。

類似lc1249。

(1) 先刪除右括號在刪除左括號，對於每一次recursion，找到第一個不合法的括號後，從last_j開始
	到i，刪除一個不合法的括號然後進行recursion。
	last_j: 當前開始刪的位置，last_i，當前開始檢查的位置。
	當刪除好右括號，去跑一次新的recursion刪除左括號，若當前是合法且為刪除左括號的recursion，
	res.push_back(now)。
	The program only generates valid answers. Every path in the search generates 
	one valid answer. The whole search space is a tree with k leaves. The number 
	of nodes in the tree is roughly O(k). But this is not always true, for example 
	a degenerated tree.

	To generate one node it requires O(n) time from the string concatenation among 
	other things. So roughly O(nk). Accurately O(nm) where m is the total "number 
	of recursive calls" or "nodes in the search tree". Then you need to relate m 
	to n in the worst case.

(2) 利用bfs，對於每一層，若沒有valid就將這個now的每一個位置都刪除一次，加入queue，
	若只要有一個，其他在這一層的not valid就不用處理，因為題目要求的是找到
	刪除最小次數的valid 括號。
	
	time complexity: O(n*2^(n-1))

	level 1: 1 * (n + c(n, n-1))
	level 2: n * (n-1 + c(n-1, n-2))
	level 3: (n-1) * (n-2 + c(n-2, n-3))
		.
		.
		.
https://leetcode.com/problems/remove-invalid-parentheses/discuss/167659/Time-Complexity-Analysis-O(n*2n)

///////////////////////////////////////////////////////////////
//
// lc303. Range Sum Query - Immutable
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp[i]表示到idx i 的sum
	sum(i, j) -> return dp[j+1] - dp[i]。

///////////////////////////////////////////////////////////////
//
// lc305. Number of Islands II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union by size，紀錄每個parent的cluster數量，少的指向多的。
	對於當前index，找四周，若parent不同，--res，代表島嶼合併。

///////////////////////////////////////////////////////////////
//
// lc307. Range Sum Query - Mutable (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 使用segement tree。
	https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/
	update: O(logN)。
	sumrange: O(logN)。

///////////////////////////////////////////////////////////////
//
// lc309. Best Time to Buy and Sell Stock with Cooldown (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用狀態機(state machine)表示dp：
	S0： 不買也不賣。
	S1： 從s0來，必須通過買，正在買入狀態。
	S2： 從s1來，必須通過賣，由於賣完必須強制休息一個回合，因此在這有個S2為cool down
		                   (表示至少休息一個回合，至於在休息狀態S0要休息幾輪看DP)。
	S0(i) = max(S0(i-1), S2(i-1));
	S1(i) = max(S1(i-1), S0(i-1)-prices[i]);  
	S2(i) = S1(i-1)+prices[i];  

///////////////////////////////////////////////////////////////
//
// lc310. Minimum Height Trees (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc207的bfs拓樸排序，將degree為1的點放入que層層去除像洋蔥一樣。
	method 2寫法更簡潔，(洋蔥式bfs)。

///////////////////////////////////////////////////////////////
//
// lc311. Sparse Matrix Multiplication (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) res[i][j] = A[i][k] * B[k][j]，可以先看A[i][k] == 0，若是，res[i][j]
	都 = 0。

///////////////////////////////////////////////////////////////
//
// lc313. Super Ugly Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp iteration，類似lc264。

///////////////////////////////////////////////////////////////
//
// lc314. Binary Tree Vertical Order Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 2-1，2-2。

類似lc987。
(1) dfs，因為無法從上往下，要連row都排序，用map<int, map<int, vector<int>>>。
(2-1) bfs with queue，只用map<int, vector<int>>。 O(nlogn)
(2-2) 也可以用unordered_map，並維持maxcol & mincol。 O(n)

///////////////////////////////////////////////////////////////
//
// lc315. Count of Smaller Numbers After Self (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1389，利用divide & conquer，用idx[i]做排序，
	依照nums[idx[i]]的大小做排序，
	if (nums[idx[i]] > nums[idx[j]]) {
		表示左邊的數字比較大，左邊要加一，且右邊放入cp_idx。
		cp_idx.push_back(idx[j])
		++lower;
	} else {
		cnt[idx[i]] += lower --> 左邊比較小，將左邊到目前為止比小的都記錄起來。
		cp_idx.push_back(idx[i]);
	}

///////////////////////////////////////////////////////////////
//
// lc322. Coin Change (看) 看遞迴。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) iteration： 利用dp去解，dp[i] = min(dp[i], dp[i-coin]+1)。
(2) recurtion： 利用dp去解，dp[i] = min(dp[i], dp[i-coin]+1)。
	注意遞迴，為避免重複執行，當dp[amount] != INT_MAX，
	有些點真的找不到解法還是會維持INT_MAX，這時要手動給予-1，
	表示這個點已找完，避免這個點其實找不到，但因為還是INT_MAX，就繼續找，導致TLE。

///////////////////////////////////////////////////////////////
//
// lc323. Number of Connected Components in an Undirected Graph
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dfs，用visit[n]紀錄走過的點。
(2) union finding，類似lc1135。

///////////////////////////////////////////////////////////////
//
// lc325. Maximum Size Subarray Sum Equals k
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum，因為要找最長的subarray == k，確認sum-k存在就
	res = max(res, i-map[sum-k])，map[0] = -1。
	若sum不存在，map[sum] = i。

///////////////////////////////////////////////////////////////
//
// lc327. Count of Range Sum (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc315，divide & conquer，先做出prefix sum，然後利用divide & conquer，
	對prefix sum做排序，其中要如何計算upper & lower？
	對於每一個在左邊的index，在右邊找第一個>=lower的index： idx1和第一個>upper的index： idx2
	這樣就可以算出區間數量，res += idx2 - idx1，這些index都是符合題目要求，
	為甚麼要sort array？
	這樣找upper & lower很好找，且上一輪的idx1，idx2，可以繼續用在下一個在左邊的index。

///////////////////////////////////////////////////////////////
//
// lc328. Odd Even Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

一次看兩個：now，now->next，兩個指向odd和even，(dummy1，dummy2)。

///////////////////////////////////////////////////////////////
//
// lc331. Verify Preorder Serialization of a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 發現規律: 有數字則#數量+1
	當前 # < 0，若長度>1 -> false;
	當前 # = 0, 若當前idx != 長度-1 -> false

///////////////////////////////////////////////////////////////
//
// lc332. Reconstruct Itinerary (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

利用unordered_map<string, multiset<string>> map，
Let N be the number of tickets. Let D be the largest outgoing degree of a vertex.
TIME: insert map: O(NlogD), traverse: O(N)
SPACE: O(N)
想像一條路走到底不能再走，就push_back(那個node)，所以路線是從尾往前，
最後要reverse。
(1) iteration
(2) recursion

///////////////////////////////////////////////////////////////
//
// lc333. Largest BST Subtree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似 lc098，維持一個區間，差別是這邊用postorder。
(1) 維持一個區間，postorder對當前node檢查left child的maxv < root->val
	且right child的minv > root->val，且在這層決定minv和maxv，
	若上述條件不符合，return max(left_cnt, right_cnt)。

///////////////////////////////////////////////////////////////
//
// lc334. Increasing Triplet Subsequence (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持:
		(a) 到目前為止有序的最小
	 	(b) 到目前為止有序的第二小
	遇到數字先和最小比較，比最小的小更新最小，
	若沒有和二小的比，比第二小的小，更新第二小的。
	NOTE: 更新順序從最小到第二小的目的是要維持到目前為止有序的第二小(前面必有比他小的)
	->以便找出第三小。

///////////////////////////////////////////////////////////////
//
// lc337. House Robber III (看) 第二種方法，第一種不用(第三種已會)。
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) 維持一個dp數組來確認當前node有沒有被跑過。
(2) 對每一個node維持一個res，res[0]表示不含此node最大值，
							res[1]表示含此node最大值。
	因此跑遞迴得到左孩子和右孩子的res後，即可得到此node的res。
	res[0] = max(left[0], left[1]) + max(right[0], right[1]);
	res[1] = root->val + left[0] + right[0];
(3) 維持當前node左邊最大值和右邊最大值，以及call recursion後得到的ll，lr，rl，rr。
	對當前最大值計算為 max(root->val+ll+lr+rl+rr, l+r)。

///////////////////////////////////////////////////////////////
//
// lc338. Counting Bits (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似因式分解，當前i為i/2的1個數加上i%2的餘數。

///////////////////////////////////////////////////////////////
//
// lc339. Nested List Weight Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc340. Longest Substring with At Most K Distinct Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc992。差別這是算出現最多k次的最大長度，992是算剛好出現k次的個數。
	用sliding window。

///////////////////////////////////////////////////////////////
//
// lc341. Flatten Nested List Iterator
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) recursion在construcor建好list。
(2) stack實作在has next。

///////////////////////////////////////////////////////////////
//
// lc343. Integer Break
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp iteration： dp[i] = max(dp[i-j]*j, max((i-j)*j, l_max));
	O(n^2)。
	或： dp[i] = 3 * max(dp[i-3], i-3)。
(2) 數學解法：找規律，用3拆分，拆到4為止結束。
	O(n)。

///////////////////////////////////////////////////////////////
//
// lc344. Reverse String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從i = 0 ~ n/2-1 和對應位互換。

///////////////////////////////////////////////////////////////
//
// lc345. Reverse Vowels of a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到母音然後swap。

///////////////////////////////////////////////////////////////
//
// lc346. Moving Average from Data Stream
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) time using que。
	類似lc622。

///////////////////////////////////////////////////////////////
//
// lc347. Top K Frequent Elements (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) priority queue，以次數做排序。
(2) bucket sort，以次數作為籃子從大到小取出。

///////////////////////////////////////////////////////////////
//
// lc348. Design Tic-Tac-Toe
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用row_v[n], colv[n]，代表每一row或col的圈或叉數，圈 = 1，叉 = -1。
	對腳和斜對角特別處理，若任一值絕對值 = n，return player。

///////////////////////////////////////////////////////////////
//
// lc349. Intersection of Two Arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 用set來做。
(2) 排序後，雙指針來做。

///////////////////////////////////////////////////////////////
//
// lc350. Intersection of Two Arrays II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用map來做。
(2) 排序後，雙指針來做。

///////////////////////////////////////////////////////////////
//
// lc362. Design Hit Counter (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 用一array紀錄該slot的天數，若與當前不符，hit[slot] = 1，else
	++hit[slot]。
(2) 利用queue紀錄{time, hit}，在hit和gethit都去pop。

///////////////////////////////////////////////////////////////
//
// lc364. Nested List Weight Sum II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) top down，若當前vec[i]是integer，放入unweighted，跑完當前迴圈，
	weighted += unweighted，unweighted是累加的。
	上一輪的unweighted的總和，要必須到下一輪使用，因為depth是從底部算起，
	最上層一定是最深的，所以每一次都要加到。
	收集不是integer的element，若不是empty，跑新的迴圈。
	ex : [1, [2, [4]]]
	1 round: 1          -> unweighted
	2 round: 1 + 2      -> unweighted
	3 round: 1 + 2 + 4  -> unweighted

///////////////////////////////////////////////////////////////
//
// lc366. Find Leaves of Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder，有點像是level order traversal倒過來，由下往上做。

///////////////////////////////////////////////////////////////
//
// lc368. Largest Divisible Subset (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) space, dp
	先將數組排序(小到大)，i>j， if nums[j]%nums[i] == 0，表示j也可以整除所有i能整除的。
	-> dp[i] = max(dp[j])+1，for j = 0~i-1。
	所以維持一個陣列output[i] = j表示nums[i]整除nums[j]，則最後將此陣列的nums取出即為答案。
	-> O(n) space。

///////////////////////////////////////////////////////////////
//
// lc369. Plus One Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，two pointer，找到最後一個不是9的，表示之後都是9，
	若最後一個不是9，直接加1，不然就將最後一個不是9的加1，其後面全改成0。
(2) O(n) space，recursion。

///////////////////////////////////////////////////////////////
//
// lc373. Find K Pairs with Smallest Sums (看) min heap。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) priority queue： 方法2的優化，min heap，one time pass。
(2) priority queue： max heap。

///////////////////////////////////////////////////////////////
//
// lc374. Guess Number Higher or Lower
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用binary search。

///////////////////////////////////////////////////////////////
//
// lc375. Guess Number Higher or Lower II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) k = j+1~i-1
	利用minimax，dp[j][i] = min(k + max(dp[j][k-1],dp[k+1][i]))
(2) recursion for minimax。

///////////////////////////////////////////////////////////////
//
// lc376. Wiggle Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp solution，維持up和down代表當前為該方向的方法數。
	if nums[i] > nums[i-1] -> up = down + 1
	if nums[i] < nums[i-1] -> down = up + 1
(2) greedy，若持續該方向，就不增加res。

///////////////////////////////////////////////////////////////
//
// lc378. Kth Smallest Element in a Sorted Matrix (看)* binary search方法。
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) parition，quick select，類似lc215。
(2) priority queue。
(3) binary search：維持一個mid代表最大最小的一半，每次遍歷整個matrix，
				   做binary search。
				   做value搜索時要做到left = right。

///////////////////////////////////////////////////////////////
//
// lc380. Insert Delete GetRandom O(1) (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map紀錄有沒有在set，因為unordered_map刪除或插入都O(1)。
	取隨機則是利用vector：nums來做操作，所以map的key紀錄val，
	value紀錄在nums這vector的idx。另外刪除就是將所在的idx和尾巴swap後pop_back就好。
	***---注意刪除時交換的方法。

///////////////////////////////////////////////////////////////
//
// lc382. Linked List Random Node
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc398，用resivoir sampling。
	要不要選當前node，看當前餘數有沒有=0。

///////////////////////////////////////////////////////////////
//
// lc383. Ransom Note
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用一個vector儲存magazine的字元出現字數，再去對每個出現在ransom note
	的字元去做減去，若有<0的，return false。

///////////////////////////////////////////////////////////////
//
// lc384. Shuffle an Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc398，用resivoir sampling。
	換的長度要在當前idx內，才符合resivoir sampling的1/i。

///////////////////////////////////////////////////////////////
//
// lc386. Lexicographical Numbers (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) iteration：
	對於當前cur，
	若cur*10 <=n，則cur *= 10，
	else，cur >= n，cur /= 10
		  ++cur，加到while (cur %10 == 0)，
		  			就 cur /= 10。
(2) recursion：
	對於1~9跑遞迴，每次push進去res，且對於當前數字跑0~9遞迴，
	遞迴行事為：cur*10 + i。

///////////////////////////////////////////////////////////////
//
// lc387. First Unique Character in a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1
(1) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc389. Find the Difference (看) bit解法。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 計算s所有字母出現字數，並在t中剪掉，若<0表示為多出來的。
(2) 類似lc136，利用xor特性來找出多出來的字母。

///////////////////////////////////////////////////////////////
//
// lc392. Is Subsequence (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用雙指針來對兩個string遍歷。
follow up: pos[i][j]表示從i開始，'a'+j第一個出現的位置。
		   遍歷pos要從後往前。

///////////////////////////////////////////////////////////////
//
// lc394. Decode String (看) iteration作法
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs：
	維持一個now_str表示當前level(同個括號層級)的字串。
	遇到數字就進入遞迴，return括號內的結果字串，iterative的加入這層level的now_string。
	最後idx=s.size()或是遇到']'就ans = now_string，並且return。
(2) iteration：
	維持兩個stack，一個次數，一個外層string。
	遇到'['就進入下一層，將當前string和cnt放入stack。
	遇到']'就計算當前now_str次數並將str_stack.top拿出加入now_str並對兩個stack都pop。
	return now_str。

///////////////////////////////////////////////////////////////
//
// lc395. Longest Substring with At Least K Repeating Characters (看*) 1和3。
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) 維持一個mask，若在對應位有出現數字但不滿k次，給1，反之，給0。
	當mask = 0，表示到目前為止符合題目要求。
	跑(最大)n次迴圈，因為每次一頭開始往後找最大重複子字串。
	time: O(n^2)。
(2) 遞迴：
	先算好所有字母出現次數，跑一次迴圈，對當前idx的字母沒有達到k次，計算這之前的最大長度(從max_idx到當前去遞迴)。
	因為最後一次到邊界的沒辦法在迴圈跑，所以當前function return時跑一次以最後(idx = n)為當前位置的遞迴。
	time: O(n)
(3) 遞迴：(我喜歡)，類似binary search。
	跑一個迴圈執到第一個沒到達K次的字母。
	對左半邊跑遞迴。 -> 0 ~ idx-1。
	右半邊則是繼續去找到第一個達到k次的字母，對剩餘字串跑遞迴。 -> idx ~ n-1。
	return max(left, right)。
	time: O(n)

///////////////////////////////////////////////////////////////
//
// lc397. Integer Replacement (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 遞迴找最小，n == 1時return 0。
(2) 找規律，當前為奇數時，若不是3且第二個bit是1(n&2 == 1)，則+1，
	因為+1後會變成4的倍數，反之則-1。

///////////////////////////////////////////////////////////////
//
// lc398. Random Pick Index (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用resivoir sampling，對於當前等同於target的數量cnt，代表有1/cnt機率選取當前i。

///////////////////////////////////////////////////////////////
//
// lc399. Evaluate Division (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find
	維持一map val表示node到parent的val。
	若union(x, y)表示 找到他們兩個的parent，xp, yp
	parent[xp] = yp，val[xp] = val * val[y] / val[x]
	這樣就把xp指向yp，且xp到其parent (yp)的val也設定好了。
	做find parent時，利用path compression，計算node到parent的val總和，
	因為做了compression，所以val總和只要算一次。

(2) dfs。

///////////////////////////////////////////////////////////////
//
// lc402. Remove K Digits (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若input為升序，去掉後面k個，因此利用升序序列，當val比res.back()小，去掉
	res.back()。

///////////////////////////////////////////////////////////////
//
// lc404. Sum of Left Leaves
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要求左子葉的和，表示當前node是上一個node的左孩子外加上當前node沒有孩子，
	因為葉子不會有孩子。

///////////////////////////////////////////////////////////////
//
// lc406. Queue Reconstruction by Height (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 題目要找出一個排序是任一index前面高度大於等於自己的數量等同於自己的inputp[1](即k)，
	因此先由高到低排序，這樣就達成先排高的再排矮的，矮的調換不會影響到高的k，
	排序完，跑迴圈(0~n-1)，再利用k依照index插入即可。

///////////////////////////////////////////////////////////////
//
// lc409. Longest Palindrome
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為最大回文字數一定是全偶字母配最多一奇數個數的字母，
	因此只要將出現個數全部相加，遇到奇數就減一(代表選偶數個數)，
	迴圈結束後，若有出現至少一次奇數個數字母，就將sum再加1(代表只選一個奇數個數的字母)

///////////////////////////////////////////////////////////////
//
// lc410. Split Array Largest Sum (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) binary search，難想，left為數組中最大值，right為sum總和。
	每次取mid，若可以被分割，表示mid可以再更小，若不能被分割，表示mid太小導致分割數量太多，
	mid必須增大。
	利用mid控制分割數量，這樣right就是最佳分割數量的最小值。當可以分割表示邊界太大，
	導致mid太大，這時讓mid變小，可以在可分割的情況下使subarry sum變小(mid控制subarry sum的最大值)。
	time complexity: nlogn。
(2) dp recursion，dp[i][j]表示0~j用了i條分割線得到的minimum of largest sum。
	space：O(m*n)
	time：O(n^2*m)，
	首先recursion function會被call幾次？ -> m*n，因為要填滿每一個dp data位置，
	再來，每個recursion有跑一次n linear search，所以m*n*n。
	可improve到logn by binary search。

///////////////////////////////////////////////////////////////
//
// lc412. Fizz Buzz (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用counter計算當前是不是3或是5。

///////////////////////////////////////////////////////////////
//
// lc414. Third Maximum Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 用pointer存。
(2) 用ordered set存。

///////////////////////////////////////////////////////////////
//
// lc415. Add Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear add from right to left。

///////////////////////////////////////////////////////////////
//
// lc416. Partition Equal Subset Sum (看)* 第一種方法。
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 利用bit vector解，
	跑一個陣列迴圈，若遇到數字為n，向左移n位表示當前數字都加上n。
	然後再和本來的bit vect做 or，這目的是除了加上n的數字，也要保有本來的數字。
	結束迴圈後，找sum/2的位置是否為1即可。
(2)	利用dp解，dp[i]表示和為i可被num vector中幾項做總和相同，
	所以dp[i] is true if dp[i] || dp[i-num] (表示i-num可被拆分且num存在於num vector)
	確定每個number都只能用一次，並對於這個num找尋dp[i-num]是否存在。
	所以i要從target往num走(--j)，
	因為如果從num走，會讓所有dp都是true，進而失去dp意義(重複使用num)。
	(here we must start from 'half' downto 'num', 
	otherwise current 'num' might be multiply used. )

///////////////////////////////////////////////////////////////
//
// lc417. Pacific Atlantic Water Flow (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs with queue，做兩遍bfs，第一遍找pac，第二遍找atl，看結果兩個都有visit
	到的丟入res。

///////////////////////////////////////////////////////////////
//
// lc419. Battleships in a Board
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為只會有直線或橫線，只要確認是直線或橫線的最後一個才res++。
	(也就是算這條是battleship只有在戰艦的最後一位)。

///////////////////////////////////////////////////////////////
//
// lc424. Longest Repeating Character Replacement
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1004。
	sliding window
	維持區間內最多k個與區間內當前最大同種字母不同的數量，
	意即每次iteration動態維持當前字母出現次數的最大數量，
	且計算區間內與此自此不同的數量(i-start+1 - maxCnt)，若大於k，移動start，
	直到上述計算值 <= K。

///////////////////////////////////////////////////////////////
//
// lc426. Convert Binary Search Tree to Sorted Doubly Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) inorder traversal，利用**pointer去做。
	node->left = *last_node;
	(*last_node)->right = node;
(2) morris traversal O(1) space。

///////////////////////////////////////////////////////////////
//
// lc428. Serialize and Deserialize N-ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc449。
(1) 利用"#"作為該node的children結束tag。

///////////////////////////////////////////////////////////////
//
// lc429. N-ary Tree Level Order Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc102，lc107，可用preorder(dfs)或是bfs去做。

///////////////////////////////////////////////////////////////
//
// lc430. Flatten a Multilevel Doubly Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到孩子就將孩子的那條尾巴的node接到當前的next。
(2)	遇到孩子就將當前的next放到stack。
	若當前為NULL，把當前=stack的top。

///////////////////////////////////////////////////////////////
//
// lc431. Encode N-ary Tree to Binary Tree (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前所以children，child[0]->right = child[1]，child[1]->right = child[2]...
	node->left = child[0]。
			1
		3	2	4
	  5   6

	  		   1
	  	3
	5 	   2
	  6      4

///////////////////////////////////////////////////////////////
//
// lc435. Non-overlapping Intervals
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc452。
	對end做sort。
	若當前start < cur_end，這個interval要remove，++res。

///////////////////////////////////////////////////////////////
//
// lc437. Path Sum III (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc560，利用prefix sum搭配dfs。若當前總和val，則res += map[val-sum]。
	因為val-sum在之前出現過k次，則加上sum = val，所以res加上k次。
(2) 較直覺，兩層遞迴，第一層正常dfs，
	第二層則是對於dfs走訪的每個點往leaf做加總去計算=sum的次數。

///////////////////////////////////////////////////////////////
//
// lc438. Find All Anagrams in a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc567。
(1) 每次往右移動，若<0，滑動左邊直到 == 0，只要==0就檢查i-left+1有沒有等同
	p.size()。

///////////////////////////////////////////////////////////////
//
// lc441. Arranging Coins
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，注意overflow。

///////////////////////////////////////////////////////////////
//
// lc442. Find All Duplicates in an Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

三種方法都在確認idx: nums[i]-1 有沒有被走訪過。
(1) 負數確認
	若idx: nums[i]-1的值為負的，代表有兩個值指到他，為重複。
(2) swapping
	如果nums[i] 和 nums[nums[i]-1]不同，將這兩個做交換，且i--，
	這邊i-1原因是一定要確認當前nums[i] = nums[nums[i]-1]才能往下一位走。
	若都沒有重複，交換完應該為1~n。
(3) 2n確認
	對於指到的數字(index為nums[i]-1的val)加上n，跑完一遍看哪個數字>2n表示該index為重複的。

///////////////////////////////////////////////////////////////
//
// lc445. Add Two Numbers II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) stack operation：
	利用stack將list倒著放，(不直接reverse list)。
(2) recursion：
	先找出兩個list長度並計算差值，此差值是用來看每層遞迴的list長度有沒有對等，
	也就是l1的digit有沒有對到l2的digit。
	當差值不等於0，當前node = l1->val，若差值=0，當前node = l1->val+l2->val。
	遞迴找出下一位的值同時傳入diff-1，將這一位指向return的下一位node。
	並對下一位node：pos檢查值有沒有>0，若有，當前這位+1。
(3) reverse input list

///////////////////////////////////////////////////////////////
//
// lc448. Find All Numbers Disappeared in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc442方法一。

///////////////////////////////////////////////////////////////
//
// lc449. Serialize and Deserialize BST
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

類似lc1008。
(1) 轉string時，利用preoreder和ostringstream來做輸入，
	轉tree時，利用stack維持一個降序序列，
	(a) 若當前比top大，找到最後一個比top大的，
	(b) 比她大的->right = 當前。
		反之，top->left = 當前。
(2) 轉tree用recursion。

///////////////////////////////////////////////////////////////
//
// lc450. Delete Node in a BST (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 利用preorder(dfs)，找到root->val == key，
	若!left || !right，代表只要return不是NULL的孩子，
	若兩者都null，return null，
	若兩者都不是null，選left的最右邊，其->right = root->right，return root->left。
(2) iteration，找到點，將now->left->最右邊接到now->right，再判斷自己是
	左孩子還是右孩子，來讓p->left or p->right去接新的點。
	若now->left is null，則直接去接now->right (now->right是新的點)。

///////////////////////////////////////////////////////////////
//
// lc451. Sort Characters By Frequency
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort
(2) priority queue

///////////////////////////////////////////////////////////////
//
// lc452. Minimum Number of Arrows to Burst Balloons
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為對於不增加射箭數量，每個term的start都要在維持的min end裡面，所以我們
	可以對end做排序。

///////////////////////////////////////////////////////////////
//
// lc453. Minimum Moves to Equal Array Elements (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 題目要求的是，每次選n-1個加上1，問最少加的次數使得每個val一樣，
	換種思考，每次選n-1個加上1，這樣是一次，那就是每次選個扣掉1，也是一次，
	所以對於每一個直，算出他和minv的diff，加總即可。
	nums[0]-minv + nums[1]-minv + ... + nums[n-1]0-minv
	= sum(nums[0...n-1]) - n * minv;

///////////////////////////////////////////////////////////////
//
// lc454. 4Sum II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先用map儲存a,b的和與其a,b的index，再對c,d找和*(-1)看有沒有在map裡面，
	有得話，++res。
	time: O(n^2)。

///////////////////////////////////////////////////////////////
//
// lc455. Assign Cookies
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) double pointer，若當前s[i] >= g[j]，++j，++res。

///////////////////////////////////////////////////////////////
//
// lc456. 132 Pattern (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用降序stack，想像從後往前遍歷，當nums[i] > sk.back()，我們要讓third
	越大越好，所以一直pop_back()到nums[i] <= sk.back()。

*** follow up: 找出所有132 pattern。

///////////////////////////////////////////////////////////////
//
// lc459. Repeated Substring Pattern (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) KMP算法中的next，也就是算出到第n位，最大重複字串長度為l，
	則return n % (n-l) == 0
(2) 利用字串長度匹配，因為可以拆分，從i = n/2 ~ 1 去找出的res。
	substr(i) == substr(0, n-i)

///////////////////////////////////////////////////////////////
//
// lc461. Hamming Distance (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) n = x^y，計算1的個數，
	n &= (n-1)，表示移除最右邊的1。所以用while來看可移除幾個1即為答案。

///////////////////////////////////////////////////////////////
//
// lc463. Island Perimeter (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs，initial當前周長4，當前周圍有聯通點就-1。
(2) 4*count-2*repeat，計算總邊長再減去內部邊長*2。

///////////////////////////////////////////////////////////////
//
// lc472. Concatenated Words (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 類似lc139，lc140。利用idx紀錄當前位置以及cnt，往後比較在set內有沒有。
	若有->遞歸。
	若idx == s.size() && cnt >= 2，return true。
(2) 不用cnt，改用一個map<int,int>紀錄當前位置的次數，memorization。

///////////////////////////////////////////////////////////////
//
// lc474. Ones and Zeroes (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp[m][n] = max(dp[m][n], dp[m-zeros][n-ones]+1)
	類似lc416，lc494。

///////////////////////////////////////////////////////////////
//
// lc476. Number Complement (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每個bit取出(&1)後做xor(^1)。

///////////////////////////////////////////////////////////////
//
// lc477. Total Hamming Distance (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

對於每1bit，可以發現不同數量總和就是有多少種0和1配對，
因次將同1bit的0和1計算出來數量後相乘。

///////////////////////////////////////////////////////////////
//
// lc485. Max Consecutive Ones
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到0將cnt設為0。

///////////////////////////////////////////////////////////////
//
// lc486. Predict the Winner (看) 注意跑遞迴要用dp來避免重複計算。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 一般遞迴：
	利用兩個sum來記錄兩個玩家選取的總和，當前玩家要贏代表選完後的下一輪玩家會輸。
(2) dp recursion：
	利用dp[start][end]代表這區間內贏最多的量(不管玩家是誰)，return dp[0][n-1] >= 0。
(3) dp iteration：類似方法2，一樣去找區間內贏做多。
	從長度1去延伸到長度n
	dp[start][end] = max(nums[start]-dp[start+1][end], nums[end]-dp[start][end-1]);

///////////////////////////////////////////////////////////////
//
// lc488. Zuma Game (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) "RRWWRRBBRR", "WB" = 2
	RRWWRRBBRR -> RRWWRRBBR[W]R -> RRWWRRBB[B]RWR -> RRWWRRRWR -> RRWWWR -> RRR -> empty
	"WWBBWBBWW", "BB" = -1
	插入每個位置去試。
	dfs with memorization。

///////////////////////////////////////////////////////////////
//
// lc489. Robot Room Cleaner (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為機器人不知道面朝哪個方向，需要有個dir表示當前機器人朝的方向，也要用set
	記錄走過的路。

///////////////////////////////////////////////////////////////
//
// lc490. The Maze (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

重點： 紀錄停留點，確保停留點不會被走。
(1) 利用dfs，當可以走，就繼續走，走到下一個是邊緣或1就停，紀錄這個停留點，確保
	下次不會走。
(2) 利用bfs，和dfs一樣的解法。

///////////////////////////////////////////////////////////////
//
// lc491. Increasing Subsequences (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，類似subset重複題目：lc090，唯一差別是重複數字不一定相鄰，
	所以要用vector紀錄該層的出現情況。
	-> 因為不能排序，用set記錄這一輪走過的點，走過就跳過。
(2) iteration，類似lc090的作法，差別在於lc090的重複是連續的，這題是不連續，
	所以必須用map紀錄上一次插入的位置。

///////////////////////////////////////////////////////////////
//
// lc493. Reverse Pairs (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用divide & conquer
	類似lc315，lc327，lc1389。
	對nums[i]做排序，且對於每一輪找到第一個nums[i] > 2*nums[j]
	res += j-mid-1。

///////////////////////////////////////////////////////////////
//
// lc494. Target Sum (看)** 三種方法都看
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2, 3

建立dp，dp[i][n]為計算到i-1個idx，且和為n的方法數

(1) recursion：dp[i][n] = dp[i-1][n-nums[i-1]] + dp[i-1][n-nums[i+1]];

(2) iteration：dp[i+1][n+nums[i]] += dp[i][n];
			   dp[i+1][n-nums[i]] += dp[i][n];
			   可優化空間從O(n^2)至O(n)。
(3) 高級寫法，轉完lc416。
	ex: a+b-c=s -> a+b = c+s
	可將題目轉為當前數組with s，可不可以分成兩半。

///////////////////////////////////////////////////////////////
//
// lc496. Next Greater Element I (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc503，利用stack iteration並看用map去將有找到next的數字記錄起來，
	這樣nums1去找如果有在map裡就可以有next greater element，反之則-1。
(2) 對於nums1的每一個數字去找nums2中對應位置，以及其next greater element，
	若找不到則為-1。

///////////////////////////////////////////////////////////////
//
// lc497. Random Point in Non-overlapping Rectangles (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc528。
	做出prefix sum based on 每個方形面積。
	並算出當前的weight，point_index = weight - 1。
	x = point_index % x_side + x_start
	y = point_index / x_side + y_start
	time: O(logN)
(2) 也可以用resivoir sampling，對於每一個跑n次rect，若當前rand%sumarea < current area，
	使用這個rect。

///////////////////////////////////////////////////////////////
//
// lc498. Diagonal Traverse (看) method 2。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1)找出規律，若右上結束，先往右，不能的話再往下。
 			若左下結束，先往下，不能的話再往右。

(2) 若往右上，
		邊界：	 (1) c>=col -> c--，r+=2;
 			 	 (2) r < 0  -> r++;
 			 	 換方向。
	若往坐下，
		邊界：	 (1) r>=row -> r--，c+=2;
 			 	 (2) c < 0  -> c++;
 			 	 換方向。

follow up：一直右上對角或是一直左下對角。

///////////////////////////////////////////////////////////////
//
// lc501. Find Mode in Binary Search Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，因為是bst，利用indorder可以走訪有序排列，隨時維持到上一個node (pre)
	最大數量，若當前val!=上一個node->val，看看pre node出現次數有沒有比max_cnt多。
	注意！！！跑完遞迴要再檢查一遍，因為可能右下角node數量>=max_cnt。

///////////////////////////////////////////////////////////////
//
// lc503. Next Greater Element II (看)* 注意第二遍。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 跑兩遍，對每一個數字若大於stack的top代表是top的第一個最大。

///////////////////////////////////////////////////////////////
//
// lc505. The Maze II (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) Dijkstra, O(n^2 + nlogn)
(2) bfs with normal queue, O(n^2)
(3) dfs, O(n!)
	since every nodes may be updated after it has been visited. 
	Therefore, the DFS tree should have n children in general.

///////////////////////////////////////////////////////////////
//
// lc506. Relative Ranks (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 排序後，將其index保留，最後依照index依序給名次。

///////////////////////////////////////////////////////////////
//
// lc507. Perfect Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc204，計算因數，用 i = 2 ~ sqrt(n)去找。若nums % i == 0，
	sum += i + num/i，若完全平方數，sum += i (意即i*i = num)。

///////////////////////////////////////////////////////////////
//
// lc508. Most Frequent Subtree Sum 
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs配上unordered_map。

///////////////////////////////////////////////////////////////
//
// lc509. Fibonacci Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc91，O(1) space。

///////////////////////////////////////////////////////////////
//
// lc510. Inorder Successor in BST II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc450，lc285，利用bst特性，往right的最左，沒有的話，往parent，若
	parent->left == now，return parent。

///////////////////////////////////////////////////////////////
//
// lc513. Find Bottom Left Tree Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) bfs找上一層qsize等於0時的當前queue head的值。
(2) dfs找當前層樹高度比最大層樹大的值，因為同層最左邊的點在dfs一定第一個被找到。

///////////////////////////////////////////////////////////////
//
// lc515. Find Largest Value in Each Tree Row
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

基本走訪tree的題目。
(1) bfs
(2) dfs

///////////////////////////////////////////////////////////////
//
// lc516. Longest Palindromic Subsequence (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc647，lc005。
	space O(n^2)
	s[i] == s[j] -> dp[i][j] = dp[i+1][j-1]+2, 
	s[i] != s[j] -> dp[i][j] = max(dp[i+1][j], dp[i][j-1])。
	也可用遞迴。

///////////////////////////////////////////////////////////////
//
// lc518. Coin Change 2 (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp iteration：
	dp[i] += dp[i-coins[j]];
(2) dfs recursion：
	因為沒有min，max的比較，不能用一般的dp recursion，這邊使用dfs，
	盡可能用完一個硬幣再往下一個硬幣做使用，並且儲存目前amount和使用到的硬幣作為
	記憶，避免重複運算。

///////////////////////////////////////////////////////////////
//
// lc523. Continuous Subarray Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

prefix sum。
類似lc560，lc713，lc974。
(1) 利用dp，因為要求至少長度為2，所以紀錄相同餘數第一次和當前i，
	if (i-map[rem] > 1) return true。
	注意：餘數0的initial index為-1。

///////////////////////////////////////////////////////////////
//
// lc525. Contiguous Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum。
	因為要計算最大區間同樣0，1數量，可將0作為-1，做累加，若當前和之前遇過，
	代表這區間0，1數量一樣。

///////////////////////////////////////////////////////////////
//
// lc528. Random Pick with Weight (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，先用prefix sum將每個weight加總，再random generate
	一個index，用binary search找到其對應的index for sum。

///////////////////////////////////////////////////////////////
//
// lc529. Minesweeper
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) dfs
(2) bfs

///////////////////////////////////////////////////////////////
//
// lc530. Minimum Absolute Difference in BST
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) inorder找相連兩個node的差值。
(2) preorder，維持一個minv和maxv區間，類似lc098。

///////////////////////////////////////////////////////////////
//
// lc531. Lonely Pixel I
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 對於當前有'B'，往該row和col找，若有，標示那一row or col已有，之後再經過
	那row or col，直接跳過。
(2) 先計算整個matrix每個row和col有多少'B'，再遍歷一次，若當前是'B'，且該row和
	col都是1(只有這個'B')。

///////////////////////////////////////////////////////////////
//
// lc532. K-diff Pairs in an Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use map，因為同樣的pair只能處理一次，所以第一次遇到num[i]，檢查num[i]+k和num[i]-k
	有沒有存過。
	若k == 0，只有在map[nums[i]] == 1時++res。
(2) 先跑一遍計算個數，再遍歷map，找m.first+k存在或!k且m.second > 1，++res。

///////////////////////////////////////////////////////////////
//
// lc535. Encode and Decode TinyURL (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 看下列解釋

https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/100268/Two-solutions-and-thoughts

///////////////////////////////////////////////////////////////
//
// lc536. Construct Binary Tree from String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs，對於左孩子或右孩子要不要跑recursion，看當前s[idx] == '('。
	接完要++idx，跳過')'。

///////////////////////////////////////////////////////////////
//
// lc537. Complex Number Multiplication
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本複數運算。

///////////////////////////////////////////////////////////////
//
// lc538. Convert BST to Greater Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

基本inverse inorder。
(1) recursion
(2) stack iteration

///////////////////////////////////////////////////////////////
//
// lc539. Minimum Time Difference
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(nlogn)，做排序，前後比較。
(2) O(n)，總數量1440，可填進去做one pass check，bucket sort。

///////////////////////////////////////////////////////////////
//
// lc540. Single Element in a Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，找出左邊還是右邊個數為奇數，往奇數的方向找。

///////////////////////////////////////////////////////////////
//
// lc541. Reverse String II (看) 這種要細心。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每2k位中的前k位，reverse，若不及k位，reverse 從i往後s.size()-i位。

///////////////////////////////////////////////////////////////
//
// lc542. 01 Matrix (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) double pass，第一遍檢查左上的最小值與自己相比，第二遍檢查右下的最小值與自己相比。
	第一遍碰到非零的要比較，第二遍碰到非0或1的要比較。 
(2) bfs：對0的點全部加入queue，在queue中檢查鄰近有1(且值比當前+1還要來得大)的加入queue，
		 且改為0，如洋蔥式解法。
(3) dfs：對有1(有1代表旁邊是0，對原本為1且旁邊都是1的改為INT_MAX)的丟入dfs，
		 在鄰近中值比當前+1來得大的繼續dfs。

///////////////////////////////////////////////////////////////
//
// lc543. Diameter of Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder
	算出一棵樹最長的路徑，其實也就是對於任一node，找出其左右子樹深度和的最大。

///////////////////////////////////////////////////////////////
//
// lc545. Boundary of Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，將tree分成兩部分，維持兩變數表示當前是left boundary或right boundary。
	以左邊為例，左邊不能走時要往右走，
	left_bound = left_bound & !root->left
	若可以往左走，
	left_bound = left_bound & root->left
	右邊一樣。

///////////////////////////////////////////////////////////////
//
// lc547. Friend Circles
//
///////////////////////////////////////////////////////////////

最佳解： method 1

為避免重複查找，紀錄查找過的人 (visit[i])。
(1) dfs。
(2) bfs。

///////////////////////////////////////////////////////////////
//
// lc549. Binary Tree Longest Consecutive Sequence II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc298。
(1) postorder，分case去討論，維持一個diff，表示current node和child node的
	difference。

///////////////////////////////////////////////////////////////
//
// lc557. Reverse Words in a String III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) reverse string when facing space

///////////////////////////////////////////////////////////////
//
// lc559. Maximum Depth of N-ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc104，lc111。
(1) 利用postorder來算出深度。

///////////////////////////////////////////////////////////////
//
// lc560. Subarray Sum Equals K (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum解法，記錄當前sum出現次數，
	若當前sum-k之前有出現過，代表在idx以前某一處之和道當前idx差距為k，
	將這些和到idx累積的sum差距k的次數加入res。
(2) 一般O(n^2)解法，類似lc300的dp。(方法三)

///////////////////////////////////////////////////////////////
//
// lc561. Array Partition I (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) Counting sort，維持一個變數，決定當前的數字要不要加入。
(2) 因為兩兩一組，若都把大的和小的分一組，這樣一定會比小小一組，大大一組來的小，
	因此先排序，每兩個取第一個加在res極為所求。

///////////////////////////////////////////////////////////////
//
// lc563. Binary Tree Tilt
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，postorder，從底層開始隨時記錄到目前為止(包含自己)所有的和，
	和res(tilt)。

///////////////////////////////////////////////////////////////
//
// lc565. Array Nesting
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遍歷一次，每次走循環，紀錄最大長度。
	***空間優化：對於使用過的應該再它原來的位置，
	所以，
	while (i != nums[i])
		swap(nums[i], nums[nums[i]]);

///////////////////////////////////////////////////////////////
//
// lc566. Reshape the Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n*m)。

///////////////////////////////////////////////////////////////
//
// lc567. Permutation in String (看)* 看方法二。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc438。

兩個都用slding window，但方法2只要一個hash table。
(1) 計算出現次數每次滑動一格計算tmp有沒有等於res。
(2) 向右滑動直到==0比較right-left+1 == n，return true，
	若<0，left向右移動直到==0，此目的是恢復那個-1的字母，也代表被中斷，從
	中斷的字母向右一個為新的left邊界。

///////////////////////////////////////////////////////////////
//
// lc572. Subtree of Another Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若當前node值一樣，直接比較兩棵樹是否相同。
	若不一樣，比較s->left和t，以及s->right和t
(2) 類似lc652。

///////////////////////////////////////////////////////////////
//
// lc575. Distribute Candies (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找出kind種類，若 > 一半糖果數量，則return 一半糖果數量，否則return kind數量。
	return 一半糖果數量是因為最多sister只能拿一半的糖果，就算kind數量多於一半糖果數量。

///////////////////////////////////////////////////////////////
//
// lc581. Shortest Unsorted Continuous Subarray (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 3

(1) 對於每個非升序的node，找到其該插入的位置並記錄start，則res = i-start+1。
	這res會隨著每個非昇序的node update一次，且start要選插入中最小的位置。
(2) 先創一個tmp vector並將他排序，這樣便一一對照nums來找到第一個不等的
	和最後一個不等的index。
(3) ！！！最好解法，跑兩遍，一遍找最大值，且確認最大值有沒有大於nums[i]，
	若沒有代表右邊界，最小值反之。

///////////////////////////////////////////////////////////////
//
// lc582. Kill Process
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

先建立data structure，unordered_map<int, vector<int>> child

(1) dfs recursion to add child
(2) use queue, bfs

///////////////////////////////////////////////////////////////
//
// lc583. Delete Operation for Two Strings (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1143，O(n) space。

///////////////////////////////////////////////////////////////
//
// lc589. N-ary Tree Preorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc114，利用stack iteration。

///////////////////////////////////////////////////////////////
//
// lc590. N-ary Tree Postorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 2, 3

(1) recursive solution
(2) iterative solution using stack (same as lc145)
(3) 後敘可用前敘的結果顛倒，
	但要注意的是放入stack要從左到右放(前敘放入stack是從右到左放)。

///////////////////////////////////////////////////////////////
//
// lc594. Longest Harmonious Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 使用map，對於map中的數字若存在+1，計算兩著的val和
(2) 先排序，利用sliding window去維持一個差距1的區間。

///////////////////////////////////////////////////////////////
//
// lc598. Range Addition II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每次operation找出最小值，return minr*minc。

///////////////////////////////////////////////////////////////
//
// lc599. Minimum Index Sum of Two Lists
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map，將list1的插入map，在跑list2時，只看list2[i]在map出現過，計算其
	index總合後，以最小的index和的list2[i]加入res。

///////////////////////////////////////////////////////////////
//
// lc605. Can Place Flowers
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前和左邊和右邊是空的，n--，當前更新為1。
	n = 0 直接return true。

///////////////////////////////////////////////////////////////
//
// lc606. Construct String from Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若左孩子空但右孩子非空，需要加()在root後面。

///////////////////////////////////////////////////////////////
//
// lc611. Valid Triangle Number (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n^2logn)
	先排序，因為完成三角形是任兩邊大於三邊，其實可以用小技巧：最短兩遍大於第三邊就代表是三角形。
	所以決定好兩邊以後第三邊可用binary search。
(2) O(n^2)
	從後面遍歷，每次跑一個迴圈固定符合題目的區間：
	while (left < right)
		if (nums[left] + nums[right] > nums[i])
		表示left~right-1都是邊長nums[right]和nums[i]的候選人。

///////////////////////////////////////////////////////////////
//
// lc617. Merge Two Binary Trees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，注意當遇到t2 = NULL, return t1，反之。

///////////////////////////////////////////////////////////////
//
// lc621. Task Scheduler
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為目標是計算要填多少個idle，對於每個同樣task要隔n個slot，先找出出現最多次(max_len)的字母和
	有多少個這樣的字母(max_cnt)，對於每個pair(長度：n+1)，數量：max_len-1，
	則每個pair還可填空n-(max_cnt-1)->employment_slot
	目前用了(max_len) * max_cnt，所以avalible_slot為len(tasks) - (max_len) * max_cnt)。

	idle 為 max(0, employment_slot - avalible_slot)，若右項為負表示填完所有pair，
	還有剩的字母，代表用原長度就好了。
	return len(tasks) + idle。

///////////////////////////////////////////////////////////////
//
// lc622. Design Circular Queue
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc641。

(1) 用length當作判斷標準。
(2) 用一boolean tag和頭尾index當作判斷標準，比較難想。

///////////////////////////////////////////////////////////////
//
// lc623. Add One Row to Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion
(2) bfs iteration

///////////////////////////////////////////////////////////////
//
// lc624. Maximum Distance in Arrays (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要選的minv和maxv去算的距離不能同一個，維持minv和maxv，遇到新的arrays[i]，
	先去和arrays[i]的頭尾計算最大值，再去更新minv和maxv，這樣計算最大值
	就不會用到同一個arrays[i]的值。

///////////////////////////////////////////////////////////////
//
// lc628. Maximum Product of Three Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(nlogn)，先排序，找出任三數最大只有兩種組合，兩負一正或三正，兩負的最小
	可取排序後的前兩個，三正最大就取最後三個。
(2) O(n)，找到最大三個和最小兩個。

///////////////////////////////////////////////////////////////
//
// lc636. Exclusive Time of Functions (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用stack，若stack不為空，將res[sk.top()] += time - last_time，
	last_time為上一次log的時間
	遇到start，把func id push到stack，
	遇到end，將res[sk.top()]++，且last_time++，因為end time + 1，
	last_time也要跟著更新而加一。

///////////////////////////////////////////////////////////////
//
// lc637. Average of Levels in Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 基本dfs。
(2) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc638. Shopping Offers (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持當前needs * prices，當作最大需要金額，對於當前needs，若存在一個
	special使得needs各項 >= 0，就算出remain放入dfs，
	比較 money = min(money, special_price + dfs())。

///////////////////////////////////////////////////////////////
//
// lc641. Design Circular Deque (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc622。

(1) 用len去判斷，注意edge case，也就是len == 0時做enque或len == 1時做
	deque，這兩個edge case，start或end指針不移動。
(2) 用start和end去想，不用考慮edge case。

///////////////////////////////////////////////////////////////
//
// lc643. Maximum Average Subarray I
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於前k位，累加，對於之後的位數 sum += num[i]，sum == nums[i-k]。

///////////////////////////////////////////////////////////////
//
// lc645. Set Mismatch (看) 第二種解法。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 利用總合來算出少哪一個數字。
(2) 類似lc442，找出重複項就是將那個nums[abs(nums[i])-1]是不是負的，
	若是代表之前就被指過一次。找沒出現過的就是指過去為正的代表沒被指過，意即沒有出現。

///////////////////////////////////////////////////////////////
//
// lc646. Maximum Length of Pair Chain (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 先排序，再來進行一次遍歷，
	對於當前尾端比min小的話min = 當前尾端。 這是因為一直維持尾端最小才能找出最常鍊子。
	若當前頭比min大，min = 當前尾端，且len++。
(2) 也可對尾端進行排序。

///////////////////////////////////////////////////////////////
//
// lc647. Palindromic Substrings
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 類似lc005。
(2) dp： dp[i][j] = 1 if (j-i<2) || dp[i+1][j-1] == 1

///////////////////////////////////////////////////////////////
//
// lc648. Replace Words (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 字串處理，dict排序後，將同樣字母頭的放到對應為中check[26],
	再將sentence以空白分開，每個去跑對應的check，因為dict有排序過，第一個
	碰到的就取代sentence中的單字。
(2) 利用prefix tree，先將dict加入tree，再對sentence中每個單字去找有沒有遇到prefix。	

///////////////////////////////////////////////////////////////
//
// lc650. 2 Keys Keyboard (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dp iteration，dp[i]為長度i的次數。
	對於這種題目，需要舉例來找規律，對於n，其最大次數為n，但其實n可以被整除n的長度所
	複製貼上，所以dp[n] = dp[i] + n/i。
	n/i表示用n長度需要做的次數，通常為複製一次和貼上次數。
	ex: dp[6] = dp[3]+6/3，也就是已有長度3的次數，複製一次長度3再貼上一次，
	所以操作3次。

(2) 利用greedy，盡可能複製大的長度，這樣貼的就比較小 -> return n/i + minSteps(i);
	所以，n/i越小越好，minsteps(i)想像成複製程度，n/i想像成貼的次數。

*** Note: 可修改為recursion。

///////////////////////////////////////////////////////////////
//
// lc652. Find Duplicate Subtrees (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 使用postorder，將得到的當前tree用 f表示，並用map紀錄有沒有出現過。
	丟到res只在目前出現一次，超過一次都不丟，目的是重複substree只丟一次避免重複丟。

///////////////////////////////////////////////////////////////
//
// lc653. Two Sum IV - Input is a BST
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 可用set，來判斷當前root->val 有沒有在set中，
	set中數字都是之前k-root->val的候選人，inorder。
(2) 利用inorder，做出vector，再利用基本2sum來找出答案。

///////////////////////////////////////////////////////////////
//
// lc654. Maximum Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) ***難想：
	維持一個降序陣列。
	當陣列空的，push當前值
	當陣列不為空：
		遇到當前的數字若比vector中最後一個小，vector最後一個->right = 當前。
		跑回圈從陣列後面找，直到最後一個比當前小的(這中間都pop，包含這最後一個比當前小的)，
		當前->left=最後一個。且將當前push到陣列裡，陣列最後一個->right = 當前。
(2) 遞迴遍歷數列找最大值當root建樹。

///////////////////////////////////////////////////////////////
//
// lc655. Print Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先算出高度，然後跑一遍preorder，維持左右邊界，mid = (l + r ) / 2
	res[h][mid] = val。

///////////////////////////////////////////////////////////////
//
// lc657. Robot Return to Origin
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似valid paratheness。

///////////////////////////////////////////////////////////////
//
// lc658. Find K Closest Elements (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) binary search找到第一個大於x的數字，左右一起搜尋。
(2) 高級寫法：binary search
	每次維持一個區間，x[mid] ~ x[mid+k]
	若右邊界靠近x，left = mid+1;
	若左邊界靠近x，right = mid;
	若左右邊界和x相同，right = mid;

///////////////////////////////////////////////////////////////
//
// lc659. Split Array into Consecutive Subsequences (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(1) space
	維持p1, p2, p3, c1, c2, c3，p表示以上一個數字(不等同現在的)結尾的長度為1
	or 2 or 3的個數，分三個case，
	(a) nums[i-1] == nums[i]
		表示可以將p_x 接到當前的c_x+1，x從小的接。
	(b) nums[i-1] + 1 == nums[i]
		表示當前c_x可以變長，在此確認p1和p2必須 == 0，否則return false
		因為c這時要變成p，若p1或p2還有值，表示儘管c == p+1，且新增c讓p減少，但還是
		有p1和p2沒有都是0，意即c不夠讓p1和p2都是0。
	(c) nums[i-1]+1 < nums[i]
		重置c1 = 0，其餘都=0，在此前要確認c1和c2都要等於0，否則return false。
(2) O(n) space
	two pass
	維持last[i]表示以i結尾的個數。
	優先看前面有沒有，ex: 1,2,3,4,5,6,7
	若先往後看，7沒辦法配對。
	(a) 若當前可以加入last[i-1]，last[i-1]--，last[i]++。
	(b) 若不行，則以現在開始往右兩個，三為一組當sequence，
		cnt[i+1]--，cnt[i+2]--，但若這兩個沒有>0，則return false，因為沒辦法
		組成3 sequence。

///////////////////////////////////////////////////////////////
//
// lc661. Image Smoother (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc289。
	因為8位(0-255)，可以開16bit，左8bit儲存結束value，右8bit儲存本來的value。
	取周圍的值可以用 M[i][j] & 0xFF。

///////////////////////////////////////////////////////////////
//
// lc662. Maximum Width of Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若用dfs，會overflow，對於每一層都減掉最左邊node的值，這樣才不會overflow。

///////////////////////////////////////////////////////////////
//
// lc663. Equal Tree Partition (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1339。
	利用set將出現過的sum都紀錄，找到sum/2在set有出現且sum % 2 == 0，
	return true。

///////////////////////////////////////////////////////////////
//
// lc665. Non-decreasing Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) check last, nums[i], nums[i+1], next
	if last > nums[i+1] && nums[i] > next
		return false。

///////////////////////////////////////////////////////////////
//
// lc666. Path Sum IV (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) top down，若val[parent] > 0, res -= val[parent]，且val[parent] *= -1，
	避免重複扣除在res。
	將parent valeu加到當前的val[node]，
	res += val[node]。

///////////////////////////////////////////////////////////////
//
// lc669. Trim a Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc938。
(1) 對於當前node先移動的區間內，再來利用dfs對於左孩子和右孩子重複上述的動作。

///////////////////////////////////////////////////////////////
//
// lc671. Second Minimum Node In a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用postorder，當發現當前val != root val，直接return，因為沒必要
	往下走，這個val是從其往下走的subtree中最小的。

///////////////////////////////////////////////////////////////
//
// lc673. Number of Longest Increasing Subsequence (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) nlogn hard
	開一個dp裡面每個洞儲存以idx為長度，結尾為val的vector： (val, cnt)
	並且越晚插入的要累加最後一個val的cnt和自己當前的cnt(當前的cnt由上一個洞計算而來)
	資料結構：dp<vector<pair<int,int>>>。
	上一個洞也是用bs找，找到適合的點，其cnt(left-1)要從該欄位的最後一個cnt扣掉。

(2) dp，利用額外一個陣列len[i]來儲存當前idx i的最長子字串個數，
	若dp[i] < dp[j]+1表示len[i] = len[j]
	若dp[i] == dp[j]+1表示有相同最大子字串長度-> len[i] = len[i] + len[j]。
	類似lc 300 dp解。

///////////////////////////////////////////////////////////////
//
// lc674. Longest Continuous Increasing Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遍歷一遍nums，若當前小於等於上一個，就將當前長度和最大長度做比較。

///////////////////////////////////////////////////////////////
//
// lc680. Valid Palindrome II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為比錯一次就false，當前若遇到比不對的，直接比較去掉最右邊是否回文和去掉最左邊
	是否回文。

///////////////////////////////////////////////////////////////
//
// lc684. Redundant Connection (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) union find
(2) bfs，類似lc207，lc310。

///////////////////////////////////////////////////////////////
//
// lc685. Redundant Connection II (看)***
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find，分三種case，
	a. 沒有一個點被兩個點指到，找到ap == bp，return 那條邊。
	b. 有一個點被兩個點指到，第二條邊的destination設置成0，目的是不做union find。
		因為這條邊是晚加入的，若沒有環，就移除重複被指到的第二條邊。
		b-1 若找到ap == bp，return 第一條邊，因為第二條邊沒被考慮到的情況下，
			還可以成環，第一條鞭必須移除。
		b-2 若都沒找到，表示沒有環，return 第二條邊，也就是晚加入的

	(1) 有環的情況下，移除第一條邊，因為有兩條邊被同時指到，必須移除第一條
		沒有的話移除造成環的邊。
	(2) 沒有環的情況下，移除第二條邊。
	第二條邊不做union find的原因是，若做的話，那他就會被考慮進去(在發現環的邊前)，到時發現環時，
	移除的邊是第一條邊，但這條邊可能不是造成還的
	ex: x - 1 - > x <- 2 ----\
				  |           x
				  3 -> x ->4 /

///////////////////////////////////////////////////////////////
//
// lc687. Longest Univalue Path
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder

///////////////////////////////////////////////////////////////
//
// lc690. Employee Importance
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) simple bfs
(2) simple dfs

///////////////////////////////////////////////////////////////
//
// lc692. Top K Frequent Words 
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

類似lc347
(1) priority queue
(2) bucket sort

///////////////////////////////////////////////////////////////
//
// lc694. Number of Distinct Islands
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，紀錄方向，注意當前結束遞迴要加tag，不然分不出來，
	ex: 1 1  and  1 1 。
		  1       1

///////////////////////////////////////////////////////////////
//
// lc695. Max Area of Island
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) dfs。
(2) bfs。

///////////////////////////////////////////////////////////////
//
// lc697. Degree of an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用兩個unoredered_map，一個找出nums[i]的起始位置，另一個找出nums[i]出現
	次數。

///////////////////////////////////////////////////////////////
//
// lc698. Partition to K Equal Sum Subsets
//
///////////////////////////////////////////////////////////////

最佳解： method 1

///////////////////////////////////////////////////////////////
//
// lc700. Search in a Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 基本dfs。
(2) iteration using bst。

///////////////////////////////////////////////////////////////
//
// lc701. Insert into a Binary Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc703. Kth Largest Element in a Stream
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) priority queue

///////////////////////////////////////////////////////////////
//
// lc704. Binary Search
//
///////////////////////////////////////////////////////////////

最佳解： method 1

基本binary search，注意跳出迴圈要檢查nums[left]是否等於target。

///////////////////////////////////////////////////////////////
//
// lc705. Design HashSet (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2, 3

(1) 用double array
(2) array of list: 利用list來處理collision的問題。hash(int)達到random
	access O(1)。
(3) bst node
	實作insert, remove，注意remove 若當前left和right都不為null，找到比當前大的
	最小node當新的root。 類似lc450。

///////////////////////////////////////////////////////////////
//
// lc706. Design HashMap (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 用double array
(2) array of list: 利用list來處理collision的問題。hash(int)達到random
	access O(1)。

///////////////////////////////////////////////////////////////
//
// lc708. Insert into a Sorted Circular Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到interval
	(a) now_v <= val <= next_v
	(b) now_v > next_v && (now_v <= val || val <= next_v)
	(c) now->next == head

///////////////////////////////////////////////////////////////
//
// lc709. To Lower Case
//
///////////////////////////////////////////////////////////////

最佳解： method 1

將大寫改成小寫，利用diff = 'A'-'a'。

///////////////////////////////////////////////////////////////
//
// lc713. Subarray Product Less Than K (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc209。
(1) 注意區間subarray計算為right-left+1。

///////////////////////////////////////////////////////////////
//
// lc714. Best Time to Buy and Sell Stock with Transaction Fee 
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc122。

///////////////////////////////////////////////////////////////
//
// lc717. 1-bit and 2-bit Characters (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 從前面走。
(2) 從後面往回看，因為input合法，往前找1的個數，直到遇到0，若1為偶數，表示最後
	一個必為0，反之，奇數表示最後兩個bit為"10"。

///////////////////////////////////////////////////////////////
//
// lc718. Maximum Length of Repeated Subarray (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 利用dp iteration：tmp[j] = max(tmp[j], dp[j-1]);
	要用一個tmp dp的原因是這個dp數組不是升序或降序更新，為了避免這次更新到的數值
	影響到還未更新的數值，需要用一tmp dp來暫存。
	follow up : 這題其實就是longest commom subsequence。
	類似lc1143。
(2) O(n) space dp
	if (s[i] != s[j])
		dp[j] = 0;

///////////////////////////////////////////////////////////////
//
// lc721. Accounts Merge (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs+queue，找出每個擁有這個信箱的使用者加到queue中。
	time: n + aloga, a is total mails
(2) union find，類似lc1135。

///////////////////////////////////////////////////////////////
//
// lc723. Candy Crush (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找連續三個以上的candy，可以對於當前的往右和往下找連續三個以上，將所有
	一樣的標記負數。
	在drop candy時，對於每一column，從row-1往前將每個board[i][j] > 0的
	放到最尾端，用一個計數器來達成，最後計數器的位置到index 0全部標記成0。
	這樣就將crush candy都消除且將可以drop的candy全部drop。

///////////////////////////////////////////////////////////////
//
// lc724. Find Pivot Index
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於index左右兩邊和一樣，可以先算一遍sum，然後對於左邊保持一個變數cursum，
	若sum-nums[i] = cursum*2，return i。

///////////////////////////////////////////////////////////////
//
// lc725. Split Linked List in Parts (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先算出list長度，再對k求商數和餘樹，餘數即為從首相算要多加一個的欄位。

///////////////////////////////////////////////////////////////
//
// lc727. Minimum Window Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc076。

///////////////////////////////////////////////////////////////
//
// lc729. My Calendar I (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) map，upper_bound找到前後兩個event，
	若next->start < end || prev->end > start
	return false;
(2) O(n^2) search
	兩者相交表示
	max(start1, start2) < min(end1, end2)

///////////////////////////////////////////////////////////////
//
// lc731. My Calendar II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 若start time ++, end time --，
	計算event重複最大的數量。
	O(n*(n+logn))
(2) 維持兩個vector，一個one，一個two，two表示區間都是兩個event佔據。
	O(n^2)

///////////////////////////////////////////////////////////////
//
// lc733. Flood Fill
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若當前顏色和newColor相同，直接return。反之做dfs，將四周的tagColor的
	顏色改成newColor。
	類似lc1034。

///////////////////////////////////////////////////////////////
//
// lc734. Sentence Similarity
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) union find，但不能transition，(a,b) (b,c)， a和c沒關係。
	用unordered_map<string, unordered_set<string>> map紀錄每個和這個
	words相關的所有similar words。
(2) 利用set，紀錄pairs[0] + " " pairs[1] 和 pairs[1] + " " + pairs[0]

///////////////////////////////////////////////////////////////
//
// lc737. Sentence Similarity
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find，類似lc1135。

///////////////////////////////////////////////////////////////
//
// lc738. Monotone Increasing Digits (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要monotone increasing digits，從尾巴往前走。
	若nums[idx-1] > nums[i]，為了找到單調最大，--nums[idx-1]，
	且flush = i。
	flush是用來設置成從flush往後全部變成9。

///////////////////////////////////////////////////////////////
//
// lc739. Daily Temperatures
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc907，lc977，lc1019，lc1130，
利用stack來維持降序陣列。

///////////////////////////////////////////////////////////////
//
// lc740. Delete and Earn (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc198，dp[i] = max(dp[i-1], dp[i-2]+nums[i]);
	因為只能隔著拿，所以當前要當作錢的話，上一個就不能拿，要看上上個所賺的錢加上當前的錢。

///////////////////////////////////////////////////////////////
//
// lc742. Closest Leaf in a Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用dfs來build graph，用bfs來算出先到leaf的點。
	root的parent為0，且visit[0] = 1，防止visit到這個點(防止把這個點當成leaf)。

///////////////////////////////////////////////////////////////
//
// lc743. Network Delay Time (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2，3

(1) 利用dijkstra，對於加過的邊，都不要再加，隨時更新node的val。
(2) 對於有值的邊，只要val[i] > val[now]+res[now][i]，就更新並push i。
	不能把邊刪掉，因為不是用dijkstra。
	ex:
	[0, 1] = 1
	[1, 2] = 2
	[2, 4] = 2
	[0, 3] = 3
	[3, 4] = 4
	[4, 5] = 2
	[4, 5] 不能被刪掉，不然4被更新最小值後，無法更新node 5。
(3) Bellman Ford，最多跑n個點，想像成最多一輪更新一個點的最小值，每一輪，
	發現val[now] != max且val[i] > val[now]+res[now][i]，就更新val[i]

///////////////////////////////////////////////////////////////
//
// lc746. Min Cost Climbing Stairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space, dp
	n_1表示上一位方法數，n_2表示上上一位
	cur = min(n_1, n_2) + cost[i]
	n_2 = n_1
	n_1 = cur
(2) now = min(i_1+cost[i-1], i_2+cost[i-2]);
    i_2 = i_1;
    i_1 = now;

///////////////////////////////////////////////////////////////
//
// lc747. Largest Number At Least Twice of Others
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) Just maintain largest number index and second largest number index.

///////////////////////////////////////////////////////////////
//
// lc752. Open the Lock (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc126。
(1) bfs，O(k^d)。
(2) bidirectional bfs，O(k^(d/2))

///////////////////////////////////////////////////////////////
//
// lc754. Reach a Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為-10 和 10 次數都一樣，所以先將input轉成正的，再來累加到超過target。
	若sum和target差距為偶數d，表示其中一項d/2可以轉相反號(cnt)，若差奇數，判斷當前now，
	若now為奇數，則加上now(cnt+1)，若now為偶數，則加上now和now+1(cnt+2)

///////////////////////////////////////////////////////////////
//
// lc756. Pyramid Transition Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前level，跑到底，若到底，往下個level，較快，因為不用使用vector<string>
	去算出在單一level所有可能性的string。
(2) time complexity: O(a^n)，
	對於每個level算出所有可能性的string。	

///////////////////////////////////////////////////////////////
//
// lc763. Partition Labels
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) two pass，
	第一個pass找到每個字母的最後出現indx，
	第二個pass利用每個字母最後出現的indx找到最長重複字串。
	->維持start,end，若當前字母的index > end，則計算end-start+1。

///////////////////////////////////////////////////////////////
//
// lc765. Couples Holding Hands (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用union find，兩兩一組，parent[i] = parent[i+1] = i。
	若當前兩兩部為一組，merge them，cnt++。
	return cnt。
	想像在同一個group的可以任意換位子，都還是合法。

///////////////////////////////////////////////////////////////
//
// lc766. Toeplitz Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 比較matrix[i][j] == matrix[i+1][j+1]。

///////////////////////////////////////////////////////////////
//
// lc767. Reorganize String (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 類似lc621，將最大的字母算出來，先填入，接下來依字母由a~z依序填入就好。

///////////////////////////////////////////////////////////////
//
// lc768. Max Chunks To Make Sorted II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

(1) 若當前可分成兩塊表示left_max[i] <= right_min[i+1]，因為從0~i的最大值比
	i+1~n-1的最小值來的要小，表示這邊可切割。分成兩塊去sort。
(2) 利用stack維持一個升序序列，若有比top小，就要判斷他可以插入到哪，也就是說
	從top到他插入的位置都是一塊，中間的stack成員都要刪除，return sk.size()
	表示可分成幾塊，其中的數值是個區間的最大值。

///////////////////////////////////////////////////////////////
//
// lc769. Max Chunks To Make Sorted
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持當前最大值maxv，當i > maxv或i == arr.size()-1，++res。
	類似lc763。

///////////////////////////////////////////////////////////////
//
// lc776. Split BST (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc450。

(1) 維持兩個，一個比v要小或等於，一個比v大。
	若當前root->val <= v，則往root->right走，且return的兩個tree，
	root->right = res_return[0]，res_return[0] = root。
	
	若當前root->val > v，則往root->left走，且return的兩個tree，
	root->left = res_return[1]，res_return[1] = root。

///////////////////////////////////////////////////////////////
//
// lc783. Minimum Distance Between BST Nodes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本inorder traversal。

///////////////////////////////////////////////////////////////
//
// lc784. Letter Case Permutation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

！！！注意大小寫轉換可以用c^32，因為英文字母大小寫差了32。
(1) 遞迴。
(2) 類似lc078的iteration，起始vector為{""}。

///////////////////////////////////////////////////////////////
//
// lc785. Is Graph Bipartite?
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，若自己的next和自己同一個group，return false。

///////////////////////////////////////////////////////////////
//
// lc792. Number of Matching Subsequences (看)方法2。
//
///////////////////////////////////////////////////////////////

最佳解： method 2

類似lc392。
(1) 用double pointer和hashmap去做。
(2) 用一vector of pair,size 26，儲存每個words[i]到目前為止的匹配進度和
	其下一個字母index，若下一個字母index = words[i].size，++res，相反就
	移到對在vector所在的index並push_back進去i和其words[i]下一個index。
	vector<pair<int, int>> map[26]

///////////////////////////////////////////////////////////////
//
// lc796. Rotate String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 遍歷整個A，切割旋轉並與B比較，看是否相同。
(2) 因為若B為A的旋轉字串，其必在A+A之間，因此用string.find去找。

///////////////////////////////////////////////////////////////
//
// lc797. All Paths From Source to Target (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc801. Minimum Swaps To Make Sequences Increasing (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為當前要不要交換，也會牽扯到前一位要不要交換，因此利用state machine，
	建立swap[i] 和 noswap[i]兩變數，表示第i位交換的最小交換次數和第i位不交換
	的最小交換次數，則狀態方程可以分成兩個case：
	(1) A[i] > A[i-1] && B[i] > B[i-1]
		這個case本來就不用交換，所以noswap[i] = noswap[i-1]，
		但若i一定要交換則上一位也要交換，swap[i] = swap[i-1]+1。
	(2) A[i] > B[i-1] && B[i] > A[i-1]
		這個case是要交換的case，則swap[i] = min(swap[i], noswap[i-1]+1)，
		因為第i位要交換表示第i-1位不能交換。
		另外也可以第i位不交換，但第i-1位要交換：
		noswap[i] = min(noswap[i], swap[i-1])。
 ***可以優化成O(1) space，類似lc122，lc309。

///////////////////////////////////////////////////////////////
//
// lc802. Find Eventual Safe States
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs以及visit[i]，若當前visit[i] != -1，直接return visit[i]。
	visit[i]表示這個點是不是safe：0->not safe，1->safe。
	對於當前指向的都跑一遍dfs，只要一個return 0，就return visit[i] = 0。
	因為safe state表示怎麼走都要是safe。

///////////////////////////////////////////////////////////////
//
// lc807. Max Increase to Keep City Skyline
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先找到row_max和col_max，再算一次diff。

///////////////////////////////////////////////////////////////
//
// lc809. Expressive Words (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc208。
(1) 利用trie tree，將每個字串變為unique字串以及每個字母出現次數的組合。

///////////////////////////////////////////////////////////////
//
// lc814. Binary Tree Pruning
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，當前為0且左右子樹為null，當前改null。

///////////////////////////////////////////////////////////////
//
// lc817. Linked List Components
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 遇到斷點，代表有一個component，所以res = res+1。
	可用one pass with unordered_set。

///////////////////////////////////////////////////////////////
//
// lc819. Most Common Word (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先遍歷一遍將大寫轉成小寫，非字母轉成空白，再利用unordered_map與istringstream，
	去計算字串出現次數。
(2) 利用double pointer去比較，若當前字母不一樣，去驗證可不可以延展。
	即s[i-1] == s[i] == s[i+1] or s[i] == s[i-1] == s[i-2]
	為什麼不比較s[i] == s[i+1] == s[i+2]是因為如果在連續字母的第一格s[i] != w[j]
	後面也不用比了，直接return false。

///////////////////////////////////////////////////////////////
//
// lc823. Binary Trees With Factors (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dp，先將數組排序後，dp[A[i]] = (dp[A[i]] + dp[A[j]]*dp[A[i]/A[j]]) % M

///////////////////////////////////////////////////////////////
//
// lc830. Positions of Large Groups
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) check if s[i] != s[i-1] && i-last >= 3。

///////////////////////////////////////////////////////////////
//
// lc832. Flipping an Image
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每一列對調，然好跑一遍迴圈用xor把矩陣顛倒。
(2) 建一個新矩陣，對於每一列，用原矩陣從後面往前一一pushback到新矩陣的列中並xor。

///////////////////////////////////////////////////////////////
//
// lc840. Magic Squares In Grid
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 暴力解，注意magic square只能有1~9，且不能重複。
(2) 找規律，中間只能是5且四個corner是偶數，保持一個pattern："43816729"或
	其reverse。

///////////////////////////////////////////////////////////////
//
// lc841. Keys and Rooms
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) bfs走一遍，每走一個n--，結束後若n != 0 則return false。
(2) dfs，類似bfs，也是要利用一vector紀錄有沒有拜訪過。

///////////////////////////////////////////////////////////////
//
// lc844. Backspace String Compare (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，從尾巴開始，利用一變數來決定還要不要往前走。
(2) O(n) space，stack

///////////////////////////////////////////////////////////////
//
// lc848. Shifting Letters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從右至左跑一遍累加次數，並且shift字母。

///////////////////////////////////////////////////////////////
//
// lc849. Maximize Distance to Closest Person (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要找出0距離1最遠的方法是，對於兩個1之間取中間值就可，但頭尾的話若是0
	不用找中間值，因為另外一邊是邊界。

///////////////////////////////////////////////////////////////
//
// lc852. Peak Index in a Mountain Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search

///////////////////////////////////////////////////////////////
//
// lc856. Score of Parentheses (看) 第一種解法。
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space：
	遇到右括號，且上一個是左括號的，計算當前是幾層，就res += 1 << l (l為層數)。
	因為兩個括號一起在一個括號，他們兩個都可以各自當成在一個括號再相加。
	像乘法分配律 2*(a+b) = 2*a + 2*b。

(2) O(n) space：
	用stack，當前為')'
		遇到top是分數，累加直到top是'('。
		遇到top是'('，放入1。

///////////////////////////////////////////////////////////////
//
// lc860. Lemonade Change
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 保持五元和十元的數量去做追蹤，若數量不夠就return false。

///////////////////////////////////////////////////////////////
//
// lc861. Score After Flipping Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy approach，首先首位一定是要1，因為對於二進治：1000>0111。
	如此一來每列接翻轉完畢，再來翻轉每行(第一行不翻，因為已透過每列翻成1)，
	可以觀察到，不管本來是0還是1，只要和該列的頭(也就是首位)一樣的，必是翻完列後同樣的。
	因此可透過此方法來計算翻完列後都一樣的作為1，比較和0的個數誰比較多，作為翻轉的依據。

///////////////////////////////////////////////////////////////
//
// lc863. All Nodes Distance K in Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為tree其實也是graph一種，先用一遍dfs(preorder)將tree的連接情況記錄起來，
	也就是轉成graph，再用bfs，從target開始層層算出k距離的所有點。

///////////////////////////////////////////////////////////////
//
// lc865. Smallest Subtree with all the Deepest Nodes
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於找到一個node其subtree可以包涵所以deepest node，其實就是類似找祖先的概念，
	利用postorder，並且維持左子樹和右子樹深度，當兩深度相同，return 當前node，
	不然就return 左子樹的node或是 右子數的node。

///////////////////////////////////////////////////////////////
//
// lc867. Transpose Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) res[j][i] = A[i][j]。

///////////////////////////////////////////////////////////////
//
// lc872. Leaf-Similar Trees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder，遇到leaf就push到stinrg中，最後比較兩個string有沒有一樣。

///////////////////////////////////////////////////////////////
//
// lc876. Middle of the Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本快慢指針問題。

///////////////////////////////////////////////////////////////
//
// lc881. Boats to Save People (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) double pointer，先排序，若當前left+right <= limit，表示可配對，
	left++, --right，若不行，表示right一人坐船，left不用+1，left不能跟right做。

///////////////////////////////////////////////////////////////
//
// lc885. Spiral Matrix III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc054，遍歷的點在範圍內再放入output中。

///////////////////////////////////////////////////////////////
//
// lc888. Fair Candy Swap
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 算出兩者之前的diff，(sumb-suma)/2，
	因為一定存在一個互換使得兩邊總和相同。
	a[i]+diff = x，x若在b中表示，是一個互換pair。

///////////////////////////////////////////////////////////////
//
// lc890. Find and Replace Pattern
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立兩個vector，一個映射過去，另一個inverse。當遇到第一個設過去的，也設定inverse。
	下次遇到已經設定過映射的，檢查inverse有沒有對到自己。
	未設定的，映射過去，若inverse已經有值，表示也錯誤。

///////////////////////////////////////////////////////////////
//
// lc889. Construct Binary Tree from Preorder and Postorder Traversal (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

O(n)
(1) dfs，利用pre_idx，post_idx，利用pre[pre_idx]搭建tree，
	判斷若root->val != post[post_idx] 則繼續搭建tree。
(2) stack iteration，
	利用pre vector做搭建，維持一個stack，
	若sk.back()->val == post[pos]，則pos++, s.pop_back()，
	若s.back()->left == null，now接左邊，不然now接右邊。
	s.push_back(now)。

///////////////////////////////////////////////////////////////
//
// lc894. All Possible Full Binary Trees (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc095，但因為左右對稱，所以只須要算左半邊的左右子樹(跑一半迴圈)，右半邊直接互換就好。
	中間點不互換，避免重複。
	另外，因為是binary tree，所以當前點數必為奇數點，選完點左右也要必是奇數，
	解法：跑回圈從奇數開始為i = i+2，這樣可以避掉左右為偶數點的情況。

///////////////////////////////////////////////////////////////
//
// lc896. Monotonic Array
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 計算出現次數，若兩者都大於0，return false。
(2) 計算bool of 上升或下降，若兩個都0，代表都不符合上升或下降，return false。

///////////////////////////////////////////////////////////////
//
// lc897. Increasing Order Search Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc094。
(1) inorder stack iteration，用dummy當作輔助使用。
(2) inorder recursion，利用double link list，因為在function中會改動其值，
	所以不能使用單*，要用雙＊。

///////////////////////////////////////////////////////////////
//
// lc901. Online Stock Span
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1019，維持一個降序stack。
	利用stack紀錄當前price和其持續天數，當進來的price比sk.top的price還大時(>=)，
	sk.pop，並將top的天數加到當前price上，最後將當前price和其天數push進sk。

///////////////////////////////////////////////////////////////
//
// lc905. Sort Array By Parity
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似quick select中partition用到的方法。

///////////////////////////////////////////////////////////////
//
// lc907. Sum of Subarray Minimums (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dp[i]，表示以i為結尾的最小總和，
	- 	那如果A[i] >= A[i-1]，表示dp[i] = dp[i-1] + A[i]，因為當前比上一個大，
	 	以當前結尾就算去往前找，結果都是和以上一個結尾去找的總合一樣。
	-	反之，找到第一個A[i] >= A[idx]，dp[i] = dp[idx] + (i-idx) * A[i]。
	這可以用stack去做，因為每次都往前找，若給定降序input，每次都要找到頭，很浪費時間。
	所以用stack維持一個升序序列，若當前比top小就pop。
	類似lc977，lc1019，lc1130，lc654，1043。

///////////////////////////////////////////////////////////////
//
// lc912. Sort an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) merge sort
(2) quick sort
(3) selection sort
(4) insertion sort
(5) bubble sort

///////////////////////////////////////////////////////////////
//
// lc914. X of a Kind in a Deck of Cards
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find greatest divisor，如果最大公因數是1，表示只能分成group size是
	1的group。

///////////////////////////////////////////////////////////////
//
// lc915. Partition Array into Disjoint Intervals (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個local max表示到partition i的最大值，若localmax > A[i]，
	表示必須extend left 到包含index i，並更新local max到i的最大值，
	因此必須再額外維持一個global maxv。
(2) O(n) space，維持一個minv[i] 表示從n-1到i為止的最小值。
	if (maxv <= minv[i+1]) return i+1

///////////////////////////////////////////////////////////////
//
// lc917. Reverse Only Letters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用頭尾兩指針i, j，判斷若非字母則跳過，若兩者都是字母則交換，迴圈終止條件為
	i >= j。

///////////////////////////////////////////////////////////////
//
// lc919. Complete Binary Tree Inserter
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs維持一個queue，找到第一個沒孩子的head來做return以及插入孩子，
	注意：整個queue都是有一個或是沒有孩子的node，若頭為有兩個孩子，pop。
(2) 建heap，利用index找到沒有完整孩子的node。 (heap.size()/2)。

///////////////////////////////////////////////////////////////
//
// lc921. Minimum Add to Make Parentheses Valid
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 基本stack操作。
(2) 可不用stack，用left就可以。

///////////////////////////////////////////////////////////////
//
// lc922. Sort Array By Parity II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用double pointer，先找到第一個偶數位置是奇數和奇數位置是偶數的點，
	做swap。

///////////////////////////////////////////////////////////////
//
// lc925. Long Pressed Name
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc809。
	利用double pointer去計算當前位置有沒有相同，若沒有，判斷typed當前
	和上一個有沒有相同，若沒有，return false。
	若name有走完表示true。

///////////////////////////////////////////////////////////////
//
// lc926. Flip String to Monotone Increasing (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當前方法數最小有兩種可能
	若當前n[idx] == 0
	(a) 前n-1位已經合法單調，那麼當前變1。 ->res+1
	(b) 到第n位有1的都變0。 -> res = min(res, ones)

///////////////////////////////////////////////////////////////
//
// lc931. Minimum Falling Path Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前路徑往上一層找前後一個的最小值。
	O(n) space。

///////////////////////////////////////////////////////////////
//
// lc934. Shortest Bridge (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs將島嶼標記，用bfs找到最短距離。

///////////////////////////////////////////////////////////////
//
// lc937. Reorder Data in Log Files
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對letter排序digit不用。

///////////////////////////////////////////////////////////////
//
// lc938. Range Sum of BST (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用preorder，
	對於往左孩子走，如果root->val > R，
	就可以往左走，root->val < L，代表可往右孩子走。
	若當前在區間內，sum += root->val，兩邊都可以走。

///////////////////////////////////////////////////////////////
//
// lc939. Minimum Area Rectangle (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 暴力解，對當前點(x1,y1)，找看過的點(x2,y2)，若(x1,y2)和(x2,y1)都看過
	update area。
	O(n^2)
(2) O(nx*ny*ny) < O(n^1.5)
	if (nx == ny) -> O(nx*ny*ny) = O(n^1.5)
	First, note that, in the 3-level loop, its complexity is o(nx * ny * ny). 
	We make the size of outmost loop, ie, nx, the largest, and in this way we 
	save much computation. However, when nx = ny, we do not save computation. 
	Thus, the worst case is nx = ny. The typical example is the N points form 
	a regular grid, where nx = ny = sqrt (N)
	(a) 對於每一個x，從小到大，若有一對y1, y2，且y1和y2上次被用過的是lastx
		-> res = min(res, (x - lastx) * (y1- y2))。

///////////////////////////////////////////////////////////////
//
// lc941. Valid Mountain Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 順著找就可以。

///////////////////////////////////////////////////////////////
//
// lc944. Delete Columns to Make Sorted
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) brute force去找就好。

///////////////////////////////////////////////////////////////
//
// lc947. Most Stones Removed with Same Row or Column (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

這題是在講，對於連通的點可以移除的點數，可以用dfs或是union find，核心在於
同個島嶼移除的點數為這個島嶼的點數-1，所以總共的移除點數就是總共的點數-總共的島嶼數。
又或者每個島嶼在移除後都會剩下一個，所以若一個島嶼只有一個點，這個島嶼不能移除。
題目中的最大move數量，指的是，至個點旁邊有row或col相同的點，這個點可以move 
(也就是remove 這個點)。

(1) union find
(2) dfs

///////////////////////////////////////////////////////////////
//
// lc950. Reveal Cards In Increasing Order (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: nlogn
	利用deque，先將arr sort，再返著build return process。
	因為pusg當前的到res，會將next放到尾巴，所以對於reversed process，
	我們可以將尾巴放到當前的next。

	簡言之，push當前，next放到尾巴 -> 尾巴放到頭，push到頭。

///////////////////////////////////////////////////////////////
//
// lc951. Flip Equivalent Binary Trees
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先判斷當前兩個node有沒有一樣，
	再return 左孩子左孩子 && 右孩子右孩子 || 左孩子右孩子 && 右孩子左孩子。

///////////////////////////////////////////////////////////////
//
// lc953. Verifying an Alien Dictionary
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 紀錄順序，兩兩比較，若a > b則return false。

///////////////////////////////////////////////////////////////
//
// lc957. Prison Cells After N Days (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持一個cycle，若當前res出現過， N = (N - 1) % (cycles-1);

///////////////////////////////////////////////////////////////
//
// lc958. Check Completeness of a Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，complete biniry tree特性為用bfs走訪一定全走非null node，遇到null
	node後，後面一定都是null，利用這特性可以跑第一遍while將node全push到queue直到遇到
	queue中第一個非null，再用另一個while繼續走queue直到遇到第一個非null node或走完queue。
	return index == que.size()。

///////////////////////////////////////////////////////////////
//
// lc959. Regions Cut By Slashes (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2。

(1) 利用union find，將每一個grid劃分成四小等份，上右下左依序為0,1,2,3。
	那麼其實就是對於這些小分塊做union find。
	要注意的是，相鄰的grid預設就要union，因為slash無法分割這些。
	若當前grid[i][j] != '/'，表示0 and 1要union，2 and 3要union。
	若當前grid[i][j] != '\'，表示0 and 3要union，1 and 2要union。
	count數量就是n*n*4。
(2) dfs，將grid分成3*3小塊，然後slash改成1其餘為0，這樣就是
	number of islands。

///////////////////////////////////////////////////////////////
//
// lc965. Univalued Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs，preorder。

///////////////////////////////////////////////////////////////
//
// lc969. Pancake Sorting
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到剩餘長度最大的(index: i)，翻到頭，再翻到剩餘長度的位置(index: n)。
	reverse(begin ~ i) then reverse(begin ~ n); --n;

///////////////////////////////////////////////////////////////
//
// lc971. Flip Binary Tree To Match Preorder Traversal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 若當前node不等於voyage的對應點，return {-1}，若左孩子的val != voyage[now+1]，
	swap(root->left, root->right)。

///////////////////////////////////////////////////////////////
//
// lc973. K Closest Points to Origin (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) quick select，不好懂。 類似215。
(2) priority queue。

///////////////////////////////////////////////////////////////
//
// lc974. Subarray Sums Divisible by K (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 和lc560類似。要注意餘數為負數的時候再加上K，prefix sum。
(2) 先算好所有的出現相同餘數的次數，再一次跑一個迴圈算好。
	ex: 若該餘數出現4次，則符合題目的次數為1+2+3。

///////////////////////////////////////////////////////////////
//
// lc977. Squares of a Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 雙指針(頭尾)取絕對值大的填入res的尾端。
(2) stack，類似lc1019，維持一個降序陣列。

///////////////////////////////////////////////////////////////
//
// lc978. Longest Turbulent Subarray (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) > ： sign = 1， < ： sign = -1
	對於當前>或<，紀錄上次是相反結果(sign)的話cnt++，反之就重新初始化狀態(cnt = 2)。
	注意若當前=上一個，初始化sign = -1, cnt = 1。

///////////////////////////////////////////////////////////////
//
// lc979. Distribute Coins in Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，紀錄當前硬幣總數，此硬幣總數代表要往父節點移動的個數。

///////////////////////////////////////////////////////////////
//
// lc980. Unique Paths III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先計算要走的數量， 然後用一般的dfs即可。

///////////////////////////////////////////////////////////////
//
// lc983. Minimum Cost For Tickets (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 跑365天循環，對當前天數，選擇最小付費方式。
	若不是搭車日期(初始化=INT_MAX)，照理說不花費，所以dp[i] = dp[i-1]。
	若是搭車日期(初始化=0)，找出最小付費方式。

///////////////////////////////////////////////////////////////
//
// lc985. Sum of Even Numbers After Queries (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持even sum，若query的index a[idx] is even，先扣掉
	even -= a[idx]
	update a[idx] = a[idx] + val
	再次檢查a[idx]是不是even，是的話，加回even。
	O(n):
	n here is the size of A. Based on the problem description, 
	it dominates the size of queries (0 <= queries[i][1] < A.length). 
	So, worst case scenario, we need 3 * n operations, which is O(n).

///////////////////////////////////////////////////////////////
//
// lc986. Interval List Intersections (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先判對兩個list有沒有交集，若沒有則換下一個，
	若有交集，頭取max(a.start, b.start)，
			 尾取min(a.end, b.end)。
	類似lc56。

///////////////////////////////////////////////////////////////
//
// lc987. Vertical Order Traversal of a Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為相同的x y 需要排序，同一個x不同y，則y由小到大填入，因此map作為資料結構。
	map<int, map<int, set<int>>> info來記錄-> info[x][y].insert(node->val)。
	(a) dfs
	(b) bfs

///////////////////////////////////////////////////////////////
//
// lc988. Smallest String Starting From Leaf (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 錯誤想法：postorder去隨時找到最小字串。
	這題是對於所有string從leaf到root找最小字串，所以每次比較都必須是leaf到root
	的字串，這樣就必須用preorder(dfs)而非postorder。
	類似lc1026。

///////////////////////////////////////////////////////////////
//
// lc989. Add to Array-Form of Integer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後面往前走，一位一位的加。

///////////////////////////////////////////////////////////////
//
// lc991. Broken Calculator
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 如果 x >= y，res += x-y，
	但x < y，最快的方法就是讓y <= x，

	為什麼優先除： 假設(y+2n) / 2 = x
	若我們先+2n times then / 2， # of operations: 2n+1
	若我們先除：y/2 + n = x， # of operations: n+1
	所以永遠先除以2都是對的，會造成最小的結果。

	We do Y/2 all the way until it's smaller than X,
	time complexity is O(log(Y/X)).

///////////////////////////////////////////////////////////////
//
// lc992. Subarrays with K Different Integers (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1004，lc1052，lc340。
	利用sliding window，紀錄所有子字串使用的integeres with different
	integers <= k。
	at most k - at most k-1。

///////////////////////////////////////////////////////////////
//
// lc993. Cousins in Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用dfs，隨時記錄當前node的parent和當前node高度，當遇到node->val等於x或是
	y，紀錄其高度，return true if parent不一樣且高度相同，否則false。
(2) bfs做法也是一樣。

///////////////////////////////////////////////////////////////
//
// lc994. Rotting Oranges (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，每清掉一層queue，++res，像洋蔥是剝皮。
	while (qsize) {
		for (int i = 0; i < qsize; ++i) {

		}
		days++;
	}

///////////////////////////////////////////////////////////////
//
// lc997. Find the Town Judge
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到一個點其in_degree - out_degree = N-1。

///////////////////////////////////////////////////////////////
//
// lc998. Maximum Binary Tree II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律。
	if (root->val < val)
		new TreeNode(val)->left = root;
	else
		root->right = func(root->right, val);

///////////////////////////////////////////////////////////////
//
// lc999. Available Captures for Rook
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到root，往四邊走。

///////////////////////////////////////////////////////////////
//
// lc1002. Find Common Characters (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用cnt(26)，每次和當前的比較，取最小值。

///////////////////////////////////////////////////////////////
//
// lc1003. Check If Word Is Valid After Substitutions (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用stack去解，遇到c時檢查當前最上面兩個是不是a和b，不是就return false。

///////////////////////////////////////////////////////////////
//
// lc1004. Max Consecutive Ones III (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 使用sliding window，右邊界一直往右，遇到0，k--，若k<0，移動左邊界，
	移動左邊界中遇到0，++k(每個iteration只移動一次，為的是right增長一次，left也要增長一次
	，因為k<0，必需停止array大小增大)，直到k>=0，就不移動左邊界，
	此方法保持左右邊界維持合法吧0數量。

///////////////////////////////////////////////////////////////
//
// lc1005. Maximize Sum Of Array After K Negations (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用quick select將前k小的找出來，然後遍歷一次對於負數且在k次的取正號，
	若k有剩餘則代表都是正號，找到最小的，取負數。

///////////////////////////////////////////////////////////////
//
// lc1008. Construct Binary Search Tree from Preorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1, 2

類似lc108。
(1) stack iteration：
	當前比stack的top小就丟入stack，且stack.top->left = 當前。
	當比stakc的top大，找到最後一個比top大的元素，將這元素->right = 當前。
(2) dfs recursion：
	跑n次迴圈，每次將一個node塞到tree中適當的位置(用遞迴)。

///////////////////////////////////////////////////////////////
//
// lc1010. Pairs of Songs With Total Durations Divisible by 60
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use map(60, 0) to store all possible time[i] % 60,
	res += map[now], with now = (60 - time[i]%60) % 60
	like prefix sum。

///////////////////////////////////////////////////////////////
//
// lc1013. Partition Array Into Three Parts With Equal Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 算出sum/3，count 次數，必須>=3。比3大是因為有可能sum == 0。

///////////////////////////////////////////////////////////////
//
// lc1018. Binary Prefix Divisible By 5
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) mod 5 at every step

///////////////////////////////////////////////////////////////
//
// lc1019. Next Greater Node In Linked List (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc503，但是因為只要找一輪，從尾巴往頭看，每次push當前val進入stack，
	找當前下一個大的，對stack找到第一個比當前大的就好(其他pop)，
	其他pop掉沒差，因為比當前小，代表往頭看當前絕對比其他val還要有可能是下一個大的。

///////////////////////////////////////////////////////////////
//
// lc1021. Remove Outermost Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為最外邊的括號會和前後兩個primitive compotnent相連，用cnt計算括號，
	若不等於0則放入res。

///////////////////////////////////////////////////////////////
//
// lc1022. Sum of Root To Leaf Binary Numbers
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1025. Divisor Game
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs recursive
(2) 找規律

///////////////////////////////////////////////////////////////
//
// lc1026. Maximum Difference Between Node and Ancestor (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用preorder (dfs)，來對整條由上往下的路徑找最大最小，藉此找到max diff。
	錯誤想法：由下往上無法確定從單一leaf到root的分別最大最小，因為這樣找會變成整個tree的最大最小，
	這樣的最大最小不一定在同一路徑上，也就不存在祖孫後代的關係。

///////////////////////////////////////////////////////////////
//
// lc1028. Recover a Tree From Preorder Traversal
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用stack size來判斷，
	若當前size == 要插入深度，back->left = now，
	反之，pop_back直到size == 拆入深度，back->right = now。

///////////////////////////////////////////////////////////////
//
// lc1029. Two City Scheduling (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為有n人去a城市，有n人去b城市，對差值做排序，越大的越前面，表示前半部去b城市，
	後半部去a城市。

///////////////////////////////////////////////////////////////
//
// lc1034. Coloring A Border (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將tagcolor全標-tagcolor，當前點跑完四個方向dfs後，若上下左右取abs後都是
	tagcolor，表示是component內部點，改為tarcolor。

///////////////////////////////////////////////////////////////
//
// lc1035. Uncrossed Lines (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp解，
	表示為dp[i][j]，
	若當前A[i] == B[j]，dp[i][j] = dp[i-1][j-1] + 1。
	否則，dp[i][j] = max(dp[i][j-1], dp[i-1][j])。
	*** 可優化為空間O(n)。

///////////////////////////////////////////////////////////////
//
// lc1037. Valid Boomerang (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算斜率，注意因為分母可能0，所以將兩個斜率的比較式變形。
	ya/xa == yb/xb is equal to ya*xb == yb*xa。

///////////////////////////////////////////////////////////////
//
// lc1038. Binary Search Tree to Greater Sum Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) inorder

///////////////////////////////////////////////////////////////
//
// lc1043. Partition Array for Maximum Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 區間內最多k個，用dp解。
	j = i ~ i-k+1
	dp[i] = max(dp[i], dp[j-1] + (i-j+1)*區間最大的A val)
	類似lc907。

///////////////////////////////////////////////////////////////
//
// lc1046. Last Stone Weight
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) nlogn sort。
(2) priority queue。 (較好)

///////////////////////////////////////////////////////////////
//
// lc1047. Remove All Adjacent Duplicates In String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc394，lc856，利用stack去做消掉括號的動作。
(2) 每次找到兩個一樣的用erase消除，且idx歸於0，但很慢。

///////////////////////////////////////////////////////////////
//
// lc1048. Longest String Chain (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp iteration。
	先將vector排序，
	對每一個word去做 last_str = word.substr(0,j) + word.substr(j+1)
	類似lc 301
	dp[cur_str] = max(dp[cur_str], dp[last_str]+1)

///////////////////////////////////////////////////////////////
//
// lc1049. Last Stone Weight II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc416，lc494。
	對於x!=y取diff，x==y抵銷，可以想像成數字分成兩堆，若一樣就是0，若不一樣取diff。
	這也就把題目轉換成0/1 Knapsacks problem。
	不可用bitset，因為bitset是用來判斷那位有沒有，無法計算次數。

///////////////////////////////////////////////////////////////
//
// lc1051. Height Checker
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1052. Grumpy Bookstore Owner
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window，往右遇到1加上，window size-1 是1扣掉。

///////////////////////////////////////////////////////////////
//
// lc1057. Campus Bikes (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，將所有配對可能通過bucket做排序，且worker從低idx到高idx，
	bikes也是從低idx到高idx，這樣的話，對同一個slot，先選低worker id，
	若worker id相同，一定低bike id先選。

///////////////////////////////////////////////////////////////
//
// lc1059. All Paths from Source Lead to Destination
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc802。
(1) dfs recursion，遇到dest檢查是終點(dst沒有指向其他點)，遇到visit[i]
	若visit[i] != -1表示之前走過，直接return。
	也可用visit表示當前路徑下走過的點，若遇到代表有環，return false。

///////////////////////////////////////////////////////////////
//
// lc1060. Missing Element in Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search
	func(idx)表示到idx為止missing number的個數。
	注意邊界問題，if k > func(arr.size()-1)，
	return arr[left] + k-func(left)
	otherwise
	return arr[left-1] + k-func(left-1)

///////////////////////////////////////////////////////////////
//
// lc1061. Lexicographically Smallest Equivalent String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

都是用union find
(1) 當ap != bp，因為要找同一group最小的，我們可以在接parent時，將大的往小的接，
	這樣保證root of union一定是最小。
(2) 用set來把同一個union的收集起來。

///////////////////////////////////////////////////////////////
//
// lc1064. Fixed Point
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本binary search。

///////////////////////////////////////////////////////////////
//
// lc1071. Greatest Common Divisor of Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用輾轉相除去算即可，因為這裡整除代表str1的首str2.size()一定要是str2，
	若不是，即無法相除，return ""。

///////////////////////////////////////////////////////////////
//
// lc1072. Flip Columns For Maximum Number of Equal Rows (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找flip後最多一樣是0 or 1的個數，所以紀錄每個row出現的次數，次數越多
	表示對這些次數多得column flip，得到的結果一定是最大數量的 0 or 1 rows。

///////////////////////////////////////////////////////////////
//
// lc1079. Letter Tile Possibilities (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc047。
	dfs，檢查當前若和上一個一樣且上一個也是未visit，當前跳過。
		要未visit的才跳過是因為未visit表示屬於同層，visit表示上一層處理過。
		比較有沒有重複都是要同層的。
	若字符不是排序過後 如"ABA"，則用(1-2)

///////////////////////////////////////////////////////////////
//
// lc1080. Insufficient Nodes in Root to Leaf Paths
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) (a) Go to leaf to check if limit > 0.
	(b) for every internal node, if return child is both NULL, 
		it means that this node is insufficient node. So we return NULL.

///////////////////////////////////////////////////////////////
//
// lc1085. Sum of Digits in the Minimum Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找到最小值。

///////////////////////////////////////////////////////////////
//
// lc1086. High Five (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) counting sort
(2) partial sort

///////////////////////////////////////////////////////////////
//
// lc1087. Brace Expansion
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本permutaion的dfs

///////////////////////////////////////////////////////////////
//
// lc1089. Duplicate Zeros (看)* 第一種方法
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先計算額外空間 = 0的數量，再來用一指針j從尾巴開始，另一個指針從原arr尾巴
	開始，若--j < n才assign當前值 -> a[j] = a[i] (往後位移一個)，
	且若arr[i] = 0，且--j < n，assign a[j] = 0。
(2) 對於重複的插入0，並pop_back。

///////////////////////////////////////////////////////////////
//
// lc1090. Largest Values From Labels
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) priority queue

///////////////////////////////////////////////////////////////
//
// lc1091. Shortest Path in Binary Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1094. Car Pooling
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc731，lc253。
	利用一array紀錄人數，注意在結束的時候要扣掉人數。
	cnt[trip[i][1]] += trip[i][0];
	cnt[trip[i][2]] -= trip[i][0];
	traverse array累加capacity，若大於limit，return false。

///////////////////////////////////////////////////////////////
//
// lc1095. Find in Mountain Array (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用binary search先找到peak index，再來對兩邊的的arr分別做一次
	binary search。

///////////////////////////////////////////////////////////////
//
// lc1099. Two Sum Less Than K
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort then two pointers。

///////////////////////////////////////////////////////////////
//
// lc1100. Find K-Length Substrings With No Repeated Characters (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window，看clean code。

///////////////////////////////////////////////////////////////
//
// lc1101. The Earliest Moment When Everyone Become Friends (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find with path compression and union by size.
	先sort，一旦size == N，return time。
	union by size：只有union head的parent指向union size。
	這樣可以不用額外創一個空間儲存每一個union的size。

///////////////////////////////////////////////////////////////
//
// lc1102. Path With Maximum Minimum Value (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用Dijkstra找maximun path from source，且這個maximum表示路徑中的最小值
	是所有路徑最大的。算是Dijkstra的變形。

///////////////////////////////////////////////////////////////
//
// lc1104. Path In Zigzag Labelled Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找出對稱性，除了第一個以外每個都是當前層級的對稱點。
	當前層級區間: res[i] = pow(2,i) - 1 + pow(2,i+1) - res[i+1]。

///////////////////////////////////////////////////////////////
//
// lc1105. Filling Bookcase Shelves (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp[i]表示到第i本書的最小高度
	dp[i] =  min(dp[i], dp[j-1] + h)
	j from i to 1
	h = max(h, books[j-1][1])
	且w要在max_width範圍內。

///////////////////////////////////////////////////////////////
//
// lc1109. Corporate Flight Bookings (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 將res[i] += res[i-1]
	若一個兼具為a~b，則在b+1 設置 -v
	這樣在b+1累加的可以扣掉。

///////////////////////////////////////////////////////////////
//
// lc1110. Delete Nodes And Return Forest
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用set來儲存delete node，後序由底層往上去扣除刪掉的點，postorder。

///////////////////////////////////////////////////////////////
//
// lc1111. Maximum Nesting Depth of Two Valid Parentheses Strings (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 要找到max(depth(a), depth(b))是minimal，把重點放在nested ()
	ex: ((()))，若都給同一個，如a或b，一定會太大，最好的方式就是將這些平均分給
	a和b，所以輪流給。也就能將maxdepth of input分成兩半，max(a和b的depth)
	一定是最小的。

///////////////////////////////////////////////////////////////
//
// lc1114. Print in Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用counter和contition variable來控制順序。

///////////////////////////////////////////////////////////////
//
// lc1118. Number of Days in a Month
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit operation，閏年400潤一次，百年不潤，四年潤一次。

///////////////////////////////////////////////////////////////
//
// lc1119. Remove Vowels from a String
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one time pass push_back。

///////////////////////////////////////////////////////////////
//
// lc1120. Maximum Average Subtree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder。

///////////////////////////////////////////////////////////////
//
// lc1122. Relative Sort Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用counting sort，先計算各個數字的出現次數，再對於arr2的數字去填入res，
	再將不屬於arr2的數字從0~1000依序填入。

///////////////////////////////////////////////////////////////
//
// lc1123. Lowest Common Ancestor of Deepest Leaves (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 一次postorder，高度從最底層開始算(深度是由上往下算)，
	若左子樹高度 = 右子樹高度，return root。
	若左子樹高度 > 右子樹高度，return left 
						(此left為遞迴return值，並不一定是root->left)。
	若左子樹高度 < 右子樹高度，return right 
						(此right為遞迴return值，並不一定是root->right)。

(2) 兩次postorder，第一次找最大深度，第二次跑lc236找最小共同祖先。

///////////////////////////////////////////////////////////////
//
// lc1128. Number of Equivalent Domino Pairs (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc049，lc1048。

(1) 利用bit operation去encode每個pair做出id。

///////////////////////////////////////////////////////////////
//
// lc1129. Shortest Path with Alternating Colors (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為有紅藍兩色，建立data structure {node, color}，表示這個點只能由
	color edge 連過來。從零開始用bfs。初始化個點最大path為2 * n，n為總數。

	其實最大是n*2-3：
	The maximum result happens when in a path from 0 to target, 
	all the intermediate nodes (excluding 0 and target) have 
	an additional self-edge. e.g.

	red_edges = [[0, 1], [1, 2], [2, 3]]
	blue_edges = [[1, 1], [2, 2]]
	n = 4
	The minimum step to reach 3 is 5 steps, because all intermediate 
	nodes 1 and 2 contain self-edges. In other words, 
	the maximum result can be 2 * (n - 2) + 1.

///////////////////////////////////////////////////////////////
//
// lc1130. Minimum Cost Tree From Leaf Values (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(n^2)：greedy。
	每次遍歷一遍找到乘積最小的並刪掉較小的那一個數。
(2) O(n)：
	類似lc1019，使用stack。
	維持降序陣列在stack，當遇到第一個比陣列尾巴大的，要去除尾八，並且對
	尾巴左邊和當前比他大的中去取小的和(去除的值，也就是本來的尾巴)相乘，
	結束後再對陣列尾八繼續坐上述比較，直到沒有尾巴比當前小。
	最後將陣列兩兩相乘(這些為降序陣列)。
	原因：要找到兩倆乘積最小，若是降序則右乘回來，若任三個存在中間最小，則優先處理。

///////////////////////////////////////////////////////////////
//
// lc1133. Largest Unique Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bucket sort，從後面往前遍歷，看到第一個cnt == 1，return。

///////////////////////////////////////////////////////////////
//
// lc1135. Connecting Cities With Minimum Cost (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先將vector依照cost排序，若依一邊長兩個點的parent不同，連接他們，
	並res += cost，直到連接了n-1個node為止。
	union find
	類似lc721。

///////////////////////////////////////////////////////////////
//
// lc1140. Stone Game II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dp recurtion
	dp[i][m]表示第從尾巴到第i個pile拿最多的數量，其實就是可以算出對方拿最小的，這樣我
	就是最大的。
	dp[i][m] = psum[i] - min(dp[i+x][max(x,m)]), for x = 1 ~ 2*m

///////////////////////////////////////////////////////////////
//
// lc1143. Longest Common Subsequence
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1035，可用O(n) space，dp iteration。

///////////////////////////////////////////////////////////////
//
// lc1145. Binary Tree Coloring Game (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於x可以將樹分成三部分，x->left, x->right, 除了x->left, x->right, x的其他node
	數量，從這三部分中選取最大的數量，若 > n/2，return true。
	*** follow up
	Alex and Lee are going to play this turned based game.
	Alex draw the whole tree. root and n will be given.
	Now Lee says he want to color the first node.

	Return true if Lee can ensure his win, otherwise return false
	Could you find the set all the nodes, that Lee can ensure he wins the game?
	What is the complexity of your solution?

	對於每個點算出left child，right child，以及parent以外的個數，任一兩個>the rest的話，
	lee 就會贏。

///////////////////////////////////////////////////////////////
//
// lc1146. Snapshot Array (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) data structure: unordered_map<int, map<int, int>> record
	對每一格index，存他的版本和該版本的val。
	利用upper_bound去找到最大的版本 < snap_id。
	get: O(logn)
	set: O(1)
	initial: O(n)
	snap: O(1)

///////////////////////////////////////////////////////////////
//
// lc1150. Check If a Number Is Majority Element in a Sorted Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) binary search，找到第一個index，然後check nums[i + n/2] == nums[i]。

///////////////////////////////////////////////////////////////
//
// lc1152. Analyze User Website Visit Pattern (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc937。
	這題在於使用者取其visit pattern，因visit by the most users，單一user
	對同一個pattern只會visit一次，可用unordered_map<user_name, map<time_stamp, websit>>
	去紀錄，用三個for迴圈找出所有visit pattern by a user。

///////////////////////////////////////////////////////////////
//
// lc1155. Number of Dice Rolls With Target Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc70，lc518。
(1) iteration 解法類似lc494。
	因為可以有顛倒順序，amount要在外面，內圈則為dice。
(2) recursion，解法類似lc494。

///////////////////////////////////////////////////////////////
//
// lc1160. Find Words That Can Be Formed by Characters
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) cnt(26)，若--cnt[words[i]][j] < 0，valid = false。

///////////////////////////////////////////////////////////////
//
// lc1161. Maximum Level Sum of a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs，用queue。

///////////////////////////////////////////////////////////////
//
// lc1162. As Far from Land as Possible
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs with queue。
	類似lc934。

///////////////////////////////////////////////////////////////
//
// lc1167. Minimum Cost to Connect Sticks (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) greedy method，先將小的合併，之後總和會比較小 -> 我們要小的，代表層層迭代
	過程中，若小的越早合併，之後小的佔結果比例會較高，相反，若大的先合併，每次疊起來，
	最大的每次都會被加到。
	所以是用priority queue。

///////////////////////////////////////////////////////////////
//
// lc1169. Invalid Transactions
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用map記錄每個人的所有交易紀錄，對於每一個新的交易，檢查map中有沒有和
	當前交易為invalid的。

(2) 不用map，用四個vector紀錄訊息，跑一個n^2 for loop確認每個交易是不是invalid，
	最後跑一個n loop確認invalid的交易丟到res中。

///////////////////////////////////////////////////////////////
//
// lc1170. Compare Strings by Frequency of the Smallest Character
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，從尾巴往前累加cnt，對每一個query string，
	return cnt[f]。
	note: cnt[f]表示 所有words 其smallest ch 個數 > f的個數總和。

///////////////////////////////////////////////////////////////
//
// lc1171. Remove Zero Sum Consecutive Nodes from Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc437，lc560，lc974。
	利用prefix_sum，注意刪除的中間段必須把map中的sum也清除，用erase。

///////////////////////////////////////////////////////////////
//
// lc1176. Diet Plan Performance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sliding window。

///////////////////////////////////////////////////////////////
//
// lc1184. Distance Between Bus Stops
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) split to two array

///////////////////////////////////////////////////////////////
//
// lc1186. Maximum Subarray Sum with One Deletion (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc053.cpp。
	分成兩個case，主要是這兩個case都維持一個min，
	a. maxNoDelete就是lc053。
	b. maxWithDelete：考慮若當前要delete，就用上一輪的maxNoDelete，
	   不delete就用maxWithDelete+arr[i]。

///////////////////////////////////////////////////////////////
//
// lc1188. Design Bounded Blocking Queue (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用unique_lock做write，shared_lock做read，condition_variable
	等待其他thread完成一定條件後解鎖，來做write。

///////////////////////////////////////////////////////////////
//
// lc1189. Maximum Number of Balloons
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，對所求的取min(l和o要除以2)。

///////////////////////////////////////////////////////////////
//
// lc1192. Critical Connections in a Network (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用rank來判斷有沒有走過，若dfs return的rank > 當前rank，這edge要被加入，
	因為dfs往後的過程沒有cycle，有cycle的話return value一定 <= 當前 rank。
	另外遇到parent需要跳過。

///////////////////////////////////////////////////////////////
//
// lc1196. How Many Apples Can You Put into the Basket
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，O(1000 + N)，若Ｎ>>1000，bucket sort效果優於nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1200. Minimum Absolute Difference
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，因為要找最小difference的所有組合，一定是相鄰兩個去做比較。

///////////////////////////////////////////////////////////////
//
// lc1202. Smallest String With Swaps (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find with path compression，compare with union size。
	將同一union的index放在一起，由小到大，然後sort後一一填入。

///////////////////////////////////////////////////////////////
//
// lc1209. Remove All Adjacent Duplicates in String II (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) stack iteration，類似lc723。
follow up: >= k
	(a) 先檢查若跟最後一個不一樣，判斷最後一個有沒有>=k，若有，pop
	(b) 再來判斷最後一個有沒有和自己一樣，若有cnt++，若沒有，push {1}。
	(c) 結束loop後檢查最後一個有沒有>=k，若有pop。

///////////////////////////////////////////////////////////////
//
// lc1213. Intersection of Three Sorted Arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 當三個不一樣時，找出最大值，update其他兩個到至少比最大值大或相等。

///////////////////////////////////////////////////////////////
//
// lc1214. Two Sum BSTs (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 用stack做inorder traversal，類似lc1305。
(2) 用recursion，確認當前有沒有符合，若沒有，往左和往右去找。

///////////////////////////////////////////////////////////////
//
// lc1217. Play with Chips
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為移動一格為cost 1，移動兩格cost 2，所以若都是奇數位置或偶數位置，cost = 0，
	因此計算odd & even次數，reutrn min(odd, even)。

///////////////////////////////////////////////////////////////
//
// lc1219. Path with Maximum Gold
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 一般dfs。

///////////////////////////////////////////////////////////////
//
// lc1221. Split a String in Balanced Strings
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算左右值，相消=0，res++。

///////////////////////////////////////////////////////////////
//
// lc1227. Airplane Seat Assignment Probability (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) f(n) = 1/n + 1/n * (n-2) * f(n-1)。
	(a) the 1st person gets his/her own seat. (with probability 1/n). 
		Then the n-th person is sure (with probability 1) to get the n-th seat.
	(b) the 1st person gets the n-th person's seat. (with probability 1/n). 
		Then the n-th person cannot (with probability 0) get the n-th seat.
	(c) the 1st person gets a seat between 2 and n-1 (with probability (n-2)/n). 
		Assume the 1st person gets a-th seat. Then in the next round, we have 3 choices again:
	3.1) if the a-th person gets 1st seat (with probability 1/(n-1)), 
		 then this is just like 1st and a-th person swap their seats, 
		 it never affect our result for the n-th person.
	3.2) if the a-th person gets n-th seat (with probability 1/(n-1)), 
		 game over.
	3.3) if the a-th person gets a seat which is not 1st or n-th, 
		 (with probability (n-1-2)/(n-1)), we jump into a loop.
(2) 利用數學歸納法得證 n > 1，f(n) = 0.5。

///////////////////////////////////////////////////////////////
//
// lc1232. Check If It Is a Straight Line
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 斜率轉換，avoid divide by zero condition。
				(y2-y1) / (x2 - x1) == (y3-y2) / (x3 - x2) 
	is equal to 
				(y2-y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)

///////////////////////////////////////////////////////////////
//
// lc1236. Web Crawler
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs recursion

///////////////////////////////////////////////////////////////
//
// lc1243. Array Transformation (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(1) space，紀錄nums[i]為prev，作為下一輪使用。

///////////////////////////////////////////////////////////////
//
// lc1244. Design A Leaderboard
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 用兩個map，一個set of pair，記錄每個分數和他的名字，
	另一個key:名字，value:分數。

///////////////////////////////////////////////////////////////
//
// lc1245. Tree Diameter
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 類似lc310，維持當前還沒用的剩餘node，while (n > 1)，若剩1表示2*res，
	對稱的。
	若n = 0，表示不對稱，2*res - 1。

(2) 計算以每個node為root的最大path，且不能走過parent node的點，不然會無窮
	迴圈。

///////////////////////////////////////////////////////////////
//
// lc1247. Minimum Swaps to Make Strings Equal (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 收集xy和yx pattern，因為要最小的swap，先去看xy自己能不能組完，yx也是，
	也就是res += (xy/2 + yx/2)，再來 xy % 2 和 yx % 2 表示用剩下來的，
	這一定是0個或1個，若只有其中是一個，return -1，若兩個都是1，表示可以swap，
	方法數 = 2，兩個都是0，維持原狀。

///////////////////////////////////////////////////////////////
//
// lc1249. Minimum Remove to Make Valid Parentheses (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc301。

(1) stack iteration，將不合法得改成'*'。

///////////////////////////////////////////////////////////////
//
// lc1252. Cells with Odd Values in a Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(m*n + l)，l: length of indeces
	紀錄出現過的row和col次數，遍歷一次matrix，看當前的row和col的合是不是odd。

(2) O(m + n + l)，計算被點到odd次數的row數量和col數量
	return even_row * odd_col + even_col * odd_row。

///////////////////////////////////////////////////////////////
//
// lc1254. Number of Closed Islands
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 做dfs，碰到邊就return 1。
(2) 先將四邊做dfs，再對內部做dfs。

///////////////////////////////////////////////////////////////
//
// lc1257. Smallest Common Region (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 建立tree map，from bottom to top，然後建立visit map，把region1 走過的
	都插入，再來traverse region2 parent path，若任一點在visit有看過，r
	return這一點。
(2) 建立tree map，from top to bottom，再來用一般lowest common ancestor
	去做。

///////////////////////////////////////////////////////////////
//
// lc1260. Shift 2D Grid
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算出最終column位置 by i+shift，shift = k % col
	計算共同往下shift的變數times = k / col。
	shift也可代表額外往下shift 1 的個數，從col-1往前shift個column都要額外
	往下shift 1。

///////////////////////////////////////////////////////////////
//
// lc1261. Find Elements in a Contaminated Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use bit set，save memory。
(2) use hash set

///////////////////////////////////////////////////////////////
//
// lc1266. Minimum Time Visiting All Points
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 找規律，因為若兩者有差，會走完共同的，然後再多走差的數量，這就表示
	兩者之間走的距離就是max(diffx, diffy)。

///////////////////////////////////////////////////////////////
//
// lc1268. Search Suggestions System (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) 先將string lexicographically排序，這樣會有一個性質：
	如果a[i] is prefix of a[j] -> a[i] is prefix of x, x from i+1~j-1。
	所以我們從上一次起始點 last_start 往後開始搜尋第一個word >= search word，
	也就是new_start，開始搜尋，然後更新start place from last_start to new start。
	time: O(log(N)) for each query
(2) 直接用set，lower_bound為 O(log(N))

///////////////////////////////////////////////////////////////
//
// lc1272. Remove Interval
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc986。
	對於有交集的，找出沒有在remove interval中的，分三case
	a. 沒交集
	b. 交集且interval[0] < start
	c. 交集且interval[1] > end

///////////////////////////////////////////////////////////////
//
// lc1273. Delete Tree Nodes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從nodes-1跑到1，value[parent[i]] += vallue[i]。
	且res[i]，表示當前i為root的subtree中所有不能抵消的點。
	若value[i] != 0，要把這些點給parent[i]。
	即res[parent[i]] += res[i]。
(2) build tree，跑一遍postorder，若sum == 0，return nodes = 0。

///////////////////////////////////////////////////////////////
//
// lc1274. Number of Ships in a Rectangle
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) time: T(n) = 4*T(n/4)+c = O(n)
	注意邊界問題。

///////////////////////////////////////////////////////////////
//
// lc1275. Find Winner on a Tic Tac Toe Game
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc348。

///////////////////////////////////////////////////////////////
//
// lc1277. Count Square Submatrices with All Ones (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc221。
	dp[i][j] means the size of biggest square with A[i][j] as bottom-right corner.
	dp[i][j] also means the number of squares with A[i][j] as bottom-right corner.
	O(n^2)
(2) 用prefix sum，O(n^3)，類似lc1314。

///////////////////////////////////////////////////////////////
//
// lc1279. Traffic Light Controlled Intersection (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1188，但不用conditional variable。

///////////////////////////////////////////////////////////////
//
// lc1282. Group the People Given the Group Size They Belong To (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 維持gp(n+1)，
	對於group size，如 = 3，將 = 3的idx收集，直到gp[3].size() == 3，然後push到
	res，並清空gp[3]，這樣就可以依序將所有同一個group size的人收集。
(2) sort idx by group size，一一填入。

///////////////////////////////////////////////////////////////
//
// lc1287. Element Appearing More Than 25% In Sorted Array (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(logN)，binary search，找出candiate first location & last location。
	類似lc33。
(2) 因為是sorted且只有一個arr[i] cnt > 25%，對每個arr[i]去檢查
	若arr[i] == arr[i+n/4]，表示arr[i]數量>25%。

///////////////////////////////////////////////////////////////
//
// lc1290. Convert Binary Number in a Linked List to Integer
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bit manipulation

///////////////////////////////////////////////////////////////
//
// lc1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum
	O(m*n)
	若當前i~i-len且j~j-len的方形 <= threshold，len++。
(2) prefix sum + binary search to find max side length
	O(m*n*log(m+n))

///////////////////////////////////////////////////////////////
//
// lc1295. Find Numbers with Even Number of Digits
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 因為maxv為10^5，可以直接用區兼職判斷，O(n)
(2) digit by digit check，O(n*k)，k為number of digit for each nums[i]

///////////////////////////////////////////////////////////////
//
// lc1299. Replace Elements with Greatest Element on Right Side (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 從後面走回去，維持一個最大值。

///////////////////////////////////////////////////////////////
//
// lc1302. Deepest Leaves Sum (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) dfs
(2) queue iteration，bfs。

///////////////////////////////////////////////////////////////
//
// lc1304. Find N Unique Integers Sum up to Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 不要用1+2+...+n-1，因為如果n很大會overflow，
	find rule。
	2*i - (n-1)

///////////////////////////////////////////////////////////////
//
// lc1305. All Elements in Two Binary Search Trees (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1214，two stack inorder traversal。
(2) 將node value放入res然後sort

///////////////////////////////////////////////////////////////
//
// lc1306. Jump Game III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本bfs。

///////////////////////////////////////////////////////////////
//
// lc1311. Get Watched Videos by Your Friends
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs + sort。

///////////////////////////////////////////////////////////////
//
// lc1313. Decompress Run-Length Encoded List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本array operation。

///////////////////////////////////////////////////////////////
//
// lc1314. Matrix Block Sum (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 先算出dp[i][j]，表示(0,0)到(i,j)的總和
	再來res[i][j] = res[i+k][j+k] - res[i+k][j-k-1] 
								 - res[i-k-1][j+k] 
								 + res[i-k-1][j-k-1]

///////////////////////////////////////////////////////////////
//
// lc1315. Sum of Nodes with Even-Valued Grandparent
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) dfs，類似lc337。

///////////////////////////////////////////////////////////////
//
// lc1317. The K Weakest Rows in a Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) binary search + priority queue。
	O(m*(logn + logm) + klogm)
(2) binary search + set。
	O(m*(logn + logm) + k)

///////////////////////////////////////////////////////////////
//
// lc1319. Number of Operations to Make Network Connected
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) union find

///////////////////////////////////////////////////////////////
//
// lc1325. Delete Leaves With a Given Value
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder。

///////////////////////////////////////////////////////////////
//
// lc1331. Rank Transform of an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort index，add to result array。

///////////////////////////////////////////////////////////////
//
// lc1337. The K Weakest Rows in a Matrix
//
///////////////////////////////////////////////////////////////

(1) bucket sort
	O(m*n + max(k, 100))
(2) binary search + priority queue。
	O(m*(logn + logm) + klogm)
(3) binary search + set。
	O(m*(logn + logm) + k)

///////////////////////////////////////////////////////////////
//
// lc1338. Reduce Array Size to The Half
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bucket sort
(2) priority queue

///////////////////////////////////////////////////////////////
//
// lc1339. Maximum Product of Splitted Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 兩次postorder，第一次算總和，第二次算乘積最大值。

///////////////////////////////////////////////////////////////
//
// lc1346. Check If N and Its Double Exist
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find pair of nums[i]*2 or nums[i]/2。

///////////////////////////////////////////////////////////////
//
// lc1347. Minimum Number of Steps to Make Two Strings Anagram
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 計算s的出現次數，扣除t的出現次數，若有負的，表示需要轉換的，把負的加總
	即為答案。
(2) 維持兩個cnt，取min(cnt1[i], cnt2[i])，表示絕對不用換的字母，加總res
	return s.size() - res。

///////////////////////////////////////////////////////////////
//
// lc1351. Count Negative Numbers in a Sorted Matrix
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc74。
(1) O(m+n)，因為row & col sorted，從右上角開始往左下角走。

///////////////////////////////////////////////////////////////
//
// lc1353. Maximum Number of Events That Can Be Attended (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) sort events。
	利用min priority queue，維持一d表示當前available time，
	將所有start == d 的end加入queue，並檢查queue中的end若 < d，都pop。

///////////////////////////////////////////////////////////////
//
// lc1359. Count All Valid Pickup and Delivery Options (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) for n-1 pairs, the first one can be inserted into 2*(n-1)+1
	positions, and the second one can be inserted into 2*n positions
	so # of methods are (2*n-1) * 2*n
	因為有順序，要/2，所以為 (2n-1)*n。

///////////////////////////////////////////////////////////////
//
// lc1365. How Many Numbers Are Smaller Than the Current Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bucket sort，bucket[i]表示所有比i小的數量總和。
	time: O(n)。

///////////////////////////////////////////////////////////////
//
// lc1366. Rank Teams by Votes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於每個ch計算得到的votes數量。
	m: # of votes, n: # of teams
	count votes: O(m*n)
	sort: O(n^2logn)

///////////////////////////////////////////////////////////////
//
// lc1367. Linked List in Binary Tree (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前點，直接對link list往下找，若都找到reutrn true，不然就遞迴。

///////////////////////////////////////////////////////////////
//
// lc1372. Longest ZigZag Path in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，維持當前node是parent的left還是right direction。
	若是left，則取自己right child return的value，反之。

///////////////////////////////////////////////////////////////
//
// lc1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1380. Lucky Numbers in a Matrix (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) O(1) space
	let A(i,j) be the min of row i, max of col j,
	if there exists another A(i',j') as lucky number,
	(1) A(i',j') > A(i,j') > A(i, j)
	(2) A(i',j) > A(i',j')
	so A(i',j) > A(i,j)
	based on lucky number definition, its a contradiction,
	so there exists only one lucky number in a matrix.

(2) O(m+n) space，維持rowv，colv表示該row的最小值和該col的最大值。

///////////////////////////////////////////////////////////////
//
// lc1385. Find the Distance Value Between Two Arrays (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

(1) O(m*n)，brute force
(2) O(nlogn)，先sort，
	i 表示當前index in arr1，j表示對於到目前為止的i，都0~j-1和0~i相差都>d。
	結束loop時，看i~n1-1都要放入res。

///////////////////////////////////////////////////////////////
//
// lc1389. Create Target Array in the Given Order (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(nlogn)，類似lc315。
	想像一下，題目要求，i < j，index[i] >= index[j]，則index[i]要往右移一位。
	可以用divide and conquer，依照最終index去做排序。
	if (index[i] + shift >= index[j]) {
		res.push_back(index[j])
		shift += 1 --> 這裡表示因為index[j]要插在index[i]前面，shift要加一。
	} else {
		res.push_back(index[i]+shift) --> update index[i]最終位置，並且
										  放到res裡。
	}
(2) O(n^2)，一般insertion方法。將i開始全都往後移一位。

///////////////////////////////////////////////////////////////
//
// lc1391. Check if There is a Valid Path in a Grid (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 對於當前，先到下一點，再對下一點back回去，若可以回到當前點，表示下一點
	是合法圖形。
	用visit來判斷下一點有沒有走過，若有就跳過。加入queue就標記走過。

///////////////////////////////////////////////////////////////
//
// lc1394. Find Lucky Integer in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。

///////////////////////////////////////////////////////////////
//
// lc1395. Count Number of Teams (看)*
//
///////////////////////////////////////////////////////////////

(1) O(n^3)，暴力解。
(2) 對於每個candidate，跑一次回圈
	維持兩個變數vector<int> less, greater。
	less[0]表示在左邊比自己小，less[1]表示在右邊比自己小。
	greater[0]表示在左邊比自己大，greater[1]表示在右邊比自己大。
	res = less[0] * greater[1] + greater[0] * less[1]。

///////////////////////////////////////////////////////////////
//
// lc1396. Design Underground System (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 考慮edge case，利用map紀錄，key: start_end，value: {total_time, cnt}
	第二個map是個人資料，key: id，value: {start, start_time}

///////////////////////////////////////////////////////////////
//
// lc1399. Count Largest Group
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) count digit。

///////////////////////////////////////////////////////////////
//
// lc1403. Minimum Subsequence in Non-Increasing Order
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort。
(2) nlogn sort。

///////////////////////////////////////////////////////////////
//
// lc1409. Queries on a Permutation With Key (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lru cache的方式去做，O(n^2)
(2) 利用bit，binary index tree。
(3) 利用segment tree。
	(2) 和 (3)都想像成range sum，arr[0,i]表示0~i的個數，也就是對於i+1位置
	中，前面有幾個number。
	因為題目要求當前number是在arr中第幾個位置，想像成每個位置都是1，那就是說
	given index i，他前面的數量就是rangesum(0,i-1)。
	另外用map紀錄number和其對應在arr的位置。

///////////////////////////////////////////////////////////////
//
// lc1413. Minimum Value to Get Positive Step by Step Sum
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為在每個for loop step sum > 0，表示追蹤minimum sum of for loop，
	return -minv + 1。
(2) 對於每輪若sum < 1，補足到1，即 res += 1-sum。

///////////////////////////////////////////////////////////////
//
// lc1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 2

greedy method。
always find the largest one less than K。
(1) recursion
	Time O((logk)^2), since O(log k) Fibonacci numbers smaller than k.
	Space O(logK), can be saved by tail recursion.
(2) iteration
	Time O((logk))
	Space O(1)

///////////////////////////////////////////////////////////////
//
// lc1427. Perform String Shifts
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) string concatenation

///////////////////////////////////////////////////////////////
//
// lc1429. First Unique Number (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc146 lru，用list和map紀錄list得iterator。
	find first unique: O(1)
(2) 用queue和map，map紀錄出現次數，若為1，push to que。
	find first unique: O(n)

///////////////////////////////////////////////////////////////
//
// lc1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1431. Kids With the Greatest Number of Candies
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) find maxv then check if candies[i] + extra >= maxv。

///////////////////////////////////////////////////////////////
//
// lc1433. Check If a String Can Break Another String (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bucket sort，從0~25，計算兩者當前數量，若次數交錯，表示不能break。
(2) nlogn sort

///////////////////////////////////////////////////////////////
//
// lc1441. Build an Array With Stack Operations
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) When we find target[i] is greater than current number, 
	just push and pop and update it until they are equal.

///////////////////////////////////////////////////////////////
//
// lc1443. Minimum Time to Collect All Apples in a Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) build graph first, start from 0, use dfs.
	We add 2 to res when we have collect all return value from
	our descendents that sum is bigger than 0 or current node is an apple.

///////////////////////////////////////////////////////////////
//
// lc1448. Count Good Nodes in Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。
(2) preorder。

///////////////////////////////////////////////////////////////
//
// lc1450. Number of Students Doing Homework at a Given Time
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本判斷interval。

///////////////////////////////////////////////////////////////
//
// lc1460. Make Two Arrays Equal by Reversing Sub-arrays
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bucket sort
(2) a. use xor to check if bit counting is same between arr and target.
	b. check if target sum is equal to arr sum.

///////////////////////////////////////////////////////////////
//
// lc1464. Maximum Product of Two Elements in an Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) use pointer to linear find

///////////////////////////////////////////////////////////////
//
// lc1466. Reorder Routes to Make All Paths Lead to the City Zero
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用rel map來判斷當前邊的關係，比如 a->b，
	rel[a].push_back({b, 1})
	rel[b].push_back({a, 0})
	這樣在做bfs就可以知道若連過去的是1，++res。

///////////////////////////////////////////////////////////////
//
// lc1469. Find All The Lonely Nodes (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用tag來判斷當前node是不是lonley，
	ex: preorder(root->left, !root->right)
	ex: preorder(root->right, !root->left)

///////////////////////////////////////////////////////////////
//
// lc1472. Design Browser History
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2，3

(1) two stack，history & future，注意history size 必須大於1。
	visit時，future clear.
(2) list，維持now & end，注意visit，如果++now >= arr.size()，push_back()
	否則，arr[now] = url
(3) unordered_map
	visit: map[++now] = url, end = now

///////////////////////////////////////////////////////////////
//
// lc1474. Delete N Nodes After M Nodes of a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one pass，對於n，now->next = now->next->next。這樣now不用動但可以
	一直接下一個。

///////////////////////////////////////////////////////////////
//
// lc1480. Running Sum of 1d Array
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 單純累加上一位的值。

///////////////////////////////////////////////////////////////
//
// lc1485. Clone Binary Tree With Random Pointer
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) 類似lc138，O(1) space, three pass，必須NodeCopy class和Node class
	一致才行
(2) 利用map，O(n) space, one pass。

///////////////////////////////////////////////////////////////
//
// lc1490. Clone N-ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

類似lc133
(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1507. Reformat Date
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 判斷長度來檢查是1 ~ 9還是 > 10來做substr。

///////////////////////////////////////////////////////////////
//
// lc1512. Number of Good Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) prefix sum

///////////////////////////////////////////////////////////////
//
// lc1522. Diameter of N-Ary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc543。

///////////////////////////////////////////////////////////////
//
// lc1530. Number of Good Leaf Nodes Pairs
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) postorder，track左子樹leaf和右子樹leaf的距離和 <= d。

///////////////////////////////////////////////////////////////
//
// lc1539. Kth Missing Positive Number
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc1060。
	唯一差別是要從1開始算。

///////////////////////////////////////////////////////////////
//
// lc1583. Count Unhappy Friends (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n^2)，紀錄preference，這樣就可以從O(n^3)變成O(n^2)。

///////////////////////////////////////////////////////////////
//
// lc1586. Binary Search Tree Iterator II (看)*
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc173。
	inorder stack traversal，將前後串連起來

///////////////////////////////////////////////////////////////
//
// lc1600. Throne Inheritance
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本dfs。

///////////////////////////////////////////////////////////////
//
// lc1602. Find Nearest Right Node in Binary Tree (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1，2

(1) bfs
(2) preorder morris traversal，注意計算深度問題。

///////////////////////////////////////////////////////////////
//
// lc1609. Even Odd Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用bfs，和sign來判斷當前要是even level or odd level。

///////////////////////////////////////////////////////////////
//
// lc1612. Check If Two Expression Trees are Equivalent (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) preorder，利用cnt(26, 0)紀錄出現的次數
follow up: 如果root是'-'，left subtree不會被影響，right subtree sign*=-1。

///////////////////////////////////////////////////////////////
//
// lc1614. Maximum Nesting Depth of the Parentheses
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) linear search。

///////////////////////////////////////////////////////////////
//
// lc1615. Maximal Network Rank (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用unordered_set記錄自己有連到幾個，跑一個O(n^2)，去算出最大的兩個邊。
	O(n^2)
	follow up: if average m is O(n), design a O(n) algo
follow up:
	1. 若最大數量的node只有一個，對於其他的node算出和最大數量的和，若這兩node有
	邊必須扣掉一。
	2. 若有兩個以上，想像若這些node 為m，若 m*(m-1)/2 > connect 這些彼此node
	的邊數量，代表一定有兩個node屬於最大數量邊，且沒有邊連這兩個，不用-1。
	note: fully connected of n nodes, its edge = n*(n-1)/2。

///////////////////////////////////////////////////////////////
//
// lc1640. Check Array Formation Through Concatenation
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用map來儲存第一個pieces的type，然後對於arr的第一個數去找對應的type，
	並iterate 該pices。

///////////////////////////////////////////////////////////////
//
// lc1644. Lowest Common Ancestor of a Binary Tree II
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 變形postordeder，遇到p或q，++cnt，cnt == 2才有lca。

///////////////////////////////////////////////////////////////
//
// lc1650. Lowest Common Ancestor of a Binary Tree III
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 類似lc160
	O(log(n)) time O(1) space

///////////////////////////////////////////////////////////////
//
// lc1654. Minimum Jumps to Reach Home (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs，建立queue with state，表示當前到position是foward or backward
	利用visit表示這個點有沒有到過，被foward到過或是backward到過。
	關於maxval，
	if (a >= b)，maxval = x+b
	if (a < b)，maxval = x+a+a+b
	https://leetcode.com/problems/minimum-jumps-to-reach-home/
	discuss/935419/Python-deque-BFS-O(max(x-max(forbidden))%2Ba%2Bb)

///////////////////////////////////////////////////////////////
//
// lc1657. Determine if Two Strings Are Close (看)
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) O(n) bucket sort
	if (n < 26log26) then O(26log26)。

///////////////////////////////////////////////////////////////
//
// lc1660. Correct a Binary Tree
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) bfs with map，利用parent map記錄自己的parent是誰，若當前自己right
	child被指過，表示自己的孩子和自己同一層，now->right = null，且自己
	的parent對自己設置null。

///////////////////////////////////////////////////////////////
//
// lc1666. Change the Root of a Binary Tree (看)**
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 利用recursion，當前有new parent，
	規則是如果當前now->left = new parent，則now->left = null，反之。
	old parent = now->parent
	now->parent = new parent，建立新的parent。
	且若當前砍掉連接後還有左孩子，則讓他變成右孩子。因為left child 要去接
	自己的parent: now->left = recursion(old_parent, now)。

///////////////////////////////////////////////////////////////
//
// lc1668. Maximum Repeating Substring
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 因為要找最大的k，repeat word for max k times and find this word
	in input string。

///////////////////////////////////////////////////////////////
//
// lc1669. Merge In Between Linked Lists
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) linear pass。

///////////////////////////////////////////////////////////////
//
// lc1676. Lowest Common Ancestor of a Binary Tree IV
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) 基本postorder，利用unordered set來記錄node。

///////////////////////////////////////////////////////////////
//
// lc1721. Swapping Nodes in a Linked List
//
///////////////////////////////////////////////////////////////

最佳解： method 1

(1) one pass
** follow up: change structure, maintain p1, n1, p2, n2
注意若 n1 == p2 or n2 == p1，要做相鄰的處理
且n2 == p1，要swap node，因為我們assume p1在左邊，p2在右邊做處理。